[
    {
        "name": "Biome",
        "members": [
            {
                "type": "std::string",
                "name": "name",
                "description": "the name that is exposed to lua functions that spawn entities"
            },
            {
                "type": "std::string",
                "name": "background_image",
                "description": "path to the image file (texture) that is used for the background"
            },
            {
                "type": "std::string",
                "name": "background_edge_left",
                "description": "if not empty, will use this image as the left edge"
            },
            {
                "type": "std::string",
                "name": "background_edge_right",
                "description": "if not empty, will use this image as the right edge"
            },
            {
                "type": "std::string",
                "name": "background_edge_top",
                "description": "if not empty, will use this image as the top edge"
            },
            {
                "type": "std::string",
                "name": "background_edge_bottom",
                "description": "if not empty, will use this image as the bottom edge"
            },
            {
                "type": "int",
                "name": "background_edge_priority",
                "example": "0 [0, 1]",
                "description": "if both biomes have edges defined, will use the one with higher priority (if priority is same, will compare (>) background_images)"
            },
            {
                "type": "bool",
                "name": "background_use_neighbor",
                "example": "0 [0, 1]",
                "description": "if set will look for neighboring biomes and use their background image"
            },
            {
                "type": "float",
                "name": "background_image_height",
                "example": "225 [0, 1]",
                "description": "height were the background image starts"
            },
            {
                "type": "bool",
                "name": "limit_background_image",
                "example": "1 [0, 1]",
                "description": "Will limit the background image to start at the cave height"
            },
            {
                "type": "std::string",
                "name": "bitmap_noise_file",
                "description": "if set, loads it to mBitmapNoise"
            },
            {
                "type": "bool",
                "name": "noise_biome_edges",
                "example": "1 [0, 1]",
                "description": "does the noisy edge for biomes, if either of biomes has this set to 0 will do a straight edge"
            },
            {
                "type": "bool",
                "name": "big_noise_biome_edges",
                "example": "1 [0, 1]",
                "description": "if true, will leak onto other biomes and not be carveable"
            },
            {
                "type": "bool",
                "name": "fat_biome_edges",
                "example": "0 [0, 1]",
                "description": "if true, will leak onto other biomes and not be carveable"
            },
            {
                "type": "bool",
                "name": "skip_edge_textures",
                "example": "0 [0, 1]",
                "description": "skips edge texture generation. Turn of for pixel scenes"
            },
            {
                "type": "std::string",
                "name": "audio_music_enter",
                "description": "the music event that plays when player enters this biome (e.g. 'music/desert/enter')"
            },
            {
                "type": "std::string",
                "name": "audio_music_2",
                "description": "the music directory that plays while player is in this biome (e.g 'coalmine')"
            },
            {
                "type": "float",
                "name": "audio_music_energy_coeff",
                "example": "-188.237 [0, 1]",
                "description": "Multiplier for music energy in this biome"
            },
            {
                "type": "bool",
                "name": "audio_music_no_forced_quietness",
                "example": "195 [0, 1]",
                "description": "If 1, music is not quieted by occasional quietness"
            },
            {
                "type": "int32",
                "name": "audio_music_forced_quietness_duration_seconds",
                "example": "1701869824 [0, 1]",
                "description": "If > 0, this is the duration of occasional quietness, else the value from magic numbers is used."
            },
            {
                "type": "std::string",
                "name": "audio_ambience",
                "example": "avent [0, 1]",
                "description": "the ambience event that plays while player is in this biome"
            },
            {
                "type": "std::string",
                "name": "audio_ambience_surface",
                "example": "ills [0, 1]",
                "description": "the ambience event that plays while player is in this biome and on surface"
            },
            {
                "type": "float",
                "name": "color_grading_r",
                "example": "1 [0, 1]",
                "description": "post fx color grading"
            },
            {
                "type": "float",
                "name": "color_grading_g",
                "example": "1 [0, 1]",
                "description": "post fx color grading"
            },
            {
                "type": "float",
                "name": "color_grading_b",
                "example": "1 [0, 1]",
                "description": "post fx color grading"
            },
            {
                "type": "float",
                "name": "color_grading_grayscale",
                "example": "0 [0, 1]",
                "description": "post fx color grading. [0.0,1.0], larger value means more grayscale"
            },
            {
                "type": "bool",
                "name": "has_rain",
                "example": "15 [0, 1]",
                "description": "if 1, rain or snowfall may occur in this biome"
            },
            {
                "type": "std::string",
                "name": "bitmap_filename",
                "example": "[0, 1]",
                "description": "loads the chunk from this bitmap, the bitmap should be 512x512"
            },
            {
                "type": "std::string",
                "name": "wang_template_file",
                "description": "uses this file to create a herringbone wang map"
            },
            {
                "type": "int",
                "name": "wang_map_width",
                "example": "256 [1, 512]",
                "description": "the size of the wang map"
            },
            {
                "type": "int",
                "name": "wang_map_height",
                "example": "256 [1, 512]",
                "description": "the size of the wang map"
            },
            {
                "type": "std::string",
                "name": "lua_script",
                "description": "default is data/scripts/biomes/NAME.lua"
            },
            {
                "type": "bool",
                "name": "pixel_scene",
                "example": "15 [0, 1]",
                "description": "for 'pixel scene' biomes, this forces the loading before hand "
            },
            {
                "type": "float",
                "name": "game_enemy_hp_scale",
                "example": "1 [0, 1]",
                "description": "1.f = default. Will multiply the hp of the camerabounded enemies in the area with hp_scale"
            },
            {
                "type": "float",
                "name": "game_enemy_attack_speed",
                "example": "1 [0, 1]",
                "description": "1.f = default. This multiplies AnimalAI's attack_ranged_frames_between in camerabounded enemies"
            },
            {
                "type": "bool",
                "name": "mInsideNoiseFBM",
                "example": "15 [0, 1]",
                "description": "will fbm the mInsideNoise if set true"
            },
            {
                "type": "double",
                "name": "mInsidePerlinScaleX",
                "example": "1 [0, 2]",
                "description": "the noise inside the stones..."
            },
            {
                "type": "double",
                "name": "mInsidePerlinScaleY",
                "example": "1 [0, 2]",
                "description": "the noise inside the stones..."
            },
            {
                "type": "bool",
                "name": "mInsidePerlinSquared",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mInsidePerlinClamped",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mInsidePerlinScaled",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mInsidePerlinScaleMin",
                "example": "0 [-2, 2]"
            },
            {
                "type": "float",
                "name": "mInsidePerlinScaleMax",
                "example": "0 [-2, 2]"
            },
            {
                "type": "bool",
                "name": "mInsidePerlinForceInside",
                "example": "0 [0, 1]",
                "description": "if set, will multiply the noise_value with the gradient value "
            },
            {
                "type": "float",
                "name": "mInsideAddValue",
                "example": "0 [0, 5]",
                "description": "added inside the caves the gradient value"
            },
            {
                "type": "float",
                "name": "mMultiplierGradient",
                "example": "1 [0, 1]",
                "description": "how much of the gradient is applied"
            },
            {
                "type": "float",
                "name": "mMultiplierPerlin",
                "example": "1 [0, 1]",
                "description": "how much of the inside noise"
            },
            {
                "type": "float",
                "name": "mMultiplierExtraPerlin",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "mGradientStartY",
                "example": "-512 [-1024, 1024]"
            },
            {
                "type": "float",
                "name": "mGradientEndY",
                "example": "512 [-1024, 1024]"
            },
            {
                "type": "double",
                "name": "mGradientSlopeStartX",
                "example": "0 [-1024, 1024]",
                "description": "if addNoise = 3, will use this to the ( x - mGradientSlopeStartX ) * mGradientSlopeDelta"
            },
            {
                "type": "double",
                "name": "mGradientSlopeDelta",
                "example": "1 [-1024, 1024]",
                "description": "if addNoise = 3, will use this to the ( x - mGradientSlopeStartX ) * mGradientSlopeDelta"
            },
            {
                "type": "int",
                "name": "mGradientAddNoise",
                "example": "1 [0, 1]",
                "description": "fake enum 1=standard noise, 2=fbm noise, 3=slope"
            },
            {
                "type": "double",
                "name": "mGradientNoiseScale",
                "example": "0.01 [0, 0.01]"
            },
            {
                "type": "float",
                "name": "mGradientLowNoise",
                "example": "-100 [-1024, 1024]"
            },
            {
                "type": "float",
                "name": "mGradientHighNoise",
                "example": "100 [-1024, 1024]"
            },
            {
                "type": "bool",
                "name": "coarse_map_force_terrain",
                "example": "0 [0, 1]",
                "description": "if 1, is initially marked as 'terrain' in the coarse map used for sky light calculations etc"
            },
            {
                "type": "bool",
                "name": "coarse_map_not_terrain",
                "example": "0 [0, 1]",
                "description": "if 1, is initially never marked as 'terrain' in the coarse map used for sky light calculations etc"
            },
            {
                "type": "bool",
                "name": "coarse_map_cell_count_always_zero",
                "example": "0 [0, 1]",
                "description": "if 1, areas in this biome always have a 64x64 cell count of 0"
            }
        ],
        "privates": [
            {
                "type": "ceng::CArray2D<uint32>*",
                "name": "bitmap_data",
                "description": "for bitmap loading, well cache it here"
            },
            {
                "type": "BitmapNoise*",
                "name": "mBitmapNoise",
                "description": "load the bitmap noise here"
            },
            {
                "type": "BiomeMaterials*",
                "name": "mBiomeMaterials",
                "description": "this is set when the biome is loaded by BiomeHelper"
            },
            {
                "type": "std::string",
                "name": "mModifierUIDescription",
                "description": "this should be set when the biome has modifiers. will be displayed when entering the biome"
            },
            {
                "type": "std::string",
                "name": "mModifierUIDecorationFile",
                "description": "this should be set when the biome has modifiers. UI 3-piece image to use when displaying modifier message when entering the biome"
            },
            {
                "type": "std::string",
                "name": "mDebugFilename",
                "description": "the file this was loaded from"
            }
        ],
        "objects": [
            {
                "type": "BiomeModifiers",
                "name": "modifiers"
            }
        ],
        "custom_data_types": [
            {
                "type": "BIOME_TYPE::Enum",
                "name": "type",
                "description": "0 = standard, 1 = bitmap level loading, loads the bitmap file"
            },
            {
                "type": "CavesSetup*",
                "name": "BitmapCaves"
            },
            {
                "type": "FOG_OF_WAR_TYPE::Enum",
                "name": "fog_of_war_type",
                "description": "the way removing fog of war works in this biome"
            },
            {
                "type": "RandomizeMaterials*",
                "name": "RandomMaterials",
                "description": "for wang tiles allows color -> random color transform"
            },
            {
                "type": "NOISE_TYPE::Enum",
                "name": "noise_type",
                "description": "the style of the cave noise"
            },
            {
                "type": "GENERAL_NOISE::Enum",
                "name": "mInsideNoiseType",
                "description": "the style of the inside noise"
            }
        ]
    },
    {
        "name": "BiomeModifiers",
        "members": [
            {
                "type": "float",
                "name": "dust_amount",
                "example": "0 [0, 1]",
                "description": "amount of dust rendered"
            },
            {
                "type": "float",
                "name": "projectile_drag_coeff",
                "example": "1 [0, 1]",
                "description": "projectile velocity is multiplied with this value every frame"
            },
            {
                "type": "float",
                "name": "entity_gravity_y_multiplier",
                "example": "1 [-1, 2]",
                "description": "affects the VelocityComponents gravity_y"
            },
            {
                "type": "int8",
                "name": "fog_of_war_delta",
                "description": "fog of war change per frame"
            },
            {
                "type": "uint8",
                "name": "fire_extinguish_chance",
                "description": "probability of fire being extinguished per cell update"
            },
            {
                "type": "uint8",
                "name": "reaction_freeze_chance",
                "description": "probability of spontaneous freezing reactions per cell reaction update"
            },
            {
                "type": "uint8",
                "name": "reaction_unfreeze_chance",
                "description": "probability of spontaneous frozen material melting reactions per cell reaction update"
            },
            {
                "type": "uint8",
                "name": "random_water_stains_chance",
                "description": "probability of random water stains being added to characters"
            },
            {
                "type": "uint8",
                "name": "random_water_stains_amount",
                "description": "number of water cells added when adding random water stains"
            },
            {
                "type": "bool",
                "name": "everything_is_conductive",
                "example": "0 [0, 1]",
                "description": "if 1, every static material in this place conduct electricity"
            }
        ]
    },
    {
        "name": "CavesSetup",
        "members": [
            {
                "type": "std::string",
                "name": "name",
                "description": "we share these based on the names, so make them unique"
            },
            {
                "type": "int",
                "name": "size_x",
                "example": "512 [0, 1]",
                "description": "How big the image is that we generate these from"
            },
            {
                "type": "int",
                "name": "size_y",
                "example": "256 [0, 1]",
                "description": "How big the image is that we generate these from"
            },
            {
                "type": "float",
                "name": "spawn_percent",
                "example": "0.05 [0, 1]",
                "description": "0-1 - with what chance do we add a spawn point to a cave"
            },
            {
                "type": "int",
                "name": "cave_count_min",
                "example": "50 [0, 200]",
                "description": "generates caves n, where n = random(cave_count_min, cave_count_max)"
            },
            {
                "type": "int",
                "name": "cave_count_max",
                "example": "100 [0, 200]",
                "description": "generates caves n, where n = random(cave_count_min, cave_count_max)"
            },
            {
                "type": "bool",
                "name": "do_beginning_paths",
                "example": "0 [0, 1]",
                "description": "if set, will do the paths that go down near the center of the image, used for setting up the caves to coal mines near where player starts"
            },
            {
                "type": "bool",
                "name": "do_beginning_down",
                "example": "0 [0, 1]",
                "description": "if true, will do a hole straight down"
            },
            {
                "type": "int",
                "name": "surface_caves_count_min",
                "example": "7 [0, 200]",
                "description": "generates caves n from the surface, where n = random(surface_caves_count_min, surface_caves_count_max)"
            },
            {
                "type": "int",
                "name": "surface_caves_count_max",
                "example": "12 [0, 200]",
                "description": "generates caves n from the surface, where n = random(surface_caves_count_min, surface_caves_count_max)"
            },
            {
                "type": "float",
                "name": "cave_strength_min",
                "example": "0.2 [0, 1]",
                "description": "how strongly do we carve the cave"
            },
            {
                "type": "float",
                "name": "cave_strength_max",
                "example": "1 [0, 1]",
                "description": "how strongly do we carve the cave"
            },
            {
                "type": "int",
                "name": "cave_childs_min",
                "example": "0 [0, 10]",
                "description": "how many child trails a cave can have"
            },
            {
                "type": "int",
                "name": "cave_childs_max",
                "example": "2 [0, 10]",
                "description": "how many child trails a cave can have"
            },
            {
                "type": "int",
                "name": "surface_cave_childs_min",
                "example": "2 [0, 10]",
                "description": "how many child trails a cave can have"
            },
            {
                "type": "int",
                "name": "surface_cave_childs_max",
                "example": "7 [0, 10]",
                "description": "how many child trails a cave can have"
            },
            {
                "type": "int",
                "name": "mountain_count_min",
                "example": "0 [0, 10]",
                "description": "how many child trails a cave can have"
            },
            {
                "type": "int",
                "name": "mountain_count_max",
                "example": "15 [0, 10]",
                "description": "how many child trails a cave can have"
            },
            {
                "type": "float",
                "name": "mountain_size_min",
                "example": "1 [0, 10]"
            },
            {
                "type": "float",
                "name": "mountain_size_max",
                "example": "10 [0, 10]"
            },
            {
                "type": "int",
                "name": "blob_caves_count_min",
                "example": "20 [0, 50]"
            },
            {
                "type": "int",
                "name": "blob_caves_count_max",
                "example": "55 [0, 100]"
            },
            {
                "type": "float",
                "name": "blob_caves_strength_min",
                "example": "1.5 [0, 50]"
            },
            {
                "type": "float",
                "name": "blob_caves_strength_max",
                "example": "3 [0, 100]"
            },
            {
                "type": "float",
                "name": "blob_caves_radius_min",
                "example": "1 [0, 10]"
            },
            {
                "type": "float",
                "name": "blob_caves_radius_max",
                "example": "10 [0, 10]"
            },
            {
                "type": "std::string",
                "name": "DEBUG_output_image",
                "description": "if set, will save a png of the height map to the file specified here"
            }
        ],
        "privates": [
            {
                "type": "std::string",
                "name": "mLuaScript",
                "description": "this is the Biome::lua_script"
            }
        ],
        "custom_data_types": [
            {
                "type": "VEC_STRUCTURES",
                "name": "structures"
            }
        ]
    },
    {
        "name": "CaveStructure",
        "members": [
            {
                "type": "std::string",
                "name": "image_file",
                "description": "path to image file that's going to be blitted"
            },
            {
                "type": "int",
                "name": "count_min",
                "example": "50 [0, 200]"
            },
            {
                "type": "int",
                "name": "count_max",
                "example": "100 [0, 200]"
            },
            {
                "type": "int",
                "name": "aabb_min_x",
                "example": "50 [0, 200]"
            },
            {
                "type": "int",
                "name": "aabb_min_y",
                "example": "100 [0, 200]"
            },
            {
                "type": "int",
                "name": "aabb_max_x",
                "example": "50 [0, 200]"
            },
            {
                "type": "int",
                "name": "aabb_max_y",
                "example": "100 [0, 200]"
            },
            {
                "type": "float",
                "name": "strength_min",
                "example": "1.5 [0, 2]"
            },
            {
                "type": "float",
                "name": "strength_max",
                "example": "1.5 [0, 2]"
            }
        ]
    },
    {
        "name": "ConfigCutThroughWorld",
        "members": [
            {
                "type": "int32",
                "name": "x",
                "example": "0 [0, 1]"
            },
            {
                "type": "int32",
                "name": "y_min",
                "example": "0 [0, 1]"
            },
            {
                "type": "int32",
                "name": "y_max",
                "example": "0 [0, 1]"
            },
            {
                "type": "int32",
                "name": "radius",
                "example": "0 [0, 1]"
            },
            {
                "type": "int32",
                "name": "edge_darkening_width",
                "example": "0 [0, 1]"
            },
            {
                "type": "uint32",
                "name": "global_id",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ConfigDamageCritical",
        "members": [
            {
                "type": "int",
                "name": "chance",
                "example": "0 [0, 100]",
                "description": "the chance of a critical hit. ]0-100[ - can be higher than 100% - then will multiply the multiplier by the extra"
            },
            {
                "type": "float",
                "name": "damage_multiplier",
                "example": "1 [0, 10]",
                "description": "multiplier that is applied to all damage types on a critical hit"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mSucceeded",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ConfigDamagesByType",
        "members": [
            {
                "type": "float",
                "name": "melee",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "projectile",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "explosion",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "electricity",
                "example": "1 [0, 1]",
                "description": "electricity stun effect is rand[0-1] < electricity"
            },
            {
                "type": "float",
                "name": "fire",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "drill",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "slice",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "ice",
                "example": "1 [0, 1]",
                "description": "freezing stun effect is rand[0-1] < ice"
            },
            {
                "type": "float",
                "name": "healing",
                "example": "1 [0, 1]",
                "description": "healing aka negative damage. this should be given as a negative value."
            },
            {
                "type": "float",
                "name": "physics_hit",
                "example": "1 [0, 1]",
                "description": "damage from being hit with a physics object"
            },
            {
                "type": "float",
                "name": "radioactive",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "poison",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "overeating",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "curse",
                "example": "1 [0, 1]"
            }
        ]
    },
    {
        "name": "ConfigDrugFx",
        "members": [
            {
                "type": "float",
                "name": "distortion_amount",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "color_amount",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "fractals_amount",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "fractals_size",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "nightvision_amount",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "doublevision_amount",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ConfigExplosion",
        "members": [
            {
                "type": "bool",
                "name": "never_cache",
                "example": "1 [0, 1]",
                "description": "if set, won't ever cache and the explosion happens that frame. Used for projectiles"
            },
            {
                "type": "float",
                "name": "explosion_radius",
                "example": "20 [0, 1]",
                "description": "Explosion radius, used to find the peasants and physics bodies that are thrown into the air"
            },
            {
                "type": "std::string",
                "name": "explosion_sprite",
                "example": "data/particles/explosion_032.xml [0, 1]",
                "description": "sprite animation of the explosion that we play"
            },
            {
                "type": "bool",
                "name": "explosion_sprite_emissive",
                "example": "0 [0, 1]",
                "description": "if 1, sprite is emissive"
            },
            {
                "type": "bool",
                "name": "explosion_sprite_additive",
                "example": "0 [0, 1]",
                "description": "if 1, sprite is additive"
            },
            {
                "type": "bool",
                "name": "explosion_sprite_random_rotation",
                "example": "1 [0, 1]",
                "description": "if true, rotates the sprite to random 90 degrees"
            },
            {
                "type": "float",
                "name": "explosion_sprite_lifetime",
                "example": "0 [0, 3.5]",
                "description": "if 0, finds the lifetime based on the rect animation currently playing. If not 0 it is seconds how long does the explosion sprite stay in the world"
            },
            {
                "type": "float",
                "name": "damage",
                "example": "5 [0, 10]",
                "description": "how much damage does this do to living entities"
            },
            {
                "type": "float",
                "name": "camera_shake",
                "example": "7.5 [0, 100]",
                "description": "camera shake - how much we shake the camera"
            },
            {
                "type": "bool",
                "name": "particle_effect",
                "example": "1 [0, 1]",
                "description": "Should we use the ParticleEffect::DoExplosion()"
            },
            {
                "type": "std::string",
                "name": "load_this_entity",
                "description": "if set, this entity is loaded when the explosion is queued"
            },
            {
                "type": "bool",
                "name": "light_enabled",
                "example": "1 [0, 1]",
                "description": "Should the explosion emit light to its surroundings?"
            },
            {
                "type": "float",
                "name": "light_fade_time",
                "example": "0.08 [0, 1]",
                "description": "The time it takes for the light flash to fade out"
            },
            {
                "type": "unsignedint",
                "name": "light_r",
                "example": "255 [0, 255]",
                "description": "Color red 0-255"
            },
            {
                "type": "unsignedint",
                "name": "light_g",
                "example": "217 [0, 255]",
                "description": "Color green 0-255"
            },
            {
                "type": "unsignedint",
                "name": "light_b",
                "example": "180 [0, 255]",
                "description": "Color blue 0-255"
            },
            {
                "type": "float",
                "name": "light_radius_coeff",
                "example": "8 [0, 1]",
                "description": "The radius of the light will be explosion_radius * light_radius_coeff"
            },
            {
                "type": "bool",
                "name": "hole_enabled",
                "example": "1 [0, 1]",
                "description": "Do we remove ground, creata a crater"
            },
            {
                "type": "bool",
                "name": "destroy_non_platform_solid_enabled",
                "example": "1 [0, 1]",
                "description": "Do we remove solid cells that aren't platforms?"
            },
            {
                "type": "int",
                "name": "electricity_count",
                "example": "0 [0, 1]",
                "description": "How many electricity entitities should we create?"
            },
            {
                "type": "int",
                "name": "min_radius_for_cracks",
                "example": "10 [0, 1]",
                "description": "Cracks are created if explosion_radius is larger than this"
            },
            {
                "type": "int",
                "name": "crack_count",
                "example": "10 [0, 1]",
                "description": "How many crack entitities should we create?"
            },
            {
                "type": "float",
                "name": "knockback_force",
                "example": "1 [0, 1]",
                "description": "How far do entities get thrown if a knockback occurs? final_knocback = explosion_radius * knockback_force * target.inv_normalized_distance_from_explosion / target.mass"
            },
            {
                "type": "bool",
                "name": "hole_destroy_liquid",
                "example": "0 [0, 1]",
                "description": "Do we destroy the liquid cells we ran into, or do we just throw them into to the air?"
            },
            {
                "type": "bool",
                "name": "hole_destroy_physics_dynamic",
                "example": "1 [0, 1]",
                "description": "Do we destroy the dynamic physics cells we encountered?"
            },
            {
                "type": "std::string",
                "name": "create_cell_material",
                "example": "fire [0, 1]",
                "description": "The material destroyed cells might turn into."
            },
            {
                "type": "int",
                "name": "create_cell_probability",
                "example": "5 [0, 1]",
                "description": "The probability a destroyed cell is turned into 'create_cell_material'"
            },
            {
                "type": "int",
                "name": "background_lightning_count",
                "example": "0 [0, 1]",
                "description": "Parallax background lightning count is set to this on explosion"
            },
            {
                "type": "std::string",
                "name": "spark_material",
                "example": "spark [0, 1]",
                "description": "spark material, TODO moved these to use a special Serializer"
            },
            {
                "type": "int",
                "name": "material_sparks_min_hp",
                "example": "10000 [0, 100]",
                "description": "How many sparks are we creating (rand max)"
            },
            {
                "type": "int",
                "name": "material_sparks_probability",
                "example": "5 [0, 100]",
                "description": "How many sparks are we creating (rand max)"
            },
            {
                "type": "int",
                "name": "material_sparks_count_min",
                "example": "7 [0, 100]",
                "description": "How many sparks are we creating (rand min)"
            },
            {
                "type": "int",
                "name": "material_sparks_count_max",
                "example": "20 [0, 100]",
                "description": "How many sparks are we creating (rand max)"
            },
            {
                "type": "bool",
                "name": "material_sparks_enabled",
                "example": "0 [0, 1]",
                "description": "Should we create few fire particles around the explosion"
            },
            {
                "type": "bool",
                "name": "material_sparks_real",
                "example": "0 [0, 1]",
                "description": "if the spark particles created are real or fake"
            },
            {
                "type": "bool",
                "name": "material_sparks_scale_with_hp",
                "example": "0 [0, 1]",
                "description": "if true, will create more sparks the harder the material"
            },
            {
                "type": "bool",
                "name": "sparks_enabled",
                "example": "1 [0, 1]",
                "description": "Should we create few fire particles around the explosion"
            },
            {
                "type": "int",
                "name": "sparks_count_min",
                "example": "7 [0, 100]",
                "description": "How many sparks are we creating (rand min)"
            },
            {
                "type": "int",
                "name": "sparks_count_max",
                "example": "20 [0, 100]",
                "description": "How many sparks are we creating (rand max)"
            },
            {
                "type": "float",
                "name": "sparks_inner_radius_coeff",
                "example": "0.333 [0, 1]",
                "description": "If 'sparks_enabled', Sparks are created in the area between circles defined by 'explosion_radius'*'sparks_inner_radius_coeff' and 'explosion_radius'"
            },
            {
                "type": "bool",
                "name": "stains_enabled",
                "example": "1 [0, 1]",
                "description": "Should we stain the ground and other particles"
            },
            {
                "type": "float",
                "name": "stains_radius",
                "example": "0 [0, 1]",
                "description": "The distance from the edge of the hole to the edge of the stained area, 0.0f for default which is 0.3 * explosion_radius"
            },
            {
                "type": "int",
                "name": "ray_energy",
                "example": "20000 [0, 1]",
                "description": "This is the energy we have per ray. Could be called 'penetration power' or something like that. If cells have a hp of 20 rays with 100 energy can penetrate 5 cells"
            },
            {
                "type": "int",
                "name": "max_durability_to_destroy",
                "example": "10 [0, 1]",
                "description": "When destroying cells only cells with a durability <= max_durability_to_destroy will be affected"
            },
            {
                "type": "int",
                "name": "gore_particle_count",
                "example": "1 [0, 1]",
                "description": "How many particles to create in case we do gore stuff?"
            },
            {
                "type": "bool",
                "name": "shake_vegetation",
                "example": "1 [0, 1]",
                "description": "Should we shake vegetation around the explosion (uses the area of stain_image to find vegetation)"
            },
            {
                "type": "bool",
                "name": "damage_mortals",
                "example": "1 [0, 1]",
                "description": "Look for peasants and throw them into the air? Remember to enabled physics_throw as well if you want them to actually fly"
            },
            {
                "type": "bool",
                "name": "physics_throw_enabled",
                "example": "1 [0, 1]",
                "description": "Should we throw physics objects into the air, also peasants"
            },
            {
                "type": "float",
                "name": "physics_multiplier_ragdoll_force",
                "example": "1 [0, 100]",
                "description": "treat the ragdolls a bit differently from other physics objects, to get them to fly nicely"
            },
            {
                "type": "float",
                "name": "cell_explosion_power",
                "example": "1 [0, 100]",
                "description": "used when a solid cell explodes as the multiplier to how big the radius is going to be"
            },
            {
                "type": "float",
                "name": "cell_explosion_radius_min",
                "example": "5 [0, 10]",
                "description": "when cell explodes, this is the minimum radius that explosion is made of"
            },
            {
                "type": "float",
                "name": "cell_explosion_radius_max",
                "example": "150 [0, 10]",
                "description": "when cell explodes, this is the minimum radius that explosion is made of"
            },
            {
                "type": "float",
                "name": "cell_explosion_velocity_min",
                "example": "0 [0, 10]",
                "description": "cell explodes only when body velocity is greater than this"
            },
            {
                "type": "float",
                "name": "cell_explosion_damage_required",
                "example": "100 [0, 1024]",
                "description": "how much fire damage is required before this explodes"
            },
            {
                "type": "float",
                "name": "cell_explosion_probability",
                "example": "0 [0, 1]",
                "description": "this is used when there's a tiny contact that doesn't cause an explosion, in those cases this is used as a random to check if we should explode or not"
            },
            {
                "type": "float",
                "name": "cell_explosion_power_ragdoll_coeff",
                "example": "0.75 [0, 2]",
                "description": "ragdoll cells destruction power is multiplied with this"
            },
            {
                "type": "bool",
                "name": "pixel_sprites_enabled",
                "example": "1 [0, 1]",
                "description": "if enabled will carve out the pixel sprites"
            },
            {
                "type": "bool",
                "name": "is_digger",
                "example": "0 [0, 1]",
                "description": "if 1, we apply some special digger logic to this explosion"
            },
            {
                "type": "bool",
                "name": "audio_enabled",
                "example": "1 [0, 1]",
                "description": "Do we play an explosion sound?"
            },
            {
                "type": "std::string",
                "name": "audio_event_name",
                "description": "Name of audio event in 'explosion' audio bank. If not set, will default to 'explosion' or 'explosion_small' based on explosion radius."
            },
            {
                "type": "float",
                "name": "audio_liquid_amount_normalized",
                "example": "0 [0, 1]",
                "description": "value of the 'liquid_amount' parameter passed to the explosion's audio event"
            },
            {
                "type": "int",
                "name": "explosion_delay_id",
                "example": "-1 [-1, 1024]",
                "description": "for delayed barrel explosions... this has to be set and has to be the same for the explosions for there to be a delay"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "who_is_responsible",
                "example": "0 [0, 1]",
                "description": "the entity that caused the explosion"
            },
            {
                "type": "EntityID",
                "name": "dont_damage_this",
                "example": "0 [0, 1]",
                "description": "if set, this entity doesn't receive damage from the explosion"
            },
            {
                "type": "EntityID",
                "name": "impl_send_message_to_this",
                "example": "0 [0, 1]"
            },
            {
                "type": "types::vector2",
                "name": "impl_position"
            },
            {
                "type": "int32",
                "name": "impl_delay_frame",
                "example": "0 [0, 1]"
            }
        ],
        "objects": [
            {
                "type": "ConfigDamageCritical",
                "name": "damage_critical",
                "description": "critical damage config. NOTE: must be already calculated ('chance' does nothing)."
            }
        ],
        "custom_data_types": [
            {
                "type": "ValueRange",
                "name": "physics_explosion_power",
                "description": "how hard do we throw physics objects"
            },
            {
                "type": "ValueRangeInt",
                "name": "delay",
                "description": "if > 0, the explosion occurs with a delay chosen randomly from this range and is never buffered"
            }
        ]
    },
    {
        "name": "ConfigGunActionInfo",
        "members": [
            {
                "type": "std_string",
                "name": "action_id"
            },
            {
                "type": "std_string",
                "name": "action_name"
            },
            {
                "type": "std_string",
                "name": "action_description"
            },
            {
                "type": "std_string",
                "name": "action_sprite_filename"
            },
            {
                "type": "std_string",
                "name": "action_unidentified_sprite_filename",
                "example": "data/ui_gfx/gun_actions/unidentified.png [0, 1]"
            },
            {
                "type": "int",
                "name": "action_type",
                "example": "0 [0, 1]"
            },
            {
                "type": "std_string",
                "name": "action_spawn_level",
                "description": "comma separated values should match probabilities"
            },
            {
                "type": "std_string",
                "name": "action_spawn_probability",
                "description": "comma separated values should match levels"
            },
            {
                "type": "std_string",
                "name": "action_spawn_requires_flag",
                "description": "if set, requires that this persistent flag is set for spawn probablities to be something else than 0"
            },
            {
                "type": "bool",
                "name": "action_spawn_manual_unlock",
                "example": "0 [0, 1]",
                "description": "if true, will not automatically call AddFlagPersistent( action_spawn_requires_flag ) when this action is spawned. You must do it yourself! "
            },
            {
                "type": "int",
                "name": "action_max_uses",
                "example": "-1 [0, 1]",
                "description": "-1 = infinite otherwise it's the amount specified"
            },
            {
                "type": "std_string",
                "name": "custom_xml_file",
                "description": "if set, this will be used instead of 'action.xml'"
            },
            {
                "type": "float",
                "name": "action_mana_drain",
                "example": "10 [0, 1]",
                "description": "how much mana does this action drain?"
            },
            {
                "type": "bool",
                "name": "action_is_dangerous_blast",
                "example": "0 [0, 1]",
                "description": "TODO - is this used anywhere?"
            },
            {
                "type": "int",
                "name": "action_draw_many_count",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "action_ai_never_uses",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "action_never_unlimited",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "state_shuffled",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "state_cards_drawn",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "state_discarded_action",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "state_destroyed_action",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "fire_rate_wait",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "speed_multiplier",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "child_speed_multiplier",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "dampening",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "explosion_radius",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "spread_degrees",
                "example": "0 [0, 180]",
                "description": "in 360 degrees, randomizes the direction of the bullet -spread_degrees to +spread_degrees"
            },
            {
                "type": "float",
                "name": "pattern_degrees",
                "example": "0 [0, 180]",
                "description": "in 360 degrees, if != 0, distributes the bullets to an even pattern from -pattern_degrees to +pattern_degrees"
            },
            {
                "type": "float",
                "name": "screenshake",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "recoil",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_melee_add",
                "example": "0 [0, 1]",
                "description": "TODO - is this used anywhere?"
            },
            {
                "type": "float",
                "name": "damage_projectile_add",
                "example": "0 [0, 1]",
                "description": "if change to mul - take into account that default is 0"
            },
            {
                "type": "float",
                "name": "damage_electricity_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_fire_add",
                "example": "0 [0, 1]",
                "description": "TODO - is this used anywhere?"
            },
            {
                "type": "float",
                "name": "damage_explosion_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_ice_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_slice_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_healing_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_curse_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_drill_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "damage_critical_chance",
                "example": "0 [0, 100]",
                "description": "the chance of a critical hit. ]0-100["
            },
            {
                "type": "float",
                "name": "damage_critical_multiplier",
                "example": "0 [0, 10]",
                "description": "multiplier that is applied to all damage types on a critical hit"
            },
            {
                "type": "float",
                "name": "explosion_damage_to_materials",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "knockback_force",
                "example": "0 [0, 1]",
                "description": "how much knockback it does to enemies"
            },
            {
                "type": "int",
                "name": "reload_time",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "lightning_count",
                "example": "0 [0, 1]"
            },
            {
                "type": "std_string",
                "name": "material"
            },
            {
                "type": "int",
                "name": "material_amount",
                "example": "0 [0, 1]"
            },
            {
                "type": "std_string",
                "name": "trail_material"
            },
            {
                "type": "int",
                "name": "trail_material_amount",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "bounces",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "gravity",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "light",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "blood_count_multiplier",
                "example": "1 [0, 1]",
                "description": "ProjectileComponent has blood_count_multiplier, it tells how much blood is generated when this hits an entity. These are multiplied together..."
            },
            {
                "type": "int",
                "name": "gore_particles",
                "example": "0 [0, 1]",
                "description": "amount of blood particles generated by the explosion"
            },
            {
                "type": "int",
                "name": "ragdoll_fx",
                "example": "0 [0, 1]",
                "description": "ragdoll_fx of the projectile, selects the highest 1 = normal, 2 = gore"
            },
            {
                "type": "bool",
                "name": "friendly_fire",
                "example": "0 [0, 1]",
                "description": "if 1, will set friendly fire on to the bullet"
            },
            {
                "type": "float",
                "name": "physics_impulse_coeff",
                "example": "0 [0, 1]",
                "description": "projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity"
            },
            {
                "type": "int",
                "name": "lifetime_add",
                "example": "0 [0, 1]"
            },
            {
                "type": "std_string",
                "name": "sprite"
            },
            {
                "type": "std_string",
                "name": "extra_entities",
                "description": "comma separated xml files, that are loaded into the projectile entity. Their components get added but nothing else from the xml files is loaded"
            },
            {
                "type": "std_string",
                "name": "game_effect_entities",
                "description": "comma separated xml files, that have the game effects when they hit the entity"
            },
            {
                "type": "std_string",
                "name": "sound_loop_tag",
                "description": "If wand has a SoundLoopComponent with this tag it will start playing when this is shot"
            },
            {
                "type": "std_string",
                "name": "projectile_file"
            }
        ]
    },
    {
        "name": "ConfigGun",
        "members": [
            {
                "type": "int",
                "name": "actions_per_round",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "shuffle_deck_when_empty",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "reload_time",
                "example": "40 [0, 1]"
            },
            {
                "type": "int",
                "name": "deck_capacity",
                "example": "2 [0, 1]",
                "description": "e.g. deck size, how many cards can be put into this gun"
            }
        ]
    },
    {
        "name": "ConfigLaser",
        "members": [
            {
                "type": "int32",
                "name": "max_cell_durability_to_destroy",
                "example": "12 [0, 1]"
            },
            {
                "type": "uint32",
                "name": "damage_to_cells",
                "example": "5000 [0, 1]"
            },
            {
                "type": "float",
                "name": "max_length",
                "example": "512 [0, 1]"
            },
            {
                "type": "float",
                "name": "beam_radius",
                "example": "2.5 [0, 1]"
            },
            {
                "type": "int32",
                "name": "beam_particle_chance",
                "example": "110 [0, 1]"
            },
            {
                "type": "float",
                "name": "beam_particle_fade",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "beam_particle_fade_reverse",
                "example": "0 [0, 1]"
            },
            {
                "type": "int32",
                "name": "hit_particle_chance",
                "example": "20 [0, 1]"
            },
            {
                "type": "bool",
                "name": "audio_enabled",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "audio_hit_always_enabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_to_entities",
                "example": "0.1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "root_entity_is_responsible_for_damage",
                "example": "0 [0, 1]",
                "description": "If 1, damage from laser to entities will be treated as if it was caused by the laser emitter's root entity"
            }
        ],
        "custom_data_types": [
            {
                "type": "int32",
                "name": "beam_particle_type",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ConfigNpcParty",
        "members": [
            {
                "type": "bool",
                "name": "entities_exist",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "direction",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "speed",
                "example": "10 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "position"
            },
            {
                "type": "VECTOR_ENTITYID",
                "name": "member_entities"
            },
            {
                "type": "VECTOR_STRING",
                "name": "member_files"
            }
        ]
    },
    {
        "name": "ConfigParallaxBackground",
        "members": [
            {
                "type": "bool",
                "name": "debug",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "init_randomize",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "storm_clouds_pos_y_0",
                "example": "130 [-256, 256]"
            },
            {
                "type": "float",
                "name": "storm_clouds_pos_y_1",
                "example": "40 [-256, 256]"
            },
            {
                "type": "float",
                "name": "storm_alpha_0",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "storm_alpha_1",
                "example": "0.6 [0, 1]"
            },
            {
                "type": "float",
                "name": "parallax_offset_y",
                "example": "50 [-200, 200]"
            },
            {
                "type": "float",
                "name": "mountains_01_offset_y",
                "example": "0 [-200, 200]"
            },
            {
                "type": "float",
                "name": "mountains_02_offset_y",
                "example": "0 [-200, 200]"
            },
            {
                "type": "float",
                "name": "clouds_01_offset_y_min",
                "example": "0 [-200, 200]"
            },
            {
                "type": "float",
                "name": "clouds_01_offset_y_max",
                "example": "0 [-200, 200]"
            },
            {
                "type": "float",
                "name": "clouds_02_offset_y_min",
                "example": "0 [-200, 200]"
            },
            {
                "type": "float",
                "name": "clouds_02_offset_y_max",
                "example": "0 [-200, 200]"
            },
            {
                "type": "float",
                "name": "gradient_sky_alpha",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "sunset_alpha",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "cloud_coeff",
                "example": "0.00166667 [0, 1]"
            }
        ]
    },
    {
        "name": "ConfigPendingPortal",
        "members": [
            {
                "type": "uint32",
                "name": "id",
                "example": "0 [0, 1]"
            },
            {
                "type": "uint32",
                "name": "target_id",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_at_home",
                "example": "0 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "target_biome_name"
            }
        ],
        "privates": [
            {
                "type": "Entity*",
                "name": "entity"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "position"
            },
            {
                "type": "vec2",
                "name": "target_position"
            }
        ]
    },
    {
        "name": "ConfigSound",
        "members": [
            {
                "type": "std::string",
                "name": "file"
            },
            {
                "type": "bool",
                "name": "stream",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_3d",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "loop",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "random_volume_min",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "random_volume_max",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "random_pitch_min",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "random_pitch_max",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "min_distance",
                "example": "0.5 [0, 1]"
            },
            {
                "type": "float",
                "name": "max_distance",
                "example": "100 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "AUDIO_LAYER::Enum",
                "name": "layer"
            }
        ]
    },
    {
        "name": "DebugSettings",
        "members": [
            {
                "type": "bool",
                "name": "mDrawPathFindingGrid",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "DEBUG_RAGDOLL_EXTRA_FORCE",
                "example": "1 [0, 1000]"
            },
            {
                "type": "bool",
                "name": "mRenderPathFinding",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mPauseSimulation",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mPauseSomeSimulation",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mCameraFreeIsSmoothed",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mCameraIsLockedInGameplay",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "camera_light",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mAllowCameraMoveWhenLocked",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mCameraDisableCameraShake",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mCameraTargetOffsetY",
                "example": "0 [-200, 200]"
            },
            {
                "type": "float",
                "name": "mCameraTargetOffsetX",
                "example": "0 [-200, 200]"
            },
            {
                "type": "bool",
                "name": "mPostFxDisabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mGuiDisabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mGuiHalfSize",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mFogOfWarOpenEverywhere",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mTrailerMode",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDayTimeRotationPaused",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mPlayerNeverDies",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mFreezeAI",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mGameAudioVisualization",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mGameMusicDebug",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mGameMusicDebugFades",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mAudioPerformanceDebug",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "B2_Friction",
                "example": "0.05 [0, 1.1]"
            },
            {
                "type": "float",
                "name": "mRecordingCameraStartX",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mRecordingCameraStartY",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "GLOBAL_WE_ARE_DOING_RESET",
                "example": "0 [0, 1]",
                "description": "used to track if we're doing the reset. cassert(false) in places "
            },
            {
                "type": "bool",
                "name": "mSettingWasChanged",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "DebugSettingsOllis",
        "members": [
            {
                "type": "float",
                "name": "airflow_lo_time",
                "example": "0.001 [0, 1]"
            },
            {
                "type": "float",
                "name": "airflow_lo_scale",
                "example": "0.0333 [0.001, 0.5]"
            },
            {
                "type": "float",
                "name": "airflow_lo_force",
                "example": "1 [0, 10]"
            },
            {
                "type": "float",
                "name": "airflow_hi_time",
                "example": "0.001 [0, 1]"
            },
            {
                "type": "float",
                "name": "airflow_hi_scale",
                "example": "0.0333 [0.001, 0.5]"
            },
            {
                "type": "float",
                "name": "airflow_hi_force",
                "example": "0 [0, 10]"
            }
        ]
    },
    {
        "name": "DebugSettingsPetrisDontTouchAndDontMoveToHeader",
        "members": [
            {
                "type": "bool",
                "name": "LIMIT_VELOCITY",
                "example": "1 [0, 1]",
                "description": "if true, will reload wang maps"
            },
            {
                "type": "bool",
                "name": "REGEN_WANG_MAPS",
                "example": "0 [0, 1]",
                "description": "if true, will reload wang maps"
            },
            {
                "type": "bool",
                "name": "DISABLE_GRIDWORLD_RENDERING",
                "example": "0 [0, 1]",
                "description": "disables the rendering so you can check the backgrounds in peace"
            },
            {
                "type": "float",
                "name": "SWIMMING_FORCE",
                "example": "5 [0, 20]"
            },
            {
                "type": "int8",
                "name": "test"
            },
            {
                "type": "uint8",
                "name": "test2"
            },
            {
                "type": "bool",
                "name": "draw_game_stats",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "DEBUG_LOAD_ALL_ENTITIES",
                "example": "0 [0, 1]",
                "description": "CODE WILL TOGGLE THIS OFF AFTER THE EXECUTION! "
            },
            {
                "type": "bool",
                "name": "mDrawUpdateRects",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawBox2D",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawBox2DAABB",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawBox2DVelocities",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawBox2DForces",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawBox2DMassDensity",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawBox2DCollisionGroups",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawJoints",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mBox2DMousePick",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDebugEnabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDebugKeysEnabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawEntities",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mEntityScale",
                "example": "1 [0.001, 1]"
            },
            {
                "type": "bool",
                "name": "mEntityDrawTags",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mEntityDrawFilename",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawWorldChunks",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mDrawWorldChunksScale",
                "example": "0.05 [0.001, 0.3]"
            },
            {
                "type": "float",
                "name": "mDrawWorldChunksPosX",
                "example": "0 [-3560, 2560]"
            },
            {
                "type": "float",
                "name": "mDrawWorldChunksPosY",
                "example": "0 [-3560, 2560]"
            },
            {
                "type": "bool",
                "name": "mDrawBiomeHeight",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDraw64x64CellCounts",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDrawWangMap",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "draw_wang_colors",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mWangMapScale",
                "example": "0.2 [0, 1]"
            },
            {
                "type": "float",
                "name": "mWangMapAlpha",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDebugSpamRandomEntities",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "do_edge",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "physics_impulse_limit",
                "example": "1 [0, 20]"
            },
            {
                "type": "float",
                "name": "physics_multiplier",
                "example": "0.2 [-10, 10]"
            },
            {
                "type": "float",
                "name": "physics_pos_x",
                "example": "3.1 [-10, 10]"
            },
            {
                "type": "float",
                "name": "physics_pos_y",
                "example": "-7.1 [-20, 20]"
            },
            {
                "type": "float",
                "name": "physics_throw_str",
                "example": "376 [0, 1000]"
            },
            {
                "type": "int",
                "name": "physics_damage_frames",
                "example": "10 [0, 60]"
            },
            {
                "type": "float",
                "name": "physics_damage_coeff",
                "example": "0.0333 [0, 1]"
            },
            {
                "type": "int",
                "name": "player_flying_frames",
                "example": "44 [0, 60]"
            },
            {
                "type": "bool",
                "name": "memory_leak_im_gui",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "display_cell_velocities",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDoingVideoCapture",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "DISABLE_ANIMAL_AI",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "std::vector<std::string>",
                "name": "mRandomEntities"
            }
        ]
    },
    {
        "name": "GameStats",
        "members": [
            {
                "type": "bool",
                "name": "dead",
                "example": "0 [0, 1]",
                "description": "is player dead?"
            },
            {
                "type": "int",
                "name": "death_count",
                "example": "0 [0, 1]",
                "description": "for global"
            },
            {
                "type": "int",
                "name": "streaks",
                "example": "0 [0, 1]",
                "description": "tracks winning streaks"
            },
            {
                "type": "uint32",
                "name": "world_seed",
                "example": "0 [0, 1]",
                "description": "writes the world seed that is in use"
            },
            {
                "type": "std::string",
                "name": "killed_by"
            },
            {
                "type": "std::string",
                "name": "killed_by_extra"
            },
            {
                "type": "double",
                "name": "playtime",
                "example": "0 [0, 1]",
                "description": "session playtime in seconds, this does not include time in menus"
            },
            {
                "type": "std::string",
                "name": "playtime_str",
                "description": "session playtime as a string"
            },
            {
                "type": "int",
                "name": "places_visited",
                "example": "0 [0, 1]",
                "description": "places visited"
            },
            {
                "type": "int",
                "name": "enemies_killed",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "heart_containers",
                "example": "0 [0, 1]"
            },
            {
                "type": "int64",
                "name": "hp",
                "example": "100 [0, 1]",
                "description": "max hp"
            },
            {
                "type": "int64",
                "name": "gold",
                "example": "0 [0, 1]"
            },
            {
                "type": "int64",
                "name": "gold_all",
                "example": "0 [0, 1]",
                "description": "all gold, not just what's currently in players inventory"
            },
            {
                "type": "bool",
                "name": "gold_infinite",
                "example": "0 [0, 1]",
                "description": "will be set to true if all of the money is unlocked "
            },
            {
                "type": "int",
                "name": "items",
                "example": "0 [0, 1]",
                "description": "wands,potions,actions"
            },
            {
                "type": "int",
                "name": "projectiles_shot",
                "example": "0 [0, 1]",
                "description": "player, how many projectiles shot?"
            },
            {
                "type": "int",
                "name": "kicks",
                "example": "0 [0, 1]",
                "description": "player, kick count"
            },
            {
                "type": "double",
                "name": "damage_taken",
                "example": "0 [0, 1]",
                "description": "total damage taken"
            },
            {
                "type": "double",
                "name": "healed",
                "example": "0 [0, 1]",
                "description": "when player is healed (by healer, or some other thing, it's tracked here, BUG: Healing liquid isn't tracked here"
            },
            {
                "type": "int",
                "name": "teleports",
                "example": "0 [0, 1]",
                "description": "how many times have we teleported, this is bugged out right now, teleport projectiles are not counted"
            },
            {
                "type": "int",
                "name": "wands_edited",
                "example": "0 [0, 1]",
                "description": "how many wands player has edited"
            },
            {
                "type": "int",
                "name": "biomes_visited_with_wands",
                "example": "0 [0, 1]",
                "description": "used to figure out if a player played a no-wands-run, tracks how many biomes has player entered with wands. Hills doesn't fire Message_VisitedNewBiome so it doesn't count."
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "death_pos"
            }
        ]
    },
    {
        "name": "GlobalStats",
        "members": [
            {
                "type": "int",
                "name": "STATS_VERSION",
                "example": "4 [0, 1]",
                "description": "used to help with stats parsing"
            },
            {
                "type": "int",
                "name": "DEBUG_HOW_MANY_RESETS",
                "example": "0 [0, 1]",
                "description": "how many times have reset this?"
            },
            {
                "type": "bool",
                "name": "DEBUG_FIXED_STATS",
                "example": "0 [0, 1]",
                "description": "this gets set true, if -fix_stats has been used"
            },
            {
                "type": "bool",
                "name": "session_dead",
                "example": "0 [0, 1]",
                "description": "is player dead?"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "DEBUG_HOW_MANY_TIMES_DONE",
                "example": "0 [0, 1]",
                "description": "debug tracker"
            },
            {
                "type": "bool",
                "name": "DEBUG_IS_ON",
                "example": "0 [0, 1]",
                "description": "is debug on"
            }
        ],
        "objects": [
            {
                "type": "GameStats",
                "name": "session",
                "description": "the current run stats"
            },
            {
                "type": "GameStats",
                "name": "highest",
                "description": "stores the highest values of each"
            },
            {
                "type": "GameStats",
                "name": "global",
                "description": "stores the total value of each"
            },
            {
                "type": "GameStats",
                "name": "prev_best",
                "description": "stores the total value of each"
            }
        ],
        "custom_data_types": [
            {
                "type": "STATS_KEY_VALUE_MAP",
                "name": "KEY_VALUE_STATS",
                "description": "tracks causes and counts"
            }
        ]
    },
    {
        "name": "grid::CosmeticParticleConfig",
        "members": [
            {
                "type": "int",
                "name": "m_material_id",
                "example": "1 [0, 100]"
            },
            {
                "type": "bool",
                "name": "cosmetic_force_create",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "render_back",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "render_on_grid",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "draw_as_long",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "airflow_force",
                "example": "0 [-10, 10]"
            },
            {
                "type": "float",
                "name": "airflow_scale",
                "example": "0 [-10, 10]"
            },
            {
                "type": "float",
                "name": "friction",
                "example": "0 [-10, 10]"
            },
            {
                "type": "float",
                "name": "probability",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "particle_single_width",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "fade_based_on_lifetime",
                "example": "1 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "vel"
            },
            {
                "type": "types::aabb",
                "name": "vel_random"
            },
            {
                "type": "uint32",
                "name": "color",
                "example": "0 [0, 1]",
                "description": "if something else than 0 will use this color"
            },
            {
                "type": "ValueRange",
                "name": "lifetime"
            },
            {
                "type": "vec2",
                "name": "gravity"
            },
            {
                "type": "ValueRangeInt",
                "name": "count"
            }
        ]
    },
    {
        "name": "impl::ConfigItemStats",
        "members": [
            {
                "type": "std::string",
                "name": "name"
            },
            {
                "type": "bool",
                "name": "count_as_item_pickup",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "pos"
            }
        ]
    },
    {
        "name": "impl::ConfigPlayerStats",
        "members": [
            {
                "type": "std::string",
                "name": "BUILD_NAME",
                "example": "Noita-Build-Apr 23 2021-18:44:24 [0, 1]",
                "description": "build name from the macro"
            }
        ],
        "objects": [
            {
                "type": "GameStats",
                "name": "stats",
                "description": "stores sessions stats"
            },
            {
                "type": "GameStats",
                "name": "biome_baseline",
                "description": "stores biome baseline for sessions stats"
            }
        ],
        "custom_data_types": [
            {
                "type": "STATS_ITEM_MAP",
                "name": "item_map",
                "description": "just a map of all the items picked up"
            },
            {
                "type": "STATS_DEATH_MAP",
                "name": "biomes_visited",
                "description": "tracks biomes visited, second value is how many times, but that bugs out with save/load"
            }
        ]
    },
    {
        "name": "impl::ConfigStats",
        "members": [
            {
                "type": "int",
                "name": "deaths",
                "example": "0 [0, 1]",
                "description": "total deaths (by whom ever)"
            },
            {
                "type": "int",
                "name": "player_kills",
                "example": "0 [0, 1]",
                "description": "how many times has killed player"
            },
            {
                "type": "int",
                "name": "player_projectile_count",
                "example": "0 [0, 1]",
                "description": "how many times has projectiles been fired"
            },
            {
                "type": "int",
                "name": "kills",
                "example": "0 [0, 1]",
                "description": "how many kills to we have all together"
            }
        ],
        "custom_data_types": [
            {
                "type": "STATS_DEATH_MAP",
                "name": "death_map",
                "description": "tracks causes and counts"
            },
            {
                "type": "STATS_DEATH_MAP",
                "name": "kill_map",
                "description": "tracks who we've killed and how many times"
            }
        ]
    }
]
