[
    {
        "name": "AIAttackComponent",
        "members": [
            {
                "type": "int",
                "name": "use_probability",
                "example": "100 [0, 100]",
                "description": "The probability for using this attack if it's otherwise possible"
            },
            {
                "type": "float",
                "name": "min_distance",
                "example": "10 [0, 10000]",
                "description": "The minimum distance from enemy at which we can perform this attack."
            },
            {
                "type": "float",
                "name": "max_distance",
                "example": "160 [0, 10000]",
                "description": "The maximum distance from enemy at which we can perform this attack."
            },
            {
                "type": "float",
                "name": "angular_range_deg",
                "example": "90 [0, 90]",
                "description": "When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right."
            },
            {
                "type": "int",
                "name": "state_duration_frames",
                "example": "45 [0, 1000]",
                "description": "How long do we stay in the attack state, before other states are allowed?"
            },
            {
                "type": "int",
                "name": "frames_between",
                "example": "180 [0, 1000]",
                "description": "The minimum number of frames we wait between these attacks"
            },
            {
                "type": "int",
                "name": "frames_between_global",
                "example": "30 [0, 1000]",
                "description": "The minimum number of frames we wait after this attack before doing any other ranged attack"
            },
            {
                "type": "std::string",
                "name": "animation_name",
                "example": "attack_ranged [0, 1]",
                "description": "The animation to play when performing this attack"
            },
            {
                "type": "bool",
                "name": "attack_landing_ranged_enabled",
                "example": "0 [0, 1]",
                "description": "If 1, we try to land before doing the attack, if there's ground near nearby under us"
            },
            {
                "type": "int",
                "name": "attack_ranged_action_frame",
                "example": "2 [0, 1000]",
                "description": "The frame of the 'attack_ranged' animation during which the ranged attack actually occurs"
            },
            {
                "type": "float",
                "name": "attack_ranged_offset_x",
                "example": "0 [-1000, 1000]",
                "description": "'attack_ranged_entity_file' is created here when performing a ranged attack"
            },
            {
                "type": "float",
                "name": "attack_ranged_offset_y",
                "example": "0 [-1000, 1000]",
                "description": "'attack_ranged_entity_file' is created here when performing a ranged attack"
            },
            {
                "type": "float",
                "name": "attack_ranged_root_offset_x",
                "example": "0 [-1000, 1000]"
            },
            {
                "type": "float",
                "name": "attack_ranged_root_offset_y",
                "example": "0 [-1000, 1000]"
            },
            {
                "type": "bool",
                "name": "attack_ranged_use_message",
                "example": "0 [0, 1]",
                "description": "If 1, we do ranged attacks by sending a Message_UseItem"
            },
            {
                "type": "bool",
                "name": "attack_ranged_predict",
                "example": "0 [0, 1]",
                "description": "If 1, we attempt to predict target movement and shoot accordingly"
            },
            {
                "type": "std::string",
                "name": "attack_ranged_entity_file",
                "example": "data/entities/projectiles/spear.xml [0, 1]",
                "description": "File to projectile entity that is created when performing a ranged attack"
            },
            {
                "type": "int",
                "name": "attack_ranged_entity_count_min",
                "example": "1 [0, 1000]",
                "description": "Minimum number of projectiles shot when performing a ranged attack"
            },
            {
                "type": "int",
                "name": "attack_ranged_entity_count_max",
                "example": "1 [0, 1000]",
                "description": "Maximum number of projectiles shot when performing a ranged attack"
            },
            {
                "type": "bool",
                "name": "attack_ranged_use_laser_sight",
                "example": "0 [0, 1]",
                "description": "If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'"
            },
            {
                "type": "bool",
                "name": "attack_ranged_aim_rotation_enabled",
                "example": "0 [0, 1]",
                "description": "If 1, we use a laser sight"
            },
            {
                "type": "float",
                "name": "attack_ranged_aim_rotation_speed",
                "example": "3 [0, 1]",
                "description": "How fast can we rotate our aim to track targets"
            },
            {
                "type": "float",
                "name": "attack_ranged_aim_rotation_shooting_ok_angle_deg",
                "example": "10 [0, 1]",
                "description": "If our aim is closer than this to the target we shoot"
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "mRangedAttackCurrentAimAngle",
                "example": "0 [0, 1]",
                "description": "which direction does our gun currently point at, physically saying?"
            },
            {
                "type": "int",
                "name": "mNextFrameUsable",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "AIComponent",
        "members": [
            {
                "type": "float",
                "name": "TEMP_TEMP_TEMP",
                "example": "0 [0, 3.5]"
            }
        ],
        "privates": [
            {
                "type": "AIData*",
                "name": "data"
            }
        ]
    },
    {
        "name": "AbilityComponent",
        "members": [
            {
                "type": "int",
                "name": "cooldown_frames",
                "example": "0 [0, 60000]"
            },
            {
                "type": "std::string",
                "name": "entity_file",
                "description": "the projectile entity file"
            },
            {
                "type": "std::string",
                "name": "sprite_file"
            },
            {
                "type": "int",
                "name": "entity_count",
                "example": "1 [0, 60000]"
            },
            {
                "type": "bool",
                "name": "never_reload",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "reload_time_frames",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mana",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mana_max",
                "example": "100 [0, 1]"
            },
            {
                "type": "float",
                "name": "mana_charge_speed",
                "example": "10 [0, 1]"
            },
            {
                "type": "bool",
                "name": "rotate_in_hand",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "rotate_in_hand_amount",
                "example": "1 [0, 1]",
                "description": "[0-1], how much does the item rotate related to the actual aiming angle"
            },
            {
                "type": "float",
                "name": "rotate_hand_amount",
                "example": "0.7 [0, 1]",
                "description": "[0-1], how much does hand sprite rotate related to the actual aiming angle"
            },
            {
                "type": "bool",
                "name": "fast_projectile",
                "example": "0 [0, 1]",
                "description": "if 1, then the velocity of the bullet is increased quite a bit. Lightning requires this"
            },
            {
                "type": "float",
                "name": "swim_propel_amount",
                "example": "0 [-1000, 1000]"
            },
            {
                "type": "int",
                "name": "max_charged_actions",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "charge_wait_frames",
                "example": "10 [0, 1]"
            },
            {
                "type": "float",
                "name": "item_recoil_recovery_speed",
                "example": "15 [0, 1]",
                "description": "How quickly does the item return to resting state after getting recoil"
            },
            {
                "type": "float",
                "name": "item_recoil_max",
                "example": "1 [0, 1]",
                "description": "Maximum distance moved by recoil"
            },
            {
                "type": "float",
                "name": "item_recoil_offset_coeff",
                "example": "1 [0, 1]",
                "description": "Item distance moved by recoil = mItemRecoil * item_recoil_offset_coeff"
            },
            {
                "type": "float",
                "name": "item_recoil_rotation_coeff",
                "example": "5 [0, 1]",
                "description": "Item rotation by recoil = mItemRecoil * item_recoil_rotation_coeff"
            },
            {
                "type": "std::string",
                "name": "base_item_file",
                "example": "data/entities/base_item.xml [0, 1]",
                "description": "when dropping / throwing the item, this is the base_item that we add the ability component to"
            },
            {
                "type": "bool",
                "name": "use_entity_file_as_projectile_info_proxy",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "click_to_use",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "stat_times_player_has_shot",
                "example": "0 [0, 1]",
                "description": "used to track how many times player has shot this 'ability'"
            },
            {
                "type": "int",
                "name": "stat_times_player_has_edited",
                "example": "0 [0, 1]",
                "description": "used to track how many times this has been edited"
            },
            {
                "type": "bool",
                "name": "shooting_reduces_amount_in_inventory",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "throw_as_item",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "simulate_throw_as_item",
                "example": "0 [0, 1]",
                "description": "If 1, the item will be work as normal ability, but throwing animation is played by the user"
            },
            {
                "type": "int",
                "name": "max_amount_in_inventory",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "amount_in_inventory",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "drop_as_item_on_death",
                "example": "1 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "ui_name",
                "example": "[NOT_SET] [0, 1]",
                "description": "way to name the weapons"
            },
            {
                "type": "bool",
                "name": "use_gun_script",
                "example": "0 [0, 1]",
                "description": "If 1, the default ability behaviour is replaced with one that uses the lua gun system."
            },
            {
                "type": "bool",
                "name": "is_petris_gun",
                "example": "0 [0, 1]",
                "description": "if 1, TODO( PETRI)"
            },
            {
                "type": "int",
                "name": "gun_level",
                "example": "1 [1, 10]",
                "description": "the level of the wand, set in gun_procedural.lua"
            },
            {
                "type": "std::string",
                "name": "add_these_child_actions",
                "description": "e.g. 'bullet,bullet,damage' ... actions are parsed into a string. These are added as actual entities when the item is initialized"
            },
            {
                "type": "int",
                "name": "current_slot_durability",
                "example": "-1 [0, 1]",
                "description": "After this many slots the last slot of the gun is removed. -1 means not initialized/infinite."
            },
            {
                "type": "std_string",
                "name": "slot_consumption_function",
                "example": "_get_gun_slot_durability_default [0, 1]",
                "description": "Name of the lua function in 'gun.lua' that is called to calculate durability of the last slot in the gun"
            },
            {
                "type": "int",
                "name": "mNextFrameUsable",
                "example": "0 [0, 1]",
                "description": "hax, don't touch!"
            },
            {
                "type": "int",
                "name": "mCastDelayStartFrame",
                "example": "0 [0, 1]",
                "description": "hax, don't touch!"
            },
            {
                "type": "int",
                "name": "mReloadFramesLeft",
                "example": "0 [0, 1]",
                "description": "hax, don't touch!"
            },
            {
                "type": "int",
                "name": "mReloadNextFrameUsable",
                "example": "0 [0, 1]",
                "description": "hax, don't touch!"
            },
            {
                "type": "int",
                "name": "mChargeCount",
                "example": "0 [0, 1]",
                "description": "hax, don't touch!"
            },
            {
                "type": "bool",
                "name": "mIsInitialized",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mAmmoLeft",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextChargeFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mItemRecoil",
                "example": "0 [0, 1]"
            }
        ],
        "objects": [
            {
                "type": "ConfigGun",
                "name": "gun_config",
                "description": "Constants for gun script"
            },
            {
                "type": "ConfigGunActionInfo",
                "name": "gunaction_config",
                "description": "Constants for gun script"
            }
        ]
    },
    {
        "name": "AdvancedFishAIComponent",
        "members": [
            {
                "type": "float",
                "name": "move_check_range_min",
                "example": "16 [0, 2]"
            },
            {
                "type": "float",
                "name": "move_check_range_max",
                "example": "64 [0, 2]"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "flock",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "avoid_predators",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mHasTargetDirection",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mTargetPos"
            },
            {
                "type": "vec2",
                "name": "mTargetVec"
            },
            {
                "type": "vec2",
                "name": "mLastFramesMovementAreaMin"
            },
            {
                "type": "vec2",
                "name": "mLastFramesMovementAreaMax"
            },
            {
                "type": "uint32",
                "name": "mNumFailedTargetSearches",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextFrameCheckAreWeStuck",
                "example": "-1 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextFrameCheckFlockWants",
                "example": "-1 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextFramePredatorAvoidance",
                "example": "-1 [0, 1]"
            },
            {
                "type": "float",
                "name": "mScared",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mWantsToBeInFlock",
                "example": "1 [0, 1]"
            }
        ]
    },
    {
        "name": "AltarComponent",
        "members": [
            {
                "type": "std::string",
                "name": "recognized_entity_tags"
            },
            {
                "type": "int",
                "name": "uses_remaining",
                "example": "3 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "EntityTags",
                "name": "m_recognized_entity_tags"
            },
            {
                "type": "uint32",
                "name": "m_recognized_entity_tags_count",
                "example": "0 [0, 1]"
            },
            {
                "type": "EntityTags",
                "name": "m_current_entity_tags"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "good_fx_material",
                "example": "0 [0, 1]",
                "description": "String name of material for particles emitted on successful sacrifice"
            },
            {
                "type": "int",
                "name": "neutral_fx_material",
                "example": "0 [0, 1]",
                "description": "String name of material for particles emitted on successful sacrifice"
            },
            {
                "type": "int",
                "name": "evil_fx_material",
                "example": "0 [0, 1]",
                "description": "String name of material for particles emitted on successful sacrifice"
            }
        ]
    },
    {
        "name": "AnimalAIComponent",
        "members": [
            {
                "type": "int",
                "name": "ai_state",
                "example": "0 [0, 20]",
                "description": "Current state of ai, defines what the animal is doing"
            },
            {
                "type": "int",
                "name": "ai_state_timer",
                "example": "0 [0, 1000]",
                "description": "If not 0, then we wait till this frame to pop current state from our state stack"
            },
            {
                "type": "bool",
                "name": "keep_state_alive_when_enabled",
                "example": "0 [0, 1]",
                "description": "if 1, will ensure state timer keeps current state alive for a while when Component is Enabled"
            },
            {
                "type": "std::string",
                "name": "preferred_job",
                "description": "We always do this job, unless interrupted (i.e. by taking fire damage)"
            },
            {
                "type": "int",
                "name": "escape_if_damaged_probability",
                "example": "30 [0, 1]",
                "description": "the chance of escaping if someone damages us. only works if 'can_fly = 0 '"
            },
            {
                "type": "int",
                "name": "attack_if_damaged_probability",
                "example": "100 [0, 1]",
                "description": "the chance of counter-attacking if someone damages us, and we didn't escape"
            },
            {
                "type": "int",
                "name": "eye_offset_x",
                "example": "0 [-100, 100]",
                "description": "We cast rays from our position + eye_offset to check if we can see something"
            },
            {
                "type": "int",
                "name": "eye_offset_y",
                "example": "0 [-100, 100]",
                "description": "We cast rays from our position + eye_offset to check if we can see something"
            },
            {
                "type": "bool",
                "name": "attack_only_if_attacked",
                "example": "0 [0, 1]",
                "description": "If 1, we never attack anyone unless attacked before by someone"
            },
            {
                "type": "bool",
                "name": "dont_counter_attack_own_herd",
                "example": "0 [0, 1]",
                "description": "If 1, we don't attack members of our herd even if they accidentally attack us"
            },
            {
                "type": "float",
                "name": "creature_detection_range_x",
                "example": "50 [0, 2000]",
                "description": "When looking for threats/prey this is the max distance from us on the X axis we scan"
            },
            {
                "type": "float",
                "name": "creature_detection_range_y",
                "example": "20 [0, 2000]",
                "description": "When looking for threats/prey this is the max distance from us on the Y axis we scan"
            },
            {
                "type": "float",
                "name": "creature_detection_angular_range_deg",
                "example": "90 [0, 90]",
                "description": "When looking for threats/prey this is our field of view around the X axis. 90 means we scan the whole 180 degrees around the X axis, to the left and right"
            },
            {
                "type": "int",
                "name": "creature_detection_check_every_x_frames",
                "example": "120 [0, 5000]",
                "description": "Checks for threats/prey take place at least this many frames apart from each other"
            },
            {
                "type": "float",
                "name": "max_distance_to_cam_to_start_hunting",
                "example": "300 [0, 2000]",
                "description": "JobDefault idles before we've been once at least this close to the camera"
            },
            {
                "type": "int",
                "name": "pathfinding_max_depth_no_target",
                "example": "50 [0, 5000]",
                "description": "The maximum depth (in nodes) path search use when we have not found prey yet"
            },
            {
                "type": "int",
                "name": "pathfinding_max_depth_has_target",
                "example": "120 [0, 5000]",
                "description": "The maximum depth (in nodes) path search use when we have found prey"
            },
            {
                "type": "float",
                "name": "aggressiveness_min",
                "example": "80 [0, 100]",
                "description": "what's the initial random aggressiveness of this creature"
            },
            {
                "type": "float",
                "name": "aggressiveness_max",
                "example": "100 [0, 100]",
                "description": "what's the initial random aggressiveness of this creature"
            },
            {
                "type": "bool",
                "name": "tries_to_ranged_attack_friends",
                "example": "0 [0, 1]",
                "description": "if 1, the AI tries to attack whoever it considers a friend based on herd_ids, CHARMED and BERSERK status etc. useful e.g. for healers."
            },
            {
                "type": "bool",
                "name": "attack_melee_enabled",
                "example": "1 [0, 1]",
                "description": "If 1, and melee attack has been configured, we can perform melee attacks"
            },
            {
                "type": "bool",
                "name": "attack_dash_enabled",
                "example": "0 [0, 1]",
                "description": "If 1, and dash attack has been configured, we can perform dash attacks (a long-distance melee attack where we dash towards the enemy)"
            },
            {
                "type": "bool",
                "name": "attack_landing_ranged_enabled",
                "example": "0 [0, 1]",
                "description": "If 1, and ranged attack has been configured, we can perform ranged attacks"
            },
            {
                "type": "bool",
                "name": "attack_ranged_enabled",
                "example": "0 [0, 1]",
                "description": "If 1, and ranged attack has been configured, we can perform ranged attacks"
            },
            {
                "type": "float",
                "name": "attack_knockback_multiplier",
                "example": "100 [-100, 100]",
                "description": "If not 0, melee and dash attacks cause knockback to target"
            },
            {
                "type": "bool",
                "name": "is_static_turret",
                "example": "0 [0, 1]",
                "description": "If 1, we can only attack in one fixed direction"
            },
            {
                "type": "int",
                "name": "attack_melee_max_distance",
                "example": "20 [0, 400]",
                "description": "Maximum distance at which we can perform a melee attack"
            },
            {
                "type": "int",
                "name": "attack_melee_action_frame",
                "example": "2 [0, 1000]",
                "description": "The animation frame during which the melee attack damage is inflicted and visual effects are created"
            },
            {
                "type": "int",
                "name": "attack_melee_frames_between",
                "example": "10 [0, 1000]",
                "description": "The minimum number of frames we wait between melee attacks"
            },
            {
                "type": "float",
                "name": "attack_melee_damage_min",
                "example": "0.4 [0, 100]",
                "description": "Melee attack damage inclusive minimum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max"
            },
            {
                "type": "float",
                "name": "attack_melee_damage_max",
                "example": "0.6 [0, 100]",
                "description": "Melee attack damage inclusive maximum amount. The damage is randomized between melee attack_damage_min and attack_melee_damage_max"
            },
            {
                "type": "float",
                "name": "attack_melee_impulse_vector_x",
                "example": "0 [-100, 100]",
                "description": "The x component of the impulse that is applied to damaged entities"
            },
            {
                "type": "float",
                "name": "attack_melee_impulse_vector_y",
                "example": "0 [-100, 100]",
                "description": "The y component of the impulse that is applied to damaged entities"
            },
            {
                "type": "float",
                "name": "attack_melee_impulse_multiplier",
                "example": "0 [-100, 100]",
                "description": "A multiplier applied to attack_melee_impulse"
            },
            {
                "type": "float",
                "name": "attack_melee_offset_x",
                "example": "0 [-1000, 1000]",
                "description": "Melee attack particle effects are created here"
            },
            {
                "type": "float",
                "name": "attack_melee_offset_y",
                "example": "0 [-1000, 1000]",
                "description": "Melee attack particle effects are created here"
            },
            {
                "type": "bool",
                "name": "attack_melee_finish_enabled",
                "example": "0 [0, 1]",
                "description": "If 1, we perform a finishing move when our attack would kill the target using the 'attack_finish' animation"
            },
            {
                "type": "int",
                "name": "attack_melee_finish_action_frame",
                "example": "2 [0, 1000]",
                "description": "The animation frame during which the melee attack finishing move damage is inflicted and visual effects are created"
            },
            {
                "type": "float",
                "name": "attack_dash_distance",
                "example": "50 [0, 10000]",
                "description": "The maximum distance from enemy at which we can perform a dash attack. If a normal melee attack is possible we always do that instead"
            },
            {
                "type": "int",
                "name": "attack_dash_frames_between",
                "example": "120 [0, 1200]",
                "description": "The minimum number of frames we wait between dash attacks"
            },
            {
                "type": "float",
                "name": "attack_dash_damage",
                "example": "0.25 [0, 20]",
                "description": "The amount of damage inflicted by the dash attack"
            },
            {
                "type": "float",
                "name": "attack_dash_speed",
                "example": "200 [0, 5000]",
                "description": "The speed at which we dash"
            },
            {
                "type": "float",
                "name": "attack_dash_lob",
                "example": "0.9 [0, 6]",
                "description": "The smaller this value is the more curved our dash attack trajectory is"
            },
            {
                "type": "float",
                "name": "attack_ranged_min_distance",
                "example": "10 [0, 10000]",
                "description": "The minimum distance from enemy at which we can perform a ranged attack."
            },
            {
                "type": "float",
                "name": "attack_ranged_max_distance",
                "example": "160 [0, 10000]",
                "description": "The maximum distance from enemy at which we can perform a ranged attack."
            },
            {
                "type": "int",
                "name": "attack_ranged_action_frame",
                "example": "2 [0, 1000]",
                "description": "The frame of the 'attack_ranged' animation during which the ranged attack actually occurs"
            },
            {
                "type": "float",
                "name": "attack_ranged_offset_x",
                "example": "0 [-1000, 1000]",
                "description": "'attack_ranged_entity_file' is created here when performing a ranged attack"
            },
            {
                "type": "float",
                "name": "attack_ranged_offset_y",
                "example": "0 [-1000, 1000]",
                "description": "'attack_ranged_entity_file' is created here when performing a ranged attack"
            },
            {
                "type": "bool",
                "name": "attack_ranged_use_message",
                "example": "0 [0, 1]",
                "description": "If 1, we do ranged attacks by sending a Message_UseItem"
            },
            {
                "type": "bool",
                "name": "attack_ranged_predict",
                "example": "0 [0, 1]",
                "description": "If 1, we attempt to predict target movement and shoot accordingly"
            },
            {
                "type": "std::string",
                "name": "attack_ranged_entity_file",
                "example": "data/entities/projectiles/spear.xml [0, 1]",
                "description": "File to projectile entity that is created when performing a ranged attack"
            },
            {
                "type": "int",
                "name": "attack_ranged_entity_count_min",
                "example": "1 [0, 1000]",
                "description": "Minimum number of projectiles shot when performing a ranged attack"
            },
            {
                "type": "int",
                "name": "attack_ranged_entity_count_max",
                "example": "1 [0, 1000]",
                "description": "Maximum number of projectiles shot when performing a ranged attack"
            },
            {
                "type": "bool",
                "name": "attack_ranged_use_laser_sight",
                "example": "0 [0, 1]",
                "description": "If 1, we draw a laser sight to our target. Requires entity to have a sprite with tag 'laser_sight'"
            },
            {
                "type": "bool",
                "name": "attack_ranged_laser_sight_beam_kind",
                "example": "0 [0, 1]",
                "description": "0 = red, 1 = blue "
            },
            {
                "type": "bool",
                "name": "attack_ranged_aim_rotation_enabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "attack_ranged_aim_rotation_speed",
                "example": "3 [0, 1]"
            },
            {
                "type": "float",
                "name": "attack_ranged_aim_rotation_shooting_ok_angle_deg",
                "example": "10 [0, 1]"
            },
            {
                "type": "int",
                "name": "attack_ranged_state_duration_frames",
                "example": "45 [0, 1000]",
                "description": "How long do we stay in the attack state, before other states are allowed?"
            },
            {
                "type": "bool",
                "name": "hide_from_prey",
                "example": "0 [0, 1]",
                "description": "If 1, we attempt to hide from our target after a succesful attack"
            },
            {
                "type": "float",
                "name": "hide_from_prey_target_distance",
                "example": "200 [0, 10000]",
                "description": "The minimum distance from our target where we should move when hiding"
            },
            {
                "type": "int",
                "name": "hide_from_prey_time",
                "example": "300 [0, 1]",
                "description": "The number of frames we spend hiding and staying hiding"
            },
            {
                "type": "bool",
                "name": "food_eating_create_particles",
                "example": "1 [0, 1]",
                "description": "If 1, we replace eaten cells with particles made of this material"
            },
            {
                "type": "int",
                "name": "eating_area_radius_x",
                "example": "3 [-100, 100]",
                "description": "1/2 width of the area from which we eat food"
            },
            {
                "type": "int",
                "name": "eating_area_radius_y",
                "example": "8 [-100, 100]",
                "description": "1/2 height of the area from which we eat food"
            },
            {
                "type": "int",
                "name": "mouth_offset_x",
                "example": "0 [-100, 100]",
                "description": "The center of the area from which we eat food"
            },
            {
                "type": "int",
                "name": "mouth_offset_y",
                "example": "0 [-100, 100]",
                "description": "The center of the area from which we eat food"
            },
            {
                "type": "bool",
                "name": "defecates_and_pees",
                "example": "0 [0, 1]",
                "description": "If 1, we occasionally take a leak or a dump"
            },
            {
                "type": "int",
                "name": "butt_offset_x",
                "example": "0 [-100, 100]",
                "description": "Bodily wastes are created here"
            },
            {
                "type": "int",
                "name": "butt_offset_y",
                "example": "0 [-100, 100]",
                "description": "Bodily wastes are created here"
            },
            {
                "type": "float",
                "name": "pee_velocity_x",
                "example": "0 [-1000, 1000]",
                "description": "The velocity at which our piss gets shot"
            },
            {
                "type": "float",
                "name": "pee_velocity_y",
                "example": "0 [-1000, 1000]",
                "description": "The velocity at which our piss gets shot"
            },
            {
                "type": "bool",
                "name": "needs_food",
                "example": "1 [0, 1]",
                "description": "If 1, we stop to eat if we encounter 'food_material' cells"
            },
            {
                "type": "bool",
                "name": "sense_creatures",
                "example": "1 [0, 1]",
                "description": "If 1, we occasionally search our surroundings for prey and threats"
            },
            {
                "type": "bool",
                "name": "sense_creatures_through_walls",
                "example": "0 [0, 1]",
                "description": "If 1, will see creatures even if the wall raycast fails"
            },
            {
                "type": "bool",
                "name": "can_fly",
                "example": "1 [0, 1]",
                "description": "If 1, we can fly. Please set 'PathFindingComponent.can_fly' to 1 as well if this is 1"
            },
            {
                "type": "bool",
                "name": "can_walk",
                "example": "1 [0, 1]",
                "description": "If 1, we can walk. Please set 'PathFindingComponent.can_walk' to 1 as well if this is 1"
            },
            {
                "type": "int",
                "name": "path_distance_to_target_node_to_turn_around",
                "example": "0 [0, 1000]",
                "description": "If we're further than this from target path finding node on the X-axis we turn to face it"
            },
            {
                "type": "float",
                "name": "path_cleanup_explosion_radius",
                "example": "6 [0, 1000]",
                "description": "If we get stuck on ground we create an explosion this big to clear our surroundings a bit"
            },
            {
                "type": "float",
                "name": "max_distance_to_move_from_home",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "AI_STATE_STACK",
                "name": "mAiStateStack",
                "description": "a stack of actions and times they take, we can push new actions to the front and pop them from there"
            },
            {
                "type": "int",
                "name": "mAiStateLastSwitchFrame",
                "example": "0 [0, 1]",
                "description": "when was the last time we switched a state"
            },
            {
                "type": "int",
                "name": "mAiStatePrev",
                "example": "0 [0, 1]",
                "description": "previous AI state"
            },
            {
                "type": "int",
                "name": "mCreatureDetectionNextCheck",
                "example": "0 [0, 1]",
                "description": "threat/prey check, next time we check for threat/prey"
            },
            {
                "type": "EntityID",
                "name": "mGreatestThreat",
                "example": "0 [0, 1]",
                "description": "the entity we consider to be our greatest threat"
            },
            {
                "type": "EntityID",
                "name": "mGreatestPrey",
                "example": "0 [0, 1]",
                "description": "the entity we consider to be our most important prey"
            },
            {
                "type": "int",
                "name": "mSelectedMultiAttack",
                "example": "-1 [0, 1]",
                "description": "which AIAttackComponent attack are we using?"
            },
            {
                "type": "bool",
                "name": "mHasFoundPrey",
                "example": "0 [0, 1]",
                "description": "1, if we have ever found prey"
            },
            {
                "type": "bool",
                "name": "mHasBeenAttackedByPlayer",
                "example": "0 [0, 1]",
                "description": "1, if we have been ever attacked"
            },
            {
                "type": "bool",
                "name": "mHasStartedAttacking",
                "example": "0 [0, 1]",
                "description": "1, if we have ever started attacking anyone"
            },
            {
                "type": "int",
                "name": "mNearbyFoodCount",
                "example": "0 [0, 1]",
                "description": "amount of 'food_material' near us"
            },
            {
                "type": "int",
                "name": "mEatNextFrame",
                "example": "0 [0, 1]",
                "description": "next frame we can eat"
            },
            {
                "type": "int",
                "name": "mEatTime",
                "example": "0 [0, 1]",
                "description": "time we've been constantly eating"
            },
            {
                "type": "int",
                "name": "mFrameNextGiveUp",
                "example": "0 [0, 1]",
                "description": "next frame we consider ourselves to be stuck"
            },
            {
                "type": "vec2",
                "name": "mLastFramesMovementAreaMin",
                "description": "AABB min of the area where we've been since the last time we got stuck"
            },
            {
                "type": "vec2",
                "name": "mLastFramesMovementAreaMax",
                "description": "AABB max of the area where we've been since the last time we got stuck"
            },
            {
                "type": "int",
                "name": "mFoodMaterialId",
                "example": "-1 [0, 1]",
                "description": "cached id of 'food_material'"
            },
            {
                "type": "int",
                "name": "mFoodParticleEffectMaterialId",
                "example": "-1 [0, 1]",
                "description": "cached id of 'food_particle_effect_material'"
            },
            {
                "type": "float",
                "name": "mNextJumpLob",
                "example": "1 [0, 1]",
                "description": "we use this for next jump"
            },
            {
                "type": "vec2",
                "name": "mNextJumpTarget",
                "description": "we use this for next jump"
            },
            {
                "type": "bool",
                "name": "mNextJumpHasVelocity",
                "example": "0 [0, 1]",
                "description": "we use this for next jump"
            },
            {
                "type": "int",
                "name": "mLastFrameJumped",
                "example": "-1 [0, 1]",
                "description": "previous frame we launched into a jump"
            },
            {
                "type": "int",
                "name": "mFramesWithoutTarget",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLastFrameCanDamageOwnHerd",
                "example": "-1 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mHomePosition",
                "description": "where our home is located"
            },
            {
                "type": "int",
                "name": "mLastFrameAttackWasDone",
                "example": "0 [0, 1]",
                "description": "when was the last time we did an attack (not necessarily did damage to anyone though)"
            },
            {
                "type": "int",
                "name": "mNextFrameCanCallFriend",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextFrameRespondFriend",
                "example": "-1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mHasNoticedPlayer",
                "example": "0 [0, 1]",
                "description": "if 1, we have noticed player or player projectile"
            },
            {
                "type": "float",
                "name": "mRangedAttackCurrentAimAngle",
                "example": "0 [0, 1]",
                "description": "which direction does our gun currently point at, physically saying?"
            },
            {
                "type": "int",
                "name": "mRangedAttackNextFrame",
                "example": "0 [0, 1]",
                "description": "next frame we can perform a ranged attack"
            },
            {
                "type": "int",
                "name": "mMeleeAttackNextFrame",
                "example": "0 [0, 1]",
                "description": "next frame we can perform a melee attack"
            },
            {
                "type": "float",
                "name": "mNextMeleeAttackDamage",
                "example": "0 [0, 1]",
                "description": "the amount of damage our next melee attack will cause. used by finishing move logic"
            },
            {
                "type": "bool",
                "name": "mMeleeAttacking",
                "example": "0 [0, 1]",
                "description": "1, if we're doing a melee attack"
            },
            {
                "type": "int",
                "name": "mMeleeAttackDashNextFrame",
                "example": "0 [0, 1]",
                "description": "the next frame we can perform a melee attack"
            },
            {
                "type": "RtsUnitGoal",
                "name": "mCurrentJob",
                "description": "info about our current job. sorta legacy and could be simplified because the RTS logic is not used anywhere but doesn't have much overhead either."
            }
        ],
        "objects": [
            {
                "type": "ConfigExplosion",
                "name": "attack_melee_finish_config_explosion",
                "description": "If we have explosion, it's the setup for it"
            }
        ],
        "custom_data_types": [
            {
                "type": "LensValue<int>",
                "name": "attack_ranged_frames_between",
                "description": "The minimum number of frames we wait between ranged attacks"
            },
            {
                "type": "int",
                "name": "food_material",
                "example": "0 [0, 1]",
                "description": "The cell material we eat if encountering said material and 'needs_food' is 1"
            },
            {
                "type": "int",
                "name": "food_particle_effect_material",
                "example": "0 [0, 1]",
                "description": "We create particles made of this material when eating if 'food_eating_create_particles' is 1"
            },
            {
                "type": "LensValue<float>",
                "name": "mAggression",
                "description": "the greater this value the more likely we're to attack creatures from other herds"
            }
        ]
    },
    {
        "name": "ArcComponent",
        "members": [
            {
                "type": "int",
                "name": "lifetime",
                "example": "60 [0, 1]",
                "description": "remaining number of frames the arc exists"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "mArcTarget",
                "example": "0 [0, 1]",
                "description": "if 'mArcTarget' points to an existing entity a lighting arc will be created between this entity and 'mArcTarget'"
            }
        ],
        "custom_data_types": [
            {
                "type": "ARC_TYPE::Enum",
                "name": "type",
                "description": "which implementation the arc should use"
            },
            {
                "type": "int",
                "name": "material",
                "example": "0 [0, 1]",
                "description": "string name for the material the arc is made of"
            }
        ]
    },
    {
        "name": "AreaDamageComponent",
        "members": [
            {
                "type": "float",
                "name": "circle_radius",
                "example": "0 [0, 1]",
                "description": "if > 0, will only damage entities inside the aabb rectangle which are closer than 'circle_radius' to the aabb center."
            },
            {
                "type": "float",
                "name": "damage_per_frame",
                "example": "10 [0, 256]"
            },
            {
                "type": "int",
                "name": "update_every_n_frame",
                "example": "1 [0, 60]"
            },
            {
                "type": "EntityID",
                "name": "entity_responsible",
                "example": "0 [0, 1]",
                "description": "if NULL, will try to figure out who to blame"
            },
            {
                "type": "std::string",
                "name": "death_cause",
                "example": "$damage_curse [0, 60]"
            },
            {
                "type": "std::string",
                "name": "entities_with_tag",
                "example": "mortal [0, 1]",
                "description": "damage entities with this tag"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "aabb_min"
            },
            {
                "type": "vec2",
                "name": "aabb_max"
            },
            {
                "type": "DAMAGE_TYPES::Enum",
                "name": "damage_type",
                "description": "the damage type"
            }
        ]
    },
    {
        "name": "AttachToEntityComponent",
        "members": [
            {
                "type": "bool",
                "name": "only_position",
                "example": "0 [0, 1]",
                "description": "if 1, we only inherit position. it is calculated as follows: target_position + target_offset * target_scale"
            },
            {
                "type": "std::string",
                "name": "target_hotspot_tag",
                "description": "if set, we apply the offset of target HotSpot with this tag"
            },
            {
                "type": "int",
                "name": "target_sprite_id",
                "example": "-1 [0, 1]",
                "description": "if >= 0, the Nth sprite transform in target entity is inherited"
            },
            {
                "type": "bool",
                "name": "rotate_based_on_x_scale",
                "example": "0 [0, 1]",
                "description": "if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg"
            },
            {
                "type": "bool",
                "name": "destroy_component_when_target_is_gone",
                "example": "1 [0, 1]",
                "description": "should probably be on by default"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "target",
                "example": "0 [0, 1]",
                "description": "EntityID of the entity we're attached to. This will fail after save/load, unfortunately"
            },
            {
                "type": "int",
                "name": "mUpdateFrame",
                "example": "-1 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "types::xform",
                "name": "Transform"
            }
        ]
    },
    {
        "name": "AudioComponent",
        "members": [
            {
                "type": "std::string",
                "name": "file"
            },
            {
                "type": "std::string",
                "name": "event_root"
            },
            {
                "type": "std::string",
                "name": "audio_physics_material"
            },
            {
                "type": "bool",
                "name": "set_latest_event_position",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "remove_latest_event_on_destroyed",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "send_message_on_event_dead",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "play_only_if_visible",
                "example": "0 [0, 1]",
                "description": "plays sounds only if entity position is on screen and not covered by fog of war"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "m_audio_physics_material",
                "example": "0 [0, 1]"
            },
            {
                "type": "AudioSourceHandle",
                "name": "m_latest_source",
                "example": "-1 [0, 1]"
            }
        ]
    },
    {
        "name": "AudioListenerComponent",
        "members": [
            {
                "type": "float",
                "name": "z",
                "example": "0 [-500, 500]"
            }
        ]
    },
    {
        "name": "AudioLoopComponent",
        "members": [
            {
                "type": "std::string",
                "name": "file"
            },
            {
                "type": "std::string",
                "name": "event_name"
            },
            {
                "type": "bool",
                "name": "auto_play",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "auto_play_if_enabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "play_on_component_enable",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "calculate_material_lowpass",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "set_speed_parameter",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "set_speed_parameter_only_based_on_x_movement",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "set_speed_parameter_only_based_on_y_movement",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "volume_autofade_speed",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "m_volume",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "m_intensity",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "m_intensity2",
                "example": "1 [0, 1]"
            },
            {
                "type": "AudioSourceHandle",
                "name": "m_source",
                "example": "-1 [0, 1]"
            },
            {
                "type": "int",
                "name": "m_frame_created",
                "example": "-1 [0, 1]"
            }
        ]
    },
    {
        "name": "BiomeTrackerComponent",
        "members": [
            {
                "type": "int",
                "name": "limit_to_every_n_frame",
                "example": "0 [0, 1]",
                "description": "if > 1, we will only check the biome every n frames"
            }
        ],
        "privates": [
            {
                "type": "Biome*",
                "name": "unsafe_current_biome",
                "description": "DO NOT ACCESS, since this can be in valid"
            },
            {
                "type": "std::string",
                "name": "current_biome_name",
                "description": "used to track in which biome we are at"
            }
        ]
    },
    {
        "name": "BlackHoleComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "16 [0, 128]"
            },
            {
                "type": "float",
                "name": "particle_attractor_force",
                "example": "2 [0, 32]"
            },
            {
                "type": "float",
                "name": "damage_probability",
                "example": "0.25 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_amount",
                "example": "0.1 [0, 10]"
            }
        ],
        "privates": [
            {
                "type": "int16",
                "name": "m_particle_attractor_id",
                "example": "-1 [0, 1]"
            }
        ]
    },
    {
        "name": "BookComponent",
        "members": [
            {
                "type": "float",
                "name": "TEMP_TEMPY",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "TEMP_TEMP_TEMP",
                "example": "0 [0, 3.5]"
            }
        ]
    },
    {
        "name": "BossDragonComponent",
        "members": [
            {
                "type": "float",
                "name": "speed",
                "example": "1 [0, 10000]"
            },
            {
                "type": "float",
                "name": "speed_hunt",
                "example": "3 [0, 10000]"
            },
            {
                "type": "float",
                "name": "acceleration",
                "example": "3 [0, 10000]"
            },
            {
                "type": "float",
                "name": "direction_adjust_speed",
                "example": "1 [0, 10000]"
            },
            {
                "type": "float",
                "name": "direction_adjust_speed_hunt",
                "example": "1 [0, 10000]"
            },
            {
                "type": "float",
                "name": "gravity",
                "example": "3 [0, 10000]"
            },
            {
                "type": "float",
                "name": "tail_gravity",
                "example": "30 [0, 10000]"
            },
            {
                "type": "float",
                "name": "part_distance",
                "example": "10 [0, 10000]"
            },
            {
                "type": "int",
                "name": "ground_check_offset",
                "example": "0 [0, 10000]"
            },
            {
                "type": "float",
                "name": "eat_ground_radius",
                "example": "1 [0, 1e+006]"
            },
            {
                "type": "bool",
                "name": "eat_ground",
                "example": "1 [0, 1]",
                "description": "does the worm destroy the ground it moves through or not?"
            },
            {
                "type": "float",
                "name": "hitbox_radius",
                "example": "1 [0, 1e+006]"
            },
            {
                "type": "float",
                "name": "bite_damage",
                "example": "2 [0, 10]",
                "description": "how much damage does this do when it hits an entity"
            },
            {
                "type": "float",
                "name": "target_kill_radius",
                "example": "1 [0, 1e+006]"
            },
            {
                "type": "float",
                "name": "target_kill_ragdoll_force",
                "example": "1 [0, 1e+006]"
            },
            {
                "type": "float",
                "name": "hunt_box_radius",
                "example": "512 [0, 10000]"
            },
            {
                "type": "float",
                "name": "random_target_box_radius",
                "example": "512 [0, 10000]"
            },
            {
                "type": "int",
                "name": "new_hunt_target_check_every",
                "example": "30 [0, 10000]"
            },
            {
                "type": "int",
                "name": "new_random_target_check_every",
                "example": "120 [0, 10000]"
            },
            {
                "type": "float",
                "name": "jump_cam_shake",
                "example": "20 [0, 10000]"
            },
            {
                "type": "float",
                "name": "jump_cam_shake_distance",
                "example": "256 [0, 10000]"
            },
            {
                "type": "float",
                "name": "eat_anim_wait_mult",
                "example": "0.05 [0, 10000]"
            },
            {
                "type": "std::string",
                "name": "projectile_1",
                "example": "data/entities/projectiles/bossdragon.xml [0, 1]"
            },
            {
                "type": "int",
                "name": "projectile_1_count",
                "example": "2 [0, 10]"
            },
            {
                "type": "std::string",
                "name": "projectile_2",
                "example": "data/entities/projectiles/bossdragon_ray.xml [0, 1]"
            },
            {
                "type": "int",
                "name": "projectile_2_count",
                "example": "5 [0, 10]"
            },
            {
                "type": "std::string",
                "name": "ragdoll_filename"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mTargetEntityId",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mTargetVec"
            },
            {
                "type": "float",
                "name": "mGravVelocity",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mSpeed",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mRandomTarget"
            },
            {
                "type": "vec2",
                "name": "mLastLivingTargetPos"
            },
            {
                "type": "int",
                "name": "mNextTargetCheckFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextHuntTargetCheckFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mOnGroundPrev",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mMaterialIdPrev",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mPhase",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextPhaseSwitchTime",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mPartDistance",
                "example": "2 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mIsInitialized",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "BossHealthBarComponent",
        "members": [
            {
                "type": "bool",
                "name": "gui",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "gui_special_final_boss",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "in_world",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "gui_max_distance_visible",
                "example": "600 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mOldSpritesDestroyed",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "CameraBoundComponent",
        "members": [
            {
                "type": "bool",
                "name": "enabled",
                "example": "1 [0, 1]",
                "description": "If enabled, kills this component if it's outside the camera distance"
            },
            {
                "type": "float",
                "name": "distance",
                "example": "250 [0, 1024]",
                "description": "Distance in pixels from the center of camera, if outside this distance the entity is destroyed"
            },
            {
                "type": "float",
                "name": "distance_border",
                "example": "20 [0, 1024]",
                "description": "Offset towards camera in pixels from 'distance' where the entity is respawned if it was frozen"
            },
            {
                "type": "int",
                "name": "max_count",
                "example": "10 [0, 1024]",
                "description": "If more than 'max_count' entities of this type exist the one furthest from camera is destroyed"
            },
            {
                "type": "bool",
                "name": "freeze_on_distance_kill",
                "example": "1 [0, 1]",
                "description": "If true and the entity went too far - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?"
            },
            {
                "type": "bool",
                "name": "freeze_on_max_count_kill",
                "example": "1 [0, 1]",
                "description": "If true and the entity was one too many of its kind - this entity will be stored so we can later respawn it where it was destroyed because it got too far from the camera?"
            }
        ]
    },
    {
        "name": "CardinalMovementComponent",
        "members": [
            {
                "type": "bool",
                "name": "horizontal_movement",
                "example": "1 [0, 1]",
                "description": "allow horizontal movement"
            },
            {
                "type": "bool",
                "name": "vertical_movement",
                "example": "1 [0, 1]",
                "description": "allow vertical movement"
            },
            {
                "type": "bool",
                "name": "intercardinal_movement",
                "example": "0 [0, 1]",
                "description": "allow intercardinal movement"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mPrevPos"
            }
        ]
    },
    {
        "name": "CellEaterComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "10 [0, 100]"
            },
            {
                "type": "int",
                "name": "eat_probability",
                "example": "100 [0, 100]"
            },
            {
                "type": "bool",
                "name": "only_stain",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "eat_dynamic_physics_bodies",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "limited_materials",
                "example": "0 [0, 1]",
                "description": "if true, will only eat the materials defined in material_list"
            },
            {
                "type": "std::string",
                "name": "ignored_material_tag",
                "description": "if set, will not eat any materials with this tag. please note that this lowers the performance of cell eating by some amount."
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "ignored_material",
                "example": "0 [0, 1]",
                "description": "String name of a material that shouldn't be eaten by the component"
            },
            {
                "type": "VEC_OF_MATERIALS",
                "name": "materials",
                "description": "is a list of accepted materials sorted"
            }
        ]
    },
    {
        "name": "CharacterCollisionComponent",
        "members": [
            {
                "type": "int",
                "name": "getting_crushed_threshold",
                "example": "5 [0, 100]"
            },
            {
                "type": "int",
                "name": "moving_up_before_getting_crushed_threshold",
                "example": "3 [0, 100]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "getting_crushed_counter",
                "example": "0 [0, 1]",
                "description": "1.12.2018 - Is this still used?"
            },
            {
                "type": "int",
                "name": "stuck_in_ground_counter",
                "example": "0 [0, 1]",
                "description": "used this mostly for player to figure out if it's stuck in ground"
            },
            {
                "type": "bool",
                "name": "mCollidedHorizontally",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "CharacterDataComponent",
        "members": [
            {
                "type": "int",
                "name": "platforming_type",
                "example": "0 [0, 3]",
                "description": "0 = oldest, 1 = newer, 2 = safest"
            },
            {
                "type": "float",
                "name": "mass",
                "example": "1 [0, 10]",
                "description": "1.0 = approx. mass of player"
            },
            {
                "type": "int",
                "name": "buoyancy_check_offset_y",
                "example": "-6 [-1000, 1000]"
            },
            {
                "type": "float",
                "name": "liquid_velocity_coeff",
                "example": "9 [0, 20]",
                "description": "how much do liquids move this character. e.g. when standing in a flowing river"
            },
            {
                "type": "float",
                "name": "gravity",
                "example": "100 [0, 250]"
            },
            {
                "type": "float",
                "name": "fly_recharge_spd",
                "example": "0 [0, 250]"
            },
            {
                "type": "float",
                "name": "fly_recharge_spd_ground",
                "example": "0 [0, 250]"
            },
            {
                "type": "bool",
                "name": "flying_needs_recharge",
                "example": "0 [0, 1]",
                "description": "const variable... player has this as true"
            },
            {
                "type": "int",
                "name": "flying_in_air_wait_frames",
                "example": "44 [0, 200]",
                "description": "to fix the tap tap tap flying cheese, we wait this many frames before recharging in air"
            },
            {
                "type": "int",
                "name": "flying_recharge_removal_frames",
                "example": "8 [0, 20]",
                "description": "another fix to the tap tap - this is how many frames from pressing down up we'll remove fly charge"
            },
            {
                "type": "int",
                "name": "climb_over_y",
                "example": "3 [0, 10]"
            },
            {
                "type": "int",
                "name": "check_collision_max_size_x",
                "example": "5 [0, 50]"
            },
            {
                "type": "int",
                "name": "check_collision_max_size_y",
                "example": "5 [0, 50]"
            },
            {
                "type": "bool",
                "name": "is_on_ground",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_on_slippery_ground",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "ground_stickyness",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "effect_hit_ground",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "eff_hg_damage_min",
                "example": "0 [0, 1]",
                "description": "if we want to damage ground when hitting it... this is the place"
            },
            {
                "type": "int",
                "name": "eff_hg_damage_max",
                "example": "0 [0, 1]",
                "description": "if we want to damage ground when hitting it... this is the place"
            },
            {
                "type": "float",
                "name": "eff_hg_position_x",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "eff_hg_position_y",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "eff_hg_size_x",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "eff_hg_size_y",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "eff_hg_velocity_min_x",
                "example": "0 [-65, 65]"
            },
            {
                "type": "float",
                "name": "eff_hg_velocity_max_x",
                "example": "0 [-65, 65]"
            },
            {
                "type": "float",
                "name": "eff_hg_velocity_min_y",
                "example": "0 [-65, 65]"
            },
            {
                "type": "float",
                "name": "eff_hg_velocity_max_y",
                "example": "0 [-65, 65]"
            },
            {
                "type": "float",
                "name": "eff_hg_offset_y",
                "example": "0 [-15, 15]"
            },
            {
                "type": "bool",
                "name": "eff_hg_update_box2d",
                "example": "0 [0, 1]",
                "description": "if true, will move physics bodies that it hits"
            },
            {
                "type": "float",
                "name": "eff_hg_b2force_multiplier",
                "example": "0.0035 [0, 1]",
                "description": "multiplies the velocity with this..."
            },
            {
                "type": "float",
                "name": "destroy_ground",
                "example": "0 [0, 1]",
                "description": "how much damage do we do the ground when land on it"
            },
            {
                "type": "bool",
                "name": "send_transform_update_message",
                "example": "0 [0, 1]",
                "description": "if 1, will send Message_TransformUpdated to updated entities and their children when the component is processed by PlayerCollisionSystem or CharacterCollisionSystem"
            },
            {
                "type": "bool",
                "name": "dont_update_velocity_and_xform",
                "example": "0 [0, 1]",
                "description": "might be useful if you want to use CharacterCollisionSystem to only update on_ground status"
            },
            {
                "type": "float",
                "name": "mFlyingTimeLeft",
                "example": "1000 [0, 1]",
                "description": "How much flying energy do we have left? - NOTE( Petri ): 1.3.2023 - This used to be a private variable. It was changed to fix the save/load infinite flying bug."
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mFramesOnGround",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLastFrameOnGround",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mVelocity"
            },
            {
                "type": "bool",
                "name": "mCollidedHorizontally",
                "example": "0 [0, 1]",
                "description": "moved this here from CharacterCollisionComponent - since that is multithreaded and we needed a non multithreaded version"
            }
        ],
        "custom_data_types": [
            {
                "type": "LensValue<float>",
                "name": "collision_aabb_min_x"
            },
            {
                "type": "LensValue<float>",
                "name": "collision_aabb_max_x"
            },
            {
                "type": "LensValue<float>",
                "name": "collision_aabb_min_y"
            },
            {
                "type": "LensValue<float>",
                "name": "collision_aabb_max_y"
            },
            {
                "type": "LensValue<float>",
                "name": "fly_time_max",
                "description": "how much flying energy + "
            }
        ]
    },
    {
        "name": "CharacterPlatformingComponent",
        "members": [
            {
                "type": "float",
                "name": "jump_velocity_x",
                "example": "0 [0, 500]"
            },
            {
                "type": "float",
                "name": "jump_velocity_y",
                "example": "-175 [-500, 0]"
            },
            {
                "type": "int",
                "name": "jump_keydown_buffer",
                "example": "2 [0, 10]"
            },
            {
                "type": "float",
                "name": "fly_speed_mult",
                "example": "0 [-100, 100]",
                "description": "AI stuff"
            },
            {
                "type": "float",
                "name": "fly_speed_change_spd",
                "example": "5 [0, 1000]",
                "description": "player"
            },
            {
                "type": "bool",
                "name": "fly_model_player",
                "example": "0 [0, 1]",
                "description": "if true, uses player fly model"
            },
            {
                "type": "bool",
                "name": "fly_smooth_y",
                "example": "1 [0, 1]",
                "description": "if true, smooths out the AI fly model"
            },
            {
                "type": "float",
                "name": "accel_x",
                "example": "1 [0, 1000]"
            },
            {
                "type": "float",
                "name": "accel_x_air",
                "example": "0.1 [0, 1000]"
            },
            {
                "type": "float",
                "name": "pixel_gravity",
                "example": "600 [0, 1000]"
            },
            {
                "type": "float",
                "name": "swim_idle_buoyancy_coeff",
                "example": "1.2 [0, 2]"
            },
            {
                "type": "float",
                "name": "swim_down_buoyancy_coeff",
                "example": "0.7 [0, 2]"
            },
            {
                "type": "float",
                "name": "swim_up_buoyancy_coeff",
                "example": "0.9 [0, 2]"
            },
            {
                "type": "float",
                "name": "swim_drag",
                "example": "0.95 [0, 2]",
                "description": "when in water velocity *= swim_drag"
            },
            {
                "type": "float",
                "name": "swim_extra_horizontal_drag",
                "example": "0.9 [0, 2]",
                "description": "when in water velocity.x *= swim_extra_horizontal_drag"
            },
            {
                "type": "bool",
                "name": "mouse_look",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "mouse_look_buffer",
                "example": "1 [0, 5]"
            },
            {
                "type": "bool",
                "name": "keyboard_look",
                "example": "0 [0, 1]",
                "description": "if true, turns based on if left or right has been pressed down"
            },
            {
                "type": "float",
                "name": "turning_buffer",
                "example": "0.1 [0, 2]"
            },
            {
                "type": "std::string",
                "name": "animation_to_play"
            },
            {
                "type": "std::string",
                "name": "animation_to_play_next"
            },
            {
                "type": "float",
                "name": "run_animation_velocity_switching_threshold",
                "example": "45 [0, 1000]"
            },
            {
                "type": "bool",
                "name": "run_animation_velocity_switching_enabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "turn_animation_frames_between",
                "example": "20 [0, 100]"
            },
            {
                "type": "int",
                "name": "precision_jumping_max_duration_frames",
                "example": "-1 [0, 1]",
                "description": "maximum duration of precision jump or knockback. -1 = infinite"
            },
            {
                "type": "float",
                "name": "audio_liquid_splash_intensity",
                "example": "1 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mExAnimationPos"
            },
            {
                "type": "int",
                "name": "mFramesInAirCounter",
                "example": "-1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mIsPrecisionJumping",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mPrecisionJumpingTime",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mPrecisionJumpingSpeedX",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mPrecisionJumpingTimeLeft",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mFlyThrottle",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mSmoothedFlyingTargetY",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mJetpackEmitting",
                "example": "-1 [0, 1]",
                "description": "-1 = undefined, 0 = not emitting, 1 = emitting"
            },
            {
                "type": "int",
                "name": "mNextTurnAnimationFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFramesNotSwimming",
                "example": "10 [0, 1]",
                "description": "0 = currently swimming"
            },
            {
                "type": "int",
                "name": "mFramesSwimming",
                "example": "0 [0, 1]",
                "description": "0 = not currently swimming"
            },
            {
                "type": "bool",
                "name": "mShouldCrouch",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mShouldCrouchPrev",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLastPostureSwitchFrame",
                "example": "-1 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLookOverrideLastFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLookOverrideDirection",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "LensValue<float>",
                "name": "velocity_min_x"
            },
            {
                "type": "LensValue<float>",
                "name": "velocity_max_x"
            },
            {
                "type": "LensValue<float>",
                "name": "velocity_min_y"
            },
            {
                "type": "LensValue<float>",
                "name": "velocity_max_y"
            },
            {
                "type": "LensValue<float>",
                "name": "run_velocity"
            },
            {
                "type": "LensValue<float>",
                "name": "fly_velocity_x"
            },
            {
                "type": "LensValue<float>",
                "name": "fly_speed_max_up"
            },
            {
                "type": "LensValue<float>",
                "name": "fly_speed_max_down"
            }
        ]
    },
    {
        "name": "CharacterStatsComponent",
        "privates": [
            {
                "type": "CharacterStatsModifier",
                "name": "stats"
            }
        ]
    },
    {
        "name": "CollisionTriggerComponent",
        "members": [
            {
                "type": "float",
                "name": "width",
                "example": "32 [0, 100]"
            },
            {
                "type": "float",
                "name": "height",
                "example": "32 [0, 100]"
            },
            {
                "type": "float",
                "name": "radius",
                "example": "32 [0, 100]"
            },
            {
                "type": "std::string",
                "name": "required_tag",
                "example": "mortal [0, 1]"
            },
            {
                "type": "bool",
                "name": "remove_component_when_triggered",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "destroy_this_entity_when_triggered",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "timer_for_destruction",
                "example": "0 [0, 60]"
            },
            {
                "type": "bool",
                "name": "self_trigger",
                "example": "0 [0, 1]",
                "description": "if true, the shooter can trigger it"
            },
            {
                "type": "int",
                "name": "skip_self_frames",
                "example": "60 [0, 1]",
                "description": "skips checks against self during these frames"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mTimer",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ConsumableTeleportComponent",
        "members": [
            {
                "type": "bool",
                "name": "create_other_end",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_at_home",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "collision_radius",
                "example": "10 [0, 20]"
            },
            {
                "type": "uint32",
                "name": "target_id",
                "example": "0 [0, 1]"
            },
            {
                "type": "uint32",
                "name": "id",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextUsableFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mHasOtherEnd",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "target_location"
            }
        ]
    },
    {
        "name": "ControllerGoombaAIComponent",
        "members": [
            {
                "type": "bool",
                "name": "auto_turn_around_enabled",
                "example": "1 [0, 1]",
                "description": "disable this if you don't want creature to 'look around', while standing still"
            },
            {
                "type": "int",
                "name": "wait_to_turn_around",
                "example": "50 [0, 300]"
            },
            {
                "type": "int",
                "name": "wall_hit_wait",
                "example": "10 [0, 300]"
            },
            {
                "type": "bool",
                "name": "check_wall_detection",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "wall_detection_aabb_min_x",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "wall_detection_aabb_max_x",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "wall_detection_aabb_min_y",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "wall_detection_aabb_max_y",
                "example": "0 [-15, 15]"
            },
            {
                "type": "bool",
                "name": "check_floor_detection",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "floor_detection_aabb_min_x",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "floor_detection_aabb_max_x",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "floor_detection_aabb_min_y",
                "example": "0 [-15, 15]"
            },
            {
                "type": "float",
                "name": "floor_detection_aabb_max_y",
                "example": "0 [-15, 15]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mChangingDirectionCounter",
                "example": "-1 [0, 1]"
            }
        ]
    },
    {
        "name": "ControlsComponent",
        "members": [
            {
                "type": "bool",
                "name": "polymorph_hax",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "polymorph_next_attack_frame",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "enabled",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "gamepad_indirect_aiming_enabled",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "gamepad_fire_on_thumbstick_extend",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "gamepad_fire_on_thumbstick_extend_threshold",
                "example": "0.7 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mButtonDownFire",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameFire",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonLastFrameFire",
                "example": "-2 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownFire2",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameFire2",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownAction",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameAction",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownThrow",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameThrow",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownInteract",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameInteract",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownLeft",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameLeft",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownRight",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameRight",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownUp",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameUp",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownDown",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameDown",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownJump",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameJump",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownRun",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameRun",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownFly",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameFly",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownDig",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameDig",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownChangeItemR",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameChangeItemR",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonCountChangeItemR",
                "example": "0 [0, 1]",
                "description": "note these have special count property"
            },
            {
                "type": "bool",
                "name": "mButtonDownChangeItemL",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameChangeItemL",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonCountChangeItemL",
                "example": "0 [0, 1]",
                "description": "note these have special count property"
            },
            {
                "type": "bool",
                "name": "mButtonDownInventory",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameInventory",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownHolsterItem",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameHolsterItem",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownDropItem",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameDropItem",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownKick",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameKick",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownEat",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mButtonFrameEat",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mButtonDownLeftClick",
                "example": "0 [0, 1]",
                "description": "NOTE! Ignores gamepad, if mouse is pressed this will be true."
            },
            {
                "type": "int",
                "name": "mButtonFrameLeftClick",
                "example": "0 [0, 1]",
                "description": "NOTE! Ignores gamepad, if mouse is pressed this will be true."
            },
            {
                "type": "bool",
                "name": "mButtonDownRightClick",
                "example": "0 [0, 1]",
                "description": "NOTE! Ignores gamepad, if mouse is pressed this will be true."
            },
            {
                "type": "int",
                "name": "mButtonFrameRightClick",
                "example": "0 [0, 1]",
                "description": "NOTE! Ignores gamepad, if mouse is pressed this will be true."
            },
            {
                "type": "bool",
                "name": "mButtonDownTransformLeft",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "int",
                "name": "mButtonFrameTransformLeft",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "bool",
                "name": "mButtonDownTransformRight",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "int",
                "name": "mButtonFrameTransformRight",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "bool",
                "name": "mButtonDownTransformUp",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "int",
                "name": "mButtonFrameTransformUp",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "int",
                "name": "mButtonCountTransformUp",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "bool",
                "name": "mButtonDownTransformDown",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "int",
                "name": "mButtonFrameTransformDown",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "int",
                "name": "mButtonCountTransformDown",
                "example": "0 [0, 1]",
                "description": "NOT IN USE!"
            },
            {
                "type": "float",
                "name": "mFlyingTargetY",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mAimingVector"
            },
            {
                "type": "vec2",
                "name": "mAimingVectorNormalized",
                "description": "Aiming vector normalized to unit sphere."
            },
            {
                "type": "vec2",
                "name": "mAimingVectorNonZeroLatest"
            },
            {
                "type": "vec2",
                "name": "mGamepadAimingVectorRaw"
            },
            {
                "type": "vec2",
                "name": "mJumpVelocity",
                "description": "used mostly by AI only?"
            },
            {
                "type": "vec2",
                "name": "mMousePosition"
            },
            {
                "type": "vec2",
                "name": "mMousePositionRaw"
            },
            {
                "type": "vec2",
                "name": "mMousePositionRawPrev"
            },
            {
                "type": "vec2",
                "name": "mMouseDelta"
            },
            {
                "type": "vec2",
                "name": "mGamepadIndirectAiming"
            },
            {
                "type": "vec2",
                "name": "mGamePadCursorInWorld",
                "description": "where the aiming cursor is in the world, updated by platformshooterplayer_system "
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineFire",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineFire2",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineRight",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineLeft",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineUp",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineDown",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineKick",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineThrow",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineJump",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "uint32_t",
                "name": "mButtonDownDelayLineFly",
                "example": "0 [0, 1]",
                "description": "Used to delay input for some game effects"
            },
            {
                "type": "LensValue<int>",
                "name": "input_latency_frames",
                "description": "Adds latency to some inputs. Used by some game effects. Max 31."
            }
        ]
    },
    {
        "name": "CrawlerAnimalComponent",
        "members": [
            {
                "type": "float",
                "name": "ray_length",
                "example": "5 [0, 100]"
            },
            {
                "type": "int",
                "name": "ray_count",
                "example": "16 [0, 64]"
            },
            {
                "type": "float",
                "name": "gravity",
                "example": "600 [0, 10000]"
            },
            {
                "type": "float",
                "name": "terminal_velocity",
                "example": "600 [0, 10000]"
            },
            {
                "type": "float",
                "name": "speed",
                "example": "0.2 [0, 10000]"
            },
            {
                "type": "int",
                "name": "give_up_area_radius",
                "example": "20 [0, 1000]"
            },
            {
                "type": "int",
                "name": "give_up_time",
                "example": "45 [0, 1000]"
            },
            {
                "type": "float",
                "name": "attack_from_ceiling_check_ray_length",
                "example": "128 [0, 1000]"
            },
            {
                "type": "int",
                "name": "attack_from_ceiling_check_every_n_frames",
                "example": "15 [0, 1000]"
            },
            {
                "type": "float",
                "name": "collision_damage",
                "example": "0.25 [0, 1000]"
            },
            {
                "type": "float",
                "name": "collision_damage_radius",
                "example": "10 [0, 1000]"
            },
            {
                "type": "int",
                "name": "collision_damage_frames_between",
                "example": "10 [0, 1000]"
            },
            {
                "type": "bool",
                "name": "animate",
                "example": "1 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mDir",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFrameNextGiveUp",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFrameNextDamage",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFrameNextAttackFromCeilingCheck",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mMin"
            },
            {
                "type": "vec2",
                "name": "mMax"
            },
            {
                "type": "vec2",
                "name": "mPrevNonSnappedPosition"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition2"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition3"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition4"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition5"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition6"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition7"
            },
            {
                "type": "ivec2",
                "name": "mPrevCellPosition8"
            },
            {
                "type": "ivec2",
                "name": "mLatestPosition"
            },
            {
                "type": "bool",
                "name": "mPrevFalling",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mIsInitialized",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mVelocityY",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mAngle",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mMovementStepAccumulator",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "CutThroughWorldDoneHereComponent",
        "members": [
            {
                "type": "uint32",
                "name": "id_of_done_cut",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "DamageModelComponent",
        "members": [
            {
                "type": "double",
                "name": "hp",
                "example": "1 [0, 4]",
                "description": "hit points at the moment"
            },
            {
                "type": "double",
                "name": "max_hp",
                "example": "0 [0, 4]",
                "description": "the maximum hp that this can have, we'll set this when loading"
            },
            {
                "type": "double",
                "name": "max_hp_cap",
                "example": "0 [0, 12]",
                "description": "the maximum 'max_hp' that this can have, <= 0 means no limits. Used by perks such as GLASS_CANNON"
            },
            {
                "type": "double",
                "name": "max_hp_old",
                "example": "0 [0, 1]",
                "description": "used for UI rendering"
            },
            {
                "type": "float",
                "name": "critical_damage_resistance",
                "example": "0 [0, 1]",
                "description": "0.0 = all critical damage multiplier is applied. 1.0 = no critical damage multiplier is applied"
            },
            {
                "type": "int",
                "name": "invincibility_frames",
                "example": "0 [0, 1024]",
                "description": "if positive, doesn't take damage"
            },
            {
                "type": "bool",
                "name": "falling_damages",
                "example": "1 [0, 1]",
                "description": "do we take fall damage"
            },
            {
                "type": "float",
                "name": "falling_damage_height_min",
                "example": "70 [0, 1]",
                "description": "how far do we need to fall to take damage, we start with this height, the peasant takes min damage from this"
            },
            {
                "type": "float",
                "name": "falling_damage_height_max",
                "example": "250 [0, 1]",
                "description": "after this the peasant always takes the maximum fall damage"
            },
            {
                "type": "float",
                "name": "falling_damage_damage_min",
                "example": "0.1 [0, 1]",
                "description": "when we fall over height_min we take this much, lineary ramping to damage_max"
            },
            {
                "type": "float",
                "name": "falling_damage_damage_max",
                "example": "1.2 [0, 1]",
                "description": "when we fall over height_min we take this much, lineary ramping to damage_max"
            },
            {
                "type": "bool",
                "name": "air_needed",
                "example": "1 [0, 1]",
                "description": "Do we breath, can we take damage from not breathing?"
            },
            {
                "type": "float",
                "name": "air_in_lungs",
                "example": "5 [0, 1]",
                "description": "How much air do we have in our lungs? - after the air runs out we take damage"
            },
            {
                "type": "float",
                "name": "air_in_lungs_max",
                "example": "5 [0, 1]",
                "description": "how much air can we have in our lungs, it's filled to this point if we're not in water"
            },
            {
                "type": "float",
                "name": "air_lack_of_damage",
                "example": "0.2 [0, 1]",
                "description": "(* dt)... damage in a second if we're in the water"
            },
            {
                "type": "float",
                "name": "minimum_knockback_force",
                "example": "0 [0, 1]",
                "description": "Minimum knockback force required to do the knockback"
            },
            {
                "type": "bool",
                "name": "materials_damage",
                "example": "1 [0, 1]",
                "description": "should materials do damage or not?"
            },
            {
                "type": "int",
                "name": "material_damage_min_cell_count",
                "example": "4 [0, 1]",
                "description": "if material damage is received from less than 'material_damage_min_cell_count' this frame, it is ignored"
            },
            {
                "type": "std::string",
                "name": "materials_that_damage",
                "example": "acid [0, 1]",
                "description": "list of materials that do damage, separated by ',' e.g. 'acid, fire, smoke'"
            },
            {
                "type": "std::string",
                "name": "materials_how_much_damage",
                "example": "0.1 [0, 1]",
                "description": "list of damage amount per material in materials_that_damage, separated by ','"
            },
            {
                "type": "bool",
                "name": "materials_damage_proportional_to_maxhp",
                "example": "0 [0, 1]",
                "description": "if damage from materials is proportional to max hp, instead of just damage"
            },
            {
                "type": "bool",
                "name": "physics_objects_damage",
                "example": "0 [0, 1]",
                "description": "if true, will take damage from physics objects that hit it"
            },
            {
                "type": "bool",
                "name": "materials_create_messages",
                "example": "0 [0, 1]",
                "description": "should collisions with certain materials create messages or not?"
            },
            {
                "type": "std::string",
                "name": "materials_that_create_messages",
                "example": "meat [0, 1]",
                "description": "list of materials that generate CollisionWithCell messages, separated by ',' e.g. 'acid, fire, smoke'"
            },
            {
                "type": "std::string",
                "name": "ragdoll_filenames_file",
                "example": "data/temp/ragdoll/filenames.txt [0, 1]",
                "description": "the file from which to load a ragdoll on death'"
            },
            {
                "type": "std::string",
                "name": "ragdoll_material",
                "example": "meat [0, 1]",
                "description": "what material is the ragdoll made out of"
            },
            {
                "type": "float",
                "name": "ragdoll_offset_x",
                "example": "0 [0, 1]",
                "description": "where should the ragdoll be created relative to our entity position'"
            },
            {
                "type": "float",
                "name": "ragdoll_offset_y",
                "example": "0 [0, 1]",
                "description": "where should the ragdoll be created relative to our entity position'"
            },
            {
                "type": "std::string",
                "name": "blood_material",
                "example": "blood_fading [0, 1]",
                "description": "this is the material that gets thrown as particles when this entity takes damage"
            },
            {
                "type": "std::string",
                "name": "blood_spray_material",
                "description": "this is the material that gets thrown as particles when this entity sprays blood on death"
            },
            {
                "type": "bool",
                "name": "blood_spray_create_some_cosmetic",
                "example": "0 [0, 1]",
                "description": "if true, we force some blood spray particles to be cosmetic (can be enabled to avoid making a huge mess of blood spray)"
            },
            {
                "type": "float",
                "name": "blood_multiplier",
                "example": "1 [0, 10]",
                "description": "how much blood, this is the multiplier used for sprouting lots or little blood"
            },
            {
                "type": "int",
                "name": "ragdoll_blood_amount_absolute",
                "example": "-1 [-1, 1000]",
                "description": "if > -1, this is the absolute amount of blood we share between particle emitters in the ragdoll"
            },
            {
                "type": "std::string",
                "name": "blood_sprite_directional",
                "description": "this sprite is loaded at damage position if we take damage that creates a blood effect"
            },
            {
                "type": "std::string",
                "name": "blood_sprite_large",
                "description": "this sprite is loaded at damage position if we take explosion/heavy damage"
            },
            {
                "type": "std::string",
                "name": "healing_particle_effect_entity",
                "description": "if this is set, will load this entity as a child of this entity, when this entity is healed"
            },
            {
                "type": "bool",
                "name": "create_ragdoll",
                "example": "1 [0, 1]",
                "description": "if 0, we skip ragdoll creation on death"
            },
            {
                "type": "bool",
                "name": "ragdollify_child_entity_sprites",
                "example": "0 [0, 1]",
                "description": "if 1, we ragdollify child entity sprites"
            },
            {
                "type": "float",
                "name": "ragdollify_root_angular_damping",
                "example": "0 [0, 1]",
                "description": "If ragdoll_filenames_file= and > 0, the angular damping of the first ragdoll body is set to this value."
            },
            {
                "type": "bool",
                "name": "ragdollify_disintegrate_nonroot",
                "example": "0 [0, 1]",
                "description": "If ragdoll_filenames_file= and true, all but the first sprite on the root entity will be disintegrated instead of being turned into physics bodies."
            },
            {
                "type": "bool",
                "name": "wait_for_kill_flag_on_death",
                "example": "0 [0, 1]",
                "description": "if 1, we wont kill the entity along with kill fx and ragdoll until 'kill' is 1"
            },
            {
                "type": "bool",
                "name": "kill_now",
                "example": "0 [0, 1]",
                "description": "if 1, we wont kill the entity along with kill fx and ragdoll until 'kill_now' is 1"
            },
            {
                "type": "bool",
                "name": "drop_items_on_death",
                "example": "1 [0, 1]",
                "description": "drop the abilities as items on death?"
            },
            {
                "type": "bool",
                "name": "ui_report_damage",
                "example": "1 [0, 1]",
                "description": "If 1, damage numbers are displayed when this entity is damaged"
            },
            {
                "type": "bool",
                "name": "ui_force_report_damage",
                "example": "0 [0, 1]",
                "description": "If 1, damage numbers are displayed when this entity is damaged, even if the numbers are disabled in settings"
            },
            {
                "type": "int",
                "name": "in_liquid_shooting_electrify_prob",
                "example": "0 [0, 100]",
                "description": "when shooting underwater how likely are we to electrify the water"
            },
            {
                "type": "float",
                "name": "wet_status_effect_damage",
                "example": "0 [0, 0.1]",
                "description": "how much damage per 10 frames is done if entity has 'wet' status effect"
            },
            {
                "type": "bool",
                "name": "is_on_fire",
                "example": "0 [0, 1]",
                "description": "Tells us we're on fire or not"
            },
            {
                "type": "float",
                "name": "fire_probability_of_ignition",
                "example": "0.5 [0, 1]",
                "description": "what is the probability that we'll ignite, 0 means won't ever ignite"
            },
            {
                "type": "int",
                "name": "fire_how_much_fire_generates",
                "example": "4 [0, 10]",
                "description": "how many fire particles do we generate each frame"
            },
            {
                "type": "float",
                "name": "fire_damage_ignited_amount",
                "example": "0.0003 [0, 2]",
                "description": "how much damage does being ignited do?"
            },
            {
                "type": "float",
                "name": "fire_damage_amount",
                "example": "0.2 [0, 2]",
                "description": "how much damage does fire do?, 0.2 is pretty good"
            },
            {
                "type": "int",
                "name": "mLastElectricityResistanceFrame",
                "example": "-2147483648 [0, 1]",
                "description": "Last frame electricity has no effect. Should not be private!"
            },
            {
                "type": "int",
                "name": "mLastFrameReportedBlock",
                "example": "-2147483648 [0, 1]",
                "description": "Last frame a damage block message was displayed for this entity"
            },
            {
                "type": "int",
                "name": "mLastMaxHpChangeFrame",
                "example": "-10000 [0, 1]",
                "description": "used for UI rendering"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mIsOnFire",
                "example": "0 [0, 1]",
                "description": "private variable to check when we're on fire and not"
            },
            {
                "type": "int",
                "name": "mFireProbability",
                "example": "100 [0, 1]",
                "description": "this gets decreased if we can't ignite anything else"
            },
            {
                "type": "int",
                "name": "mFireFramesLeft",
                "example": "0 [0, 1]",
                "description": "this is the remaining frames we're on fire"
            },
            {
                "type": "int",
                "name": "mFireDurationFrames",
                "example": "0 [0, 1]",
                "description": "this is the total duration in frames we're on fire"
            },
            {
                "type": "bool",
                "name": "mFireTriedIgniting",
                "example": "0 [0, 1]",
                "description": "private variable to check when we could have been ignited or not"
            },
            {
                "type": "int",
                "name": "mLastCheckX",
                "example": "0 [0, 1]",
                "description": "an optimization, so we don't have to check everything every frame"
            },
            {
                "type": "int",
                "name": "mLastCheckY",
                "example": "0 [0, 1]",
                "description": "an optimization, so we don't have to check everything every frame"
            },
            {
                "type": "int",
                "name": "mLastCheckTime",
                "example": "0 [0, 1]",
                "description": "an optimization, so we don't have to check everything every frame"
            },
            {
                "type": "int",
                "name": "mLastMaterialDamageFrame",
                "example": "0 [0, 1]",
                "description": "this is the last frame we took material damage"
            },
            {
                "type": "bool",
                "name": "mFallIsOnGround",
                "example": "0 [0, 1]",
                "description": "for fall damage, keeps a private variable about if we're on ground or not"
            },
            {
                "type": "float",
                "name": "mFallHighestY",
                "example": "3.40282e+038 [0, 1]",
                "description": "private var to keep track of how high have we flown to"
            },
            {
                "type": "int",
                "name": "mFallCount",
                "example": "0 [0, 1]",
                "description": "how many times have we fallen? This is used to make sure we don't take damage from the first fall"
            },
            {
                "type": "bool",
                "name": "mAirAreWeInWater",
                "example": "0 [0, 1]",
                "description": "a private variable to track our state in drowning"
            },
            {
                "type": "int",
                "name": "mAirFramesNotInWater",
                "example": "0 [0, 1]",
                "description": "how many frames have been with air to breathe"
            },
            {
                "type": "bool",
                "name": "mAirDoWeHave",
                "example": "0 [0, 1]",
                "description": "a private variable to track our state in drowning"
            },
            {
                "type": "int",
                "name": "mTotalCells",
                "example": "0 [0, 1]",
                "description": "how many cells are there total"
            },
            {
                "type": "int",
                "name": "mLiquidCount",
                "example": "0 [0, 1]",
                "description": "how many of the cells are liquid"
            },
            {
                "type": "int",
                "name": "mLiquidMaterialWeAreIn",
                "example": "-1 [0, 1]",
                "description": "stores the liquid material we're in... may not be the most accurate"
            },
            {
                "type": "std::vector<int>",
                "name": "mDamageMaterials",
                "description": "NOTE! Sorted! a list of materials that do damage (materials_that_damage)"
            },
            {
                "type": "std::vector<float>",
                "name": "mDamageMaterialsHowMuch",
                "description": "NOTE! Sorted! a list of materials that do damage (materials_that_damage)"
            },
            {
                "type": "std::vector<int>",
                "name": "mCollisionMessageMaterials",
                "description": "NOTE! Sorted! a list of materials that create messages (materials_that_create_messages)"
            },
            {
                "type": "std::vector<int>",
                "name": "mCollisionMessageMaterialCountsThisFrame",
                "description": "Number of cells per collided with this frame. Order matches mCollisionMessageMaterials"
            },
            {
                "type": "std::vector<float>",
                "name": "mMaterialDamageThisFrame",
                "description": "A list of damage per material that damages us. In same order as materials"
            },
            {
                "type": "float",
                "name": "mFallDamageThisFrame",
                "example": "0 [0, 1]",
                "description": "Amount of fall damage received this frame"
            },
            {
                "type": "float",
                "name": "mElectricityDamageThisFrame",
                "example": "0 [0, 1]",
                "description": "Amount of electricity damage received this frame"
            },
            {
                "type": "float",
                "name": "mPhysicsDamageThisFrame",
                "example": "0 [0, 1]",
                "description": "max physics damage we have taken this round"
            },
            {
                "type": "vec2",
                "name": "mPhysicsDamageVecThisFrame",
                "description": "direction of physics damage"
            },
            {
                "type": "int",
                "name": "mPhysicsDamageLastFrame",
                "example": "0 [0, 1]",
                "description": "frame number when we took physics damage"
            },
            {
                "type": "EntityTypeID",
                "name": "mPhysicsDamageEntity",
                "example": "0 [0, 1]",
                "description": "the physics entity that hit us"
            },
            {
                "type": "EntityTypeID",
                "name": "mPhysicsDamageTelekinesisCasterEntity",
                "example": "0 [0, 1]",
                "description": "who moved an object that hit us via telekinesis"
            },
            {
                "type": "int",
                "name": "mLastDamageFrame",
                "example": "-120 [0, 1]",
                "description": "frame number when we took any damage"
            },
            {
                "type": "double",
                "name": "mHpBeforeLastDamage",
                "example": "0 [0, 1]",
                "description": "how much hp did we have a while ago?"
            },
            {
                "type": "float",
                "name": "mFireDamageBuffered",
                "example": "0 [0, 1]",
                "description": "used to optimized cases where lots of entities are taking fire damage"
            },
            {
                "type": "int32",
                "name": "mFireDamageBufferedNextDeliveryFrame",
                "example": "0 [0, 1]"
            }
        ],
        "objects": [
            {
                "type": "ConfigDamagesByType",
                "name": "damage_multipliers",
                "description": "the multipliers applied to different types of damage"
            }
        ],
        "custom_data_types": [
            {
                "type": "RAGDOLL_FX::Enum",
                "name": "ragdoll_fx_forced",
                "description": "if set, will force this ragdoll fx to happen everytime"
            }
        ]
    },
    {
        "name": "DamageNearbyEntitiesComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "10 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_min",
                "example": "0.1 [0, 1]"
            },
            {
                "type": "float",
                "name": "damage_max",
                "example": "0.2 [0, 1]"
            },
            {
                "type": "float",
                "name": "target_vec_max_len",
                "example": "5 [0, 1]"
            },
            {
                "type": "float",
                "name": "knockback_multiplier",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "time_between_damaging",
                "example": "20 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "damage_description",
                "example": "bite [0, 1]"
            },
            {
                "type": "std::string",
                "name": "target_tag",
                "example": "mortal [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mVelocity"
            },
            {
                "type": "int",
                "name": "mNextDamageFrame",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "DAMAGE_TYPES::Enum",
                "name": "damage_type",
                "description": "the damage type"
            },
            {
                "type": "RAGDOLL_FX::Enum",
                "name": "ragdoll_fx"
            }
        ]
    },
    {
        "name": "DebugFollowMouseComponent"
    },
    {
        "name": "DebugLogMessagesComponent",
        "members": [
            {
                "type": "float",
                "name": "TEMP_TEMPY",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "TEMP_TEMP_TEMP",
                "example": "0 [0, 3.5]"
            }
        ]
    },
    {
        "name": "DebugSpatialVisualizerComponent",
        "members": [
            {
                "type": "float",
                "name": "min_x",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "min_y",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "max_x",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "max_y",
                "example": "0 [0, 1]"
            },
            {
                "type": "unsignedint",
                "name": "color",
                "example": "4294967295 [0, 1]"
            }
        ]
    },
    {
        "name": "DieIfSpeedBelowComponent",
        "members": [
            {
                "type": "float",
                "name": "min_speed",
                "example": "1 [0, 1000]",
                "description": "The entity that owns this component is killed if its speed (via VelocityComponent) falls below this value."
            },
            {
                "type": "float",
                "name": "mMinSpeedSquared",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "DroneLauncherComponent",
        "members": [
            {
                "type": "std::string",
                "name": "drone_entity_file",
                "example": "data/entities/misc/player_drone.xml [0, 1]"
            }
        ]
    },
    {
        "name": "DrugEffectComponent",
        "objects": [
            {
                "type": "ConfigDrugFx",
                "name": "drug_fx_target"
            },
            {
                "type": "ConfigDrugFx",
                "name": "m_drug_fx_current"
            }
        ]
    },
    {
        "name": "DrugEffectModifierComponent",
        "objects": [
            {
                "type": "ConfigDrugFx",
                "name": "fx_add"
            },
            {
                "type": "ConfigDrugFx",
                "name": "fx_multiply"
            }
        ]
    },
    {
        "name": "ElectricChargeComponent",
        "members": [
            {
                "type": "int",
                "name": "charge_time_frames",
                "example": "120 [0, 240]"
            },
            {
                "type": "float",
                "name": "fx_velocity_max",
                "example": "120 [0, 240]"
            },
            {
                "type": "int",
                "name": "electricity_emission_interval_frames",
                "example": "5 [0, 10]"
            },
            {
                "type": "int",
                "name": "fx_emission_interval_min",
                "example": "2 [0, 20]"
            },
            {
                "type": "int",
                "name": "fx_emission_interval_max",
                "example": "15 [0, 30]"
            },
            {
                "type": "int",
                "name": "charge",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ElectricityComponent",
        "members": [
            {
                "type": "int",
                "name": "energy",
                "example": "1000 [0, 10000]"
            },
            {
                "type": "float",
                "name": "probability_to_heat",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "speed",
                "example": "32 [0, 10000]"
            },
            {
                "type": "int",
                "name": "splittings_min",
                "example": "0 [0, 10000]"
            },
            {
                "type": "int",
                "name": "splittings_max",
                "example": "0 [0, 10000]"
            },
            {
                "type": "int",
                "name": "splitting_energy_min",
                "example": "0 [0, 10000]"
            },
            {
                "type": "int",
                "name": "splitting_energy_max",
                "example": "0 [0, 10000]"
            },
            {
                "type": "bool",
                "name": "hack_is_material_crack",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "hack_crack_ice",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "hack_is_set_fire",
                "example": "0 [0, 1]",
                "description": "if set will set the thing on fire where this is located at"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mSplittingsLeft",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mSplittingEnergy",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mAvgDir"
            },
            {
                "type": "ivec2",
                "name": "mPrevPos"
            },
            {
                "type": "int",
                "name": "mPrevMaterial",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mShouldPlaySound",
                "example": "1 [0, 1]"
            }
        ]
    },
    {
        "name": "ElectricityReceiverComponent",
        "members": [
            {
                "type": "int",
                "name": "offset_x",
                "example": "0 [1, 3]"
            },
            {
                "type": "int",
                "name": "offset_y",
                "example": "0 [1, 3]"
            },
            {
                "type": "int",
                "name": "radius",
                "example": "1 [1, 3]"
            },
            {
                "type": "int",
                "name": "active_time_frames",
                "example": "1 [1, 15]"
            },
            {
                "type": "int",
                "name": "switch_on_msg_interval_frames",
                "example": "0 [0, 60]"
            },
            {
                "type": "int",
                "name": "electrified_msg_interval_frames",
                "example": "-1 [0, 15]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mLastFrameElectrified",
                "example": "-1000 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextElectrifiedMsgFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextSwitchOnMsgFrame",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ElectricitySourceComponent",
        "members": [
            {
                "type": "int",
                "name": "radius",
                "example": "5 [1, 16]"
            },
            {
                "type": "int",
                "name": "emission_interval_frames",
                "example": "15 [1, 10]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mNextFrameEmitElectricity",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "EndingMcGuffinComponent",
        "members": [
            {
                "type": "float",
                "name": "TEMP_TEMPY",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "TEMP_TEMP_TEMP",
                "example": "0 [0, 3.5]"
            }
        ]
    },
    {
        "name": "EnergyShieldComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "16 [0, 100]"
            },
            {
                "type": "float",
                "name": "damage_multiplier",
                "example": "1.5 [0, 10]"
            },
            {
                "type": "float",
                "name": "max_energy",
                "example": "1 [0, 10]"
            },
            {
                "type": "float",
                "name": "energy_required_to_shield",
                "example": "0.2 [0, 10]"
            },
            {
                "type": "float",
                "name": "recharge_speed",
                "example": "1 [0, 10]"
            },
            {
                "type": "float",
                "name": "sector_degrees",
                "example": "360 [0, 360]",
                "description": "if less than 180 we only provide partial cover to the current direction of the entity"
            },
            {
                "type": "float",
                "name": "energy",
                "example": "0 [0, 3]"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mPrevPosition"
            }
        ]
    },
    {
        "name": "ExplodeOnDamageComponent",
        "members": [
            {
                "type": "float",
                "name": "explode_on_death_percent",
                "example": "1 [0, 1]",
                "description": "rolls a dice (0 - 1) if we explode on death"
            },
            {
                "type": "float",
                "name": "explode_on_damage_percent",
                "example": "1 [0, 1]",
                "description": "rolls a dice (0 - 1) if we explode on damage"
            },
            {
                "type": "float",
                "name": "physics_body_modified_death_probability",
                "example": "0 [0, 1]",
                "description": "if we get message about the physics body being modified, do we explode on what percent"
            },
            {
                "type": "float",
                "name": "physics_body_destruction_required",
                "example": "0.5 [0, 1]",
                "description": "how big of percent of our body, do we need to lose before we explode"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mDone",
                "example": "0 [0, 1]"
            }
        ],
        "objects": [
            {
                "type": "ConfigExplosion",
                "name": "config_explosion",
                "description": "if we have explosion, it's the setup for it"
            }
        ]
    },
    {
        "name": "ExplosionComponent",
        "members": [
            {
                "type": "int",
                "name": "timeout_frames",
                "example": "0 [0, 180]",
                "description": "for timer"
            },
            {
                "type": "int",
                "name": "timeout_frames_random",
                "example": "0 [0, 180]",
                "description": "a random value between 0 and 'timout_frames_random' is added to timer"
            },
            {
                "type": "bool",
                "name": "kill_entity",
                "example": "1 [0, 1]",
                "description": "if 1, we kill the entity when exploding"
            },
            {
                "type": "int",
                "name": "mTimerTriggerFrame",
                "example": "-1 [0, 1]"
            }
        ],
        "objects": [
            {
                "type": "ConfigExplosion",
                "name": "config_explosion",
                "description": "setup for out explosion"
            }
        ],
        "custom_data_types": [
            {
                "type": "EXPLOSION_TRIGGER_TYPE::Enum",
                "name": "trigger",
                "description": "what triggers the explosion"
            }
        ]
    },
    {
        "name": "FishAIComponent",
        "members": [
            {
                "type": "int",
                "name": "direction",
                "example": "0 [-1, 1]"
            },
            {
                "type": "float",
                "name": "speed",
                "example": "100 [1, 1000]"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "velocity"
            },
            {
                "type": "int",
                "name": "stuck_counter",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mLastCheckPos"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "aabb_min"
            },
            {
                "type": "vec2",
                "name": "aabb_max"
            }
        ]
    },
    {
        "name": "FlyingComponent",
        "members": [
            {
                "type": "int",
                "name": "type",
                "example": "0 [0, 1]",
                "description": "type of flight, 1 = perlin noise"
            },
            {
                "type": "float",
                "name": "perlin_freq",
                "example": "0.2 [0, 1]",
                "description": "frequency of the perlin noise sampling"
            },
            {
                "type": "float",
                "name": "perlin_time_freq",
                "example": "0.3 [0, 1]",
                "description": "t *= perlin_time_freq"
            },
            {
                "type": "float",
                "name": "perlin_wind_x",
                "example": "0 [-1, 1]",
                "description": "wind velocity that gets added to the samples"
            },
            {
                "type": "float",
                "name": "perlin_wind_y",
                "example": "0 [-1, 1]",
                "description": "wind velocity that gets added to the samples"
            }
        ]
    },
    {
        "name": "FogOfWarRadiusComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "256 [0, 1024]",
                "description": "256 is the default player has"
            }
        ]
    },
    {
        "name": "FogOfWarRemoverComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "140 [0, 2000]"
            }
        ]
    },
    {
        "name": "GameAreaEffectComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "0 [0, 3.5]",
                "description": "what's the radius (in pixels) of the area effect"
            },
            {
                "type": "std::string",
                "name": "collide_with_tag",
                "example": "hittable [0, 1]",
                "description": "the tags we're looking for"
            },
            {
                "type": "int",
                "name": "frame_length",
                "example": "-1 [0, 1]",
                "description": "if not 0 will reapply this effect after this many frames have gone by"
            }
        ],
        "privates": [
            {
                "type": "VECTOR_ENTITYID",
                "name": "mEntitiesAppliedOutTo"
            },
            {
                "type": "VECTOR_INT",
                "name": "mEntitiesAppliedFrame"
            }
        ],
        "custom_data_types": [
            {
                "type": "VECTOR_STR",
                "name": "game_effect_entitities",
                "description": "just a vector of the game_effect entities"
            }
        ]
    },
    {
        "name": "GameEffectComponent",
        "members": [
            {
                "type": "std::string",
                "name": "custom_effect_id",
                "description": "if 'effect' is set to 'CUSTOM', this will define effect uniqueness."
            },
            {
                "type": "int",
                "name": "frames",
                "example": "-1 [0, 1]",
                "description": "how many frames does it affect -1 = forever"
            },
            {
                "type": "int",
                "name": "exclusivity_group",
                "example": "0 [0, 1]",
                "description": "if > 0, previous game effects with the same exclusivity group as new one will be removed when calling LoadGameEffectEntityTo"
            },
            {
                "type": "bool",
                "name": "report_block_msg",
                "example": "1 [0, 1]",
                "description": "to disable the block message that rises"
            },
            {
                "type": "bool",
                "name": "disable_movement",
                "example": "0 [0, 1]",
                "description": "if set, will disable movement"
            },
            {
                "type": "std::string",
                "name": "ragdoll_effect_custom_entity_file",
                "description": "an entity that is loaded to each ragdoll part if 'ragdoll_effect' is set to 'CUSTOM_RAGDOLL_ENTITY'"
            },
            {
                "type": "bool",
                "name": "ragdoll_fx_custom_entity_apply_only_to_largest_body",
                "example": "0 [0, 1]",
                "description": "if 1, 'ragdoll_effect_custom_entity_file' is loaded only to the largest piece in the ragdoll "
            },
            {
                "type": "std::string",
                "name": "polymorph_target",
                "description": "when doing a polymorph, this is what we convert it to"
            },
            {
                "type": "USTRING",
                "name": "mSerializedData",
                "description": "polymorph stores the serialized entity here..."
            },
            {
                "type": "EntityID",
                "name": "mCaster",
                "example": "0 [0, 1]",
                "description": "Contains a handle to the caster of this GameEffect"
            },
            {
                "type": "int",
                "name": "mCasterHerdId",
                "example": "0 [0, 1]",
                "description": "Contains the herd if of the caster of this GameEffect"
            },
            {
                "type": "int",
                "name": "teleportation_probability",
                "example": "600 [0, 1]",
                "description": "How likely is it that we teleport, larger = less often"
            },
            {
                "type": "int",
                "name": "teleportation_delay_min_frames",
                "example": "30 [0, 1]",
                "description": "Never teleports more often that this"
            },
            {
                "type": "float",
                "name": "teleportation_radius_min",
                "example": "128 [0, 1]"
            },
            {
                "type": "float",
                "name": "teleportation_radius_max",
                "example": "1024 [0, 1]"
            },
            {
                "type": "int",
                "name": "teleportations_num",
                "example": "0 [0, 1]",
                "description": "How many times has this GameEffectComponent teleported the owner?"
            },
            {
                "type": "double",
                "name": "no_heal_max_hp_cap",
                "example": "3.40282e+038 [0, 1]",
                "description": "If current hp is less than this, we store it here. Then we make sure the hp never exceeds this."
            },
            {
                "type": "bool",
                "name": "caused_by_ingestion_status_effect",
                "example": "0 [0, 1]",
                "description": "Did this effect occur because someone ate something?"
            },
            {
                "type": "bool",
                "name": "caused_by_stains",
                "example": "0 [0, 1]",
                "description": "was this caused by stains"
            },
            {
                "type": "bool",
                "name": "mCharmDisabledCameraBound",
                "example": "0 [0, 1]",
                "description": "When charmed, will try to disable CameraBound. This keeps track if we've done it, so we can enable it back"
            },
            {
                "type": "bool",
                "name": "mCharmEnabledTeleporting",
                "example": "0 [0, 1]",
                "description": "When charmed, will try to enable teleporting (tag:teleportable_NOT). This keeps track if we've done it, so we can disable it again"
            },
            {
                "type": "bool",
                "name": "mInvisible",
                "example": "0 [0, 1]",
                "description": "Are we invisible?"
            },
            {
                "type": "int",
                "name": "mCounter",
                "example": "0 [0, 1]",
                "description": "Counts stuff"
            },
            {
                "type": "int",
                "name": "mCooldown",
                "example": "0 [0, 1]",
                "description": "Counts cooldown"
            },
            {
                "type": "bool",
                "name": "mIsExtension",
                "example": "0 [0, 1]",
                "description": "If 1, this is an effect extension and shouldn't create an extension when removed"
            }
        ],
        "custom_data_types": [
            {
                "type": "GAME_EFFECT::Enum",
                "name": "effect",
                "description": "GAME_EFFECT"
            },
            {
                "type": "RAGDOLL_FX::Enum",
                "name": "ragdoll_effect",
                "description": "if set, will use this for ragdoll effect"
            },
            {
                "type": "int",
                "name": "ragdoll_material",
                "example": "0 [0, 1]",
                "description": "converts to string name of the material that ragdoll is made out of"
            },
            {
                "type": "StatusEffectType",
                "name": "causing_status_effect",
                "example": "0 [0, 1]",
                "description": "Status effect that caused this game effect, if any"
            }
        ]
    },
    {
        "name": "GameLogComponent",
        "members": [
            {
                "type": "bool",
                "name": "report_death",
                "example": "1 [0, 1]",
                "description": "switches on reporting things"
            },
            {
                "type": "bool",
                "name": "report_damage",
                "example": "0 [0, 1]",
                "description": "if set, will report when receiving damage"
            },
            {
                "type": "bool",
                "name": "report_new_biomes",
                "example": "1 [0, 1]",
                "description": "if false, won't report when player enters new biomes"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mNewBiomeCheckFrame",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "VISITED_VEC",
                "name": "mVisitiedBiomes",
                "description": "list of visited biomes"
            }
        ]
    },
    {
        "name": "GameStatsComponent",
        "members": [
            {
                "type": "std::string",
                "name": "name",
                "description": "no one uses the name variable on entity, so we have to do this to make it happen"
            },
            {
                "type": "std::string",
                "name": "stats_filename",
                "description": "also generated from the gunk"
            },
            {
                "type": "bool",
                "name": "is_player",
                "example": "0 [0, 1]",
                "description": "if true, will use the session file for loading stats"
            },
            {
                "type": "std::string",
                "name": "extra_death_msg",
                "description": "set when e.g. polymorphed"
            },
            {
                "type": "bool",
                "name": "dont_do_logplayerkill",
                "example": "0 [0, 1]",
                "description": "if 1, StatsLogPlayerKill must be manually called from lua"
            },
            {
                "type": "int",
                "name": "player_polymorph_count",
                "example": "0 [0, 1]",
                "description": "skip loading of stats if this higher than 0 and decrament this by one"
            }
        ]
    },
    {
        "name": "GasBubbleComponent",
        "members": [
            {
                "type": "float",
                "name": "acceleration",
                "example": "-1 [-100, 0]"
            },
            {
                "type": "float",
                "name": "max_speed",
                "example": "20 [0, 20]"
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "mVelocity",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "GenomeDataComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_predator",
                "example": "0 [0, 1]",
                "description": "Predators are considered threats by other species and hunt for food."
            },
            {
                "type": "float",
                "name": "food_chain_rank",
                "example": "0 [0, 200]",
                "description": "0 means king of the hill. Greater number = more likely to get eaten by other species."
            },
            {
                "type": "bool",
                "name": "berserk_dont_attack_friends",
                "example": "0 [0, 1]",
                "description": "if 1, this animal will not try to attack player who would normally be its friend"
            }
        ],
        "privates": [
            {
                "type": "LensValue<bool>",
                "name": "friend_thundermage",
                "description": "if 1, thunder mage doesn't attack this"
            },
            {
                "type": "LensValue<bool>",
                "name": "friend_firemage",
                "description": "if 1, fire mage doesn't attack this"
            }
        ],
        "custom_data_types": [
            {
                "type": "LensValue<int>",
                "name": "herd_id",
                "description": "This is used for example to separate people in different tribes."
            }
        ]
    },
    {
        "name": "GhostComponent",
        "members": [
            {
                "type": "float",
                "name": "speed",
                "example": "5 [0, 1]",
                "description": "pixels per second"
            },
            {
                "type": "int",
                "name": "new_hunt_target_check_every",
                "example": "0 [0, 1]",
                "description": "how often do we look for targets"
            },
            {
                "type": "float",
                "name": "hunt_box_radius",
                "example": "512 [0, 1]"
            },
            {
                "type": "float",
                "name": "aggressiveness",
                "example": "100 [0, 1]",
                "description": "if higher than relations then will attack"
            },
            {
                "type": "float",
                "name": "max_distance_from_home",
                "example": "300 [0, 1]",
                "description": "how far from home can we go?"
            },
            {
                "type": "bool",
                "name": "die_if_no_home",
                "example": "1 [0, 1]",
                "description": "if set to false will die, if it can't find home"
            },
            {
                "type": "std::string",
                "name": "target_tag",
                "example": "player_unit [0, 1]",
                "description": "if something else (like mortal), will attack the home"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "mEntityHome",
                "example": "0 [0, 1]",
                "description": "where is our home?"
            },
            {
                "type": "int",
                "name": "mFramesWithoutHome",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mTargetPosition"
            },
            {
                "type": "int",
                "name": "mTargetEntityId",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mRandomTarget"
            },
            {
                "type": "int",
                "name": "mNextTargetCheckFrame",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "velocity"
            }
        ]
    },
    {
        "name": "GodInfoComponent",
        "members": [
            {
                "type": "float",
                "name": "mana_current",
                "example": "0 [0, 1000]",
                "description": "How much mana the player now has to use"
            },
            {
                "type": "float",
                "name": "mana_max",
                "example": "500 [0, 1000]",
                "description": "Max size of the mana pool"
            },
            {
                "type": "float",
                "name": "gold",
                "example": "0 [0, 1000]",
                "description": "How much gold the player has"
            }
        ],
        "privates": [
            {
                "type": "Entity*",
                "name": "god_entity"
            }
        ]
    },
    {
        "name": "GunComponent",
        "privates": [
            {
                "type": "LuaManager*",
                "name": "mLuaManager"
            }
        ]
    },
    {
        "name": "HealthBarComponent"
    },
    {
        "name": "HitEffectComponent",
        "members": [
            {
                "type": "int",
                "name": "value",
                "example": "0 [0, 100]",
                "description": "Usage depends on selected 'effect_hit'"
            },
            {
                "type": "std::string",
                "name": "value_string",
                "description": "Usage depends on selected 'effect_hit'"
            }
        ],
        "custom_data_types": [
            {
                "type": "GAME_EFFECT::Enum",
                "name": "condition_effect",
                "description": "Hit entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic"
            },
            {
                "type": "StatusEffectType",
                "name": "condition_status",
                "example": "0 [0, 1]",
                "description": "Hit entity needs to have this 'STATUS_EFFECT' for effects to apply"
            },
            {
                "type": "HIT_EFFECT::Enum",
                "name": "effect_hit",
                "description": "What kind of 'HIT_EFFECT' is applied to hit entity if condition is true"
            }
        ]
    },
    {
        "name": "HitboxComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_player",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_enemy",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_item",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "aabb_min_x",
                "example": "-5 [-15, 15]"
            },
            {
                "type": "float",
                "name": "aabb_max_x",
                "example": "5 [-15, 15]"
            },
            {
                "type": "float",
                "name": "aabb_min_y",
                "example": "-5 [-15, 15]"
            },
            {
                "type": "float",
                "name": "aabb_max_y",
                "example": "5 [-15, 15]"
            },
            {
                "type": "float",
                "name": "damage_multiplier",
                "example": "1 [0, 1]",
                "description": "All damage from hits to this hitbox is multiplied with this value before applying it."
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "dead",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "offset"
            }
        ]
    },
    {
        "name": "HomingComponent",
        "members": [
            {
                "type": "std::string",
                "name": "target_tag",
                "example": "homing_target [0, 1]"
            },
            {
                "type": "bool",
                "name": "target_who_shot",
                "example": "0 [0, 1]",
                "description": "If 1, targets who shot the projectile, ignores 'target_tag'."
            },
            {
                "type": "float",
                "name": "detect_distance",
                "example": "150 [0, 1000]"
            },
            {
                "type": "float",
                "name": "homing_velocity_multiplier",
                "example": "0.9 [-100, 100]"
            },
            {
                "type": "float",
                "name": "homing_targeting_coeff",
                "example": "160 [0, 1000]"
            },
            {
                "type": "bool",
                "name": "just_rotate_towards_target",
                "example": "0 [0, 1]",
                "description": "the default accelerates towards a target. If true will only rotate towards the target."
            },
            {
                "type": "float",
                "name": "max_turn_rate",
                "example": "0.05 [0, 6.283]",
                "description": "radians. If just_rotate_towards_target then this is the maximum radians it can turn per frame"
            },
            {
                "type": "EntityID",
                "name": "predefined_target",
                "example": "0 [0, 1]",
                "description": "If set, we track this entity"
            },
            {
                "type": "bool",
                "name": "look_for_root_entities_only",
                "example": "0 [0, 1]",
                "description": "if set, will only look for entities that are _not_ child entities."
            }
        ]
    },
    {
        "name": "HotspotComponent",
        "members": [
            {
                "type": "bool",
                "name": "transform_with_scale",
                "example": "1 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "sprite_hotspot_name"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "offset"
            }
        ]
    },
    {
        "name": "IKLimbAttackerComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "54 [0, 1]"
            },
            {
                "type": "float",
                "name": "leg_velocity_coeff",
                "example": "15 [0, 1]"
            },
            {
                "type": "float",
                "name": "targeting_radius",
                "example": "120 [0, 1]"
            },
            {
                "type": "bool",
                "name": "targeting_raytrace",
                "example": "1 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "target_entities_with_tag",
                "example": "mortal [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "mTargetEntity",
                "example": "0 [0, 1]"
            },
            {
                "type": "IKLimbAttackerState",
                "name": "mState"
            },
            {
                "type": "float",
                "name": "mStateTimer",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "mTarget"
            }
        ]
    },
    {
        "name": "IKLimbComponent",
        "members": [
            {
                "type": "float",
                "name": "length",
                "example": "40 [0, 1]"
            },
            {
                "type": "float",
                "name": "thigh_extra_lenght",
                "example": "2 [0, 1]"
            },
            {
                "type": "float",
                "name": "mJointSideInterpolation",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mPart0PrevPos"
            },
            {
                "type": "float",
                "name": "mPart0PrevRotation",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mPart1PrevPos"
            },
            {
                "type": "float",
                "name": "mPart1PrevRotation",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "end_position"
            },
            {
                "type": "vec2",
                "name": "mJointWorldPos"
            },
            {
                "type": "vec2",
                "name": "mEndPrevPos"
            }
        ]
    },
    {
        "name": "IKLimbWalkerComponent",
        "members": [
            {
                "type": "float",
                "name": "ground_attachment_min_spread",
                "example": "16 [0, 1]"
            },
            {
                "type": "int",
                "name": "ground_attachment_max_tries",
                "example": "10 [0, 1]"
            },
            {
                "type": "float",
                "name": "ground_attachment_max_angle",
                "example": "0.8 [0, 1]"
            },
            {
                "type": "float",
                "name": "ground_attachment_ray_length_coeff",
                "example": "1.15 [0, 1]"
            },
            {
                "type": "float",
                "name": "leg_velocity_coeff",
                "example": "15 [0, 1]"
            },
            {
                "type": "bool",
                "name": "affect_flying",
                "example": "0 [0, 1]",
                "description": "if set, will cause the mFlyingTime (in CharacterDataComponent) of the parent to be 0 or 1 depending on if we're touching anything"
            },
            {
                "type": "int",
                "name": "mState",
                "example": "0 [0, 1]",
                "description": "0 = detached, 1 = attached"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "ray_skip_material",
                "example": "0 [0, 1]",
                "description": "String name of material to not cast rays against. Defaults to 'aluminium'"
            },
            {
                "type": "vec2",
                "name": "mTarget"
            },
            {
                "type": "vec2",
                "name": "mPrevTarget"
            },
            {
                "type": "vec2",
                "name": "mPrevCenterPosition"
            }
        ]
    },
    {
        "name": "IKLimbsAnimatorComponent",
        "members": [
            {
                "type": "int",
                "name": "future_state_samples",
                "example": "10 [0, 1]",
                "description": "The number of future animation states evaluated to find the next state"
            },
            {
                "type": "float",
                "name": "ground_attachment_ray_length_coeff",
                "example": "1.15 [0, 1]",
                "description": "Limb raycast length is (ground_attachment_ray_length_coeff * limb length)"
            },
            {
                "type": "float",
                "name": "leg_velocity_coeff",
                "example": "15 [0, 1]",
                "description": "Limbs are moved towards target position at a pace affected by this value."
            },
            {
                "type": "bool",
                "name": "affect_flying",
                "example": "0 [0, 1]",
                "description": "If set, will cause the mFlyingTime (in CharacterDataComponent) of the entity to be 0 or 1 depending on if the limbs are touching ground"
            },
            {
                "type": "float",
                "name": "large_movement_penalty_coeff",
                "example": "0.25 [0, 1]",
                "description": "The movement score is multiplied by this value if a large move would occur"
            },
            {
                "type": "float",
                "name": "no_ground_attachment_penalty_coeff",
                "example": "0.75 [0, 1]",
                "description": "If a limb movement would make it not collide with ground, the movement score is multiplied with this value. Use lower values to make the limbs prioritize attaching to walls."
            },
            {
                "type": "bool",
                "name": "is_limp",
                "example": "0 [0, 1]",
                "description": "If 1, will apply verlet animation to simulate ragdoll-like limbs"
            }
        ],
        "privates": [
            {
                "type": "IKLimbStateVec",
                "name": "mLimbStates"
            },
            {
                "type": "bool",
                "name": "mHasGroundAttachmentOnAnyLeg",
                "example": "0 [0, 1]",
                "description": "Will be set to true if at least one leg is attached to ground."
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "ray_skip_material",
                "example": "0 [0, 1]",
                "description": "String name of material to not cast rays against. Defaults to 'aluminium'"
            },
            {
                "type": "vec2",
                "name": "mPrevBodyPosition"
            }
        ]
    },
    {
        "name": "IngestionComponent",
        "members": [
            {
                "type": "int64",
                "name": "ingestion_size",
                "example": "0 [0, 1]",
                "description": "How many units of material we currently store"
            },
            {
                "type": "int64",
                "name": "ingestion_capacity",
                "example": "7500 [0, 1]",
                "description": "How many units of material we can store"
            },
            {
                "type": "uint32",
                "name": "ingestion_cooldown_delay_frames",
                "example": "600 [0, 1]",
                "description": "How many frames is ingestion_size retained after last time eating?"
            },
            {
                "type": "uint32",
                "name": "ingestion_reduce_every_n_frame",
                "example": "5 [0, 1]",
                "description": "One unit of ingestion_size is removed every N frame"
            },
            {
                "type": "float",
                "name": "overingestion_damage",
                "example": "0.002 [0, 1]",
                "description": "How much damage per overingested cell is applied"
            },
            {
                "type": "float",
                "name": "blood_healing_speed",
                "example": "0.0008 [0, 1000]",
                "description": "affects healing speed if entity has HEALING_BLOOD game effect. The amount of hp restored per one blood cell."
            },
            {
                "type": "std::string",
                "name": "ingestion_satiation_material_tag",
                "description": "If set, only materials with this tag will increase satiation level"
            },
            {
                "type": "int32",
                "name": "m_ingestion_cooldown_frames",
                "example": "0 [0, 1]",
                "description": "Next frame ingestion_size cooldown can occur"
            }
        ],
        "privates": [
            {
                "type": "int32",
                "name": "m_next_overeating_msg_frame",
                "example": "0 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "m_ingestion_satiation_material_tag_cached"
            },
            {
                "type": "std::set<int32>",
                "name": "m_ingestion_satiation_material_cache"
            },
            {
                "type": "int32",
                "name": "m_damage_effect_lifetime",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "InheritTransformComponent",
        "members": [
            {
                "type": "bool",
                "name": "use_root_parent",
                "example": "0 [0, 1]",
                "description": "if 1, we use the root of our entity hierarchy instead of the immediate parent"
            },
            {
                "type": "bool",
                "name": "only_position",
                "example": "0 [0, 1]",
                "description": "if 1, we only inherit position. it is calculated as follows: parent_position + parent_offset * parent_scale"
            },
            {
                "type": "std::string",
                "name": "parent_hotspot_tag",
                "description": "if set, we apply the offset of parent HotSpot with this tag"
            },
            {
                "type": "int",
                "name": "parent_sprite_id",
                "example": "-1 [0, 1]",
                "description": "if >= 0, the Nth sprite transform in parent entity is inherited"
            },
            {
                "type": "bool",
                "name": "always_use_immediate_parent_rotation",
                "example": "0 [0, 1]",
                "description": "if 1, we use the immediate parent for rotation, no matter what other properties say"
            },
            {
                "type": "bool",
                "name": "rotate_based_on_x_scale",
                "example": "0 [0, 1]",
                "description": "if 1, the rotation is set to 0 deg if scale >= 0 else to 180 deg"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mUpdateFrame",
                "example": "-1 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "types::xform",
                "name": "Transform"
            }
        ]
    },
    {
        "name": "InteractableComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "10 [0, 1]",
                "description": "Distance from entity position where interaction is possible"
            },
            {
                "type": "std::string",
                "name": "ui_text",
                "description": "key or string for the text to display"
            },
            {
                "type": "std::string",
                "name": "name",
                "description": "this name is called to the on_interacted function on LuaComponents"
            },
            {
                "type": "int",
                "name": "exclusivity_group",
                "example": "0 [0, 1]",
                "description": "If > 0, only 1 instance of this interaction can be display at the same time"
            }
        ]
    },
    {
        "name": "Inventory2Component",
        "members": [
            {
                "type": "int",
                "name": "quick_inventory_slots",
                "example": "10 [0, 30]"
            },
            {
                "type": "int",
                "name": "full_inventory_slots_x",
                "example": "8 [0, 30]"
            },
            {
                "type": "int",
                "name": "full_inventory_slots_y",
                "example": "8 [0, 30]"
            },
            {
                "type": "uint32",
                "name": "mSavedActiveItemIndex",
                "example": "0 [0, 1]",
                "description": "Used to retain active item across save/load. Don't touch this unless you know what you're doing!"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "mActiveItem",
                "example": "0 [0, 1]",
                "description": "NOTE: Don't attempt to directly change the value of this field via lua code. It will probably break the game logic in obvious or subtle ways."
            },
            {
                "type": "EntityID",
                "name": "mActualActiveItem",
                "example": "0 [0, 1]",
                "description": "NOTE: Don't attempt to directly change the value of this field via lua code. It will probably break the game logic in obvious or subtle ways."
            },
            {
                "type": "EntityID",
                "name": "mActiveStash",
                "example": "0 [0, 1]"
            },
            {
                "type": "EntityID",
                "name": "mThrowItem",
                "example": "0 [0, 1]",
                "description": "Is used to store the item that is being thrown, instead of mActiveItem, since the player can switch items (mActiveItem) during the throwing animation"
            },
            {
                "type": "bool",
                "name": "mItemHolstered",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mInitialized",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mForceRefresh",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDontLogNextItemEquip",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mSmoothedItemXOffset",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLastItemSwitchFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mIntroEquipItemLerp",
                "example": "1 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mSmoothedItemAngleVec"
            }
        ]
    },
    {
        "name": "InventoryComponent",
        "members": [
            {
                "type": "int",
                "name": "ui_container_type",
                "example": "1 [0, 1]",
                "description": "UI_CONTAINER_TYPES enum"
            },
            {
                "type": "std::string",
                "name": "ui_element_sprite",
                "example": "data/ui_gfx/inventory/inventory_box.png [0, 1]",
                "description": "ui back sprite"
            },
            {
                "type": "std::string",
                "name": "actions",
                "description": "list of actions, used for serialization"
            }
        ],
        "privates": [
            {
                "type": "InvenentoryUpdateListener*",
                "name": "update_listener",
                "description": "listener to keep ui up with ability changes"
            },
            {
                "type": "INVENTORYITEM_VECTOR",
                "name": "items"
            }
        ],
        "custom_data_types": [
            {
                "type": "ivec2",
                "name": "ui_container_size",
                "description": "ui size, how many items x*y we can fit in"
            },
            {
                "type": "ivec2",
                "name": "ui_element_size",
                "description": "ui size"
            },
            {
                "type": "ivec2",
                "name": "ui_position_on_screen",
                "description": "where do we load this on screen"
            }
        ]
    },
    {
        "name": "InventoryGuiComponent",
        "members": [
            {
                "type": "bool",
                "name": "has_opened_inventory_edit",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "wallet_money_target",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mDisplayFireRateWaitBar",
                "example": "0 [0, 1]",
                "description": "hax, don't touch!"
            }
        ],
        "privates": [
            {
                "type": "ImGuiContext*",
                "name": "imgui"
            },
            {
                "type": "int",
                "name": "mLastFrameInteracted",
                "example": "-100 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLastFrameActionsVisible",
                "example": "-1 [0, 1]"
            },
            {
                "type": "Entity*",
                "name": "mLastPurchasedAction"
            },
            {
                "type": "bool",
                "name": "mActive",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mAlpha",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "mBackgroundOverlayAlpha",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFrameShake_ReloadBar",
                "example": "0 [0, 1]",
                "description": "for animations of shaking them bars"
            },
            {
                "type": "int",
                "name": "mFrameShake_ManaBar",
                "example": "0 [0, 1]",
                "description": "for animations of shaking them bars"
            },
            {
                "type": "int",
                "name": "mFrameShake_FlyBar",
                "example": "0 [0, 1]",
                "description": "for animations of shaking them bars"
            },
            {
                "type": "int",
                "name": "mFrameShake_FireRateWaitBar",
                "example": "0 [0, 1]",
                "description": "for animations of shaking them bars"
            }
        ]
    },
    {
        "name": "ItemAIKnowledgeComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_ranged_weapon",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_throwable_weapon",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_melee_weapon",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_self_healing",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_other_healing",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_self_buffing",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_other_buffing",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_weapon",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_known",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_safe",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_consumed",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "never_use",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "ranged_min_distance",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ItemActionComponent",
        "members": [
            {
                "type": "std::string",
                "name": "action_id",
                "description": "the name ID of the action"
            }
        ]
    },
    {
        "name": "ItemAlchemyComponent",
        "custom_data_types": [
            {
                "type": "int",
                "name": "material_make_always_cast",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "material_remove_shuffle",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "material_animate_wand",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "material_animate_wand_alt",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "material_increase_uses_remaining",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "material_sacrifice",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ItemChestComponent",
        "members": [
            {
                "type": "int",
                "name": "item_count_min",
                "example": "0 [0, 1e+006]"
            },
            {
                "type": "int",
                "name": "item_count_max",
                "example": "0 [0, 1e+006]"
            },
            {
                "type": "int",
                "name": "level",
                "example": "0 [0, 1e+006]"
            },
            {
                "type": "bool",
                "name": "enemy_drop",
                "example": "0 [0, 1]",
                "description": "enemy_drop, if set will modify the item_count_min, item_count_max..."
            },
            {
                "type": "std::string",
                "name": "actions",
                "description": "e.g. 'bullet,bullet,damage' ... actions are parsed into a string"
            },
            {
                "type": "std::string",
                "name": "action_uses_remaining",
                "description": "e.g. '10,10,-1' ... action uses remaining counts are parsed into a string"
            },
            {
                "type": "std::string",
                "name": "other_entities_to_spawn",
                "description": "file names of other entities we should spawn from this chest, comma separated"
            },
            {
                "type": "unsignedint",
                "name": "mSeed",
                "example": "0 [0, 1]",
                "description": "this is used to figure out what we spawn from this chest"
            }
        ]
    },
    {
        "name": "ItemComponent",
        "members": [
            {
                "type": "std::string",
                "name": "item_name",
                "description": "the name of the item"
            },
            {
                "type": "bool",
                "name": "is_stackable",
                "example": "0 [0, 1]",
                "description": "does this item stack on other items the same 'item_name' in the inventory?"
            },
            {
                "type": "bool",
                "name": "is_consumable",
                "example": "0 [0, 1]",
                "description": "if 1, using this item will reduce 'uses_remaining'. When it reaches zero the item is destroyed"
            },
            {
                "type": "bool",
                "name": "stats_count_as_item_pick_up",
                "example": "1 [0, 1]",
                "description": "does this count as an item that was picked up in the stats"
            },
            {
                "type": "bool",
                "name": "auto_pickup",
                "example": "0 [0, 1]",
                "description": "if 1, item will be automatically picked up, no pickup hint is shown"
            },
            {
                "type": "bool",
                "name": "permanently_attached",
                "example": "0 [0, 1]",
                "description": "if 1, this item can't be removed from a container once it is put inside one"
            },
            {
                "type": "int",
                "name": "uses_remaining",
                "example": "-1 [0, 1]",
                "description": "how many times can this item be used? -1 = unlimited, will be reset to gun_actions.lua max_uses by inventorygui_system, -2 = unlimited unlimited"
            },
            {
                "type": "bool",
                "name": "is_identified",
                "example": "1 [0, 1]",
                "description": "is it known what this item does?"
            },
            {
                "type": "bool",
                "name": "is_frozen",
                "example": "0 [0, 1]",
                "description": "if 1, this item can't be modified or moved from a wand"
            },
            {
                "type": "bool",
                "name": "collect_nondefault_actions",
                "example": "0 [0, 1]",
                "description": "does player keep this item when respawning?"
            },
            {
                "type": "bool",
                "name": "remove_on_death",
                "example": "0 [0, 1]",
                "description": "is this entity destroyed when it's in an inventory and the inventory owner dies?"
            },
            {
                "type": "bool",
                "name": "remove_on_death_if_empty",
                "example": "0 [0, 1]",
                "description": "is this entity destroyed when it's in an inventory, empty and the inventory owner dies?"
            },
            {
                "type": "bool",
                "name": "remove_default_child_actions_on_death",
                "example": "0 [0, 1]",
                "description": "if true, the default AbilityComponent.child_actions in this items will be removed when it dies"
            },
            {
                "type": "bool",
                "name": "play_hover_animation",
                "example": "0 [0, 1]",
                "description": "if 1, the item will play a hovering animation"
            },
            {
                "type": "bool",
                "name": "play_spinning_animation",
                "example": "1 [0, 1]",
                "description": "if 1, the item will play a spinning animation, if player_hover_animation is 0"
            },
            {
                "type": "bool",
                "name": "is_equipable_forced",
                "example": "0 [0, 1]",
                "description": "if 1, the default logic for determining if an item can be equiped in inventory is overridden and this can be always equipped"
            },
            {
                "type": "bool",
                "name": "play_pick_sound",
                "example": "1 [0, 1]",
                "description": "if 1, plays a default sound when picked"
            },
            {
                "type": "bool",
                "name": "drinkable",
                "example": "1 [0, 1]",
                "description": "if 0 you cannot drink this, default is 1, because that's how it was implemented and backwards compatibility"
            },
            {
                "type": "int",
                "name": "max_child_items",
                "example": "0 [0, 1]",
                "description": "number of items this can hold inside itself. TODO: get rid of all uses of 'ability->gun_config.deck_capacity' and replace them with this!"
            },
            {
                "type": "std::string",
                "name": "ui_sprite",
                "description": "sprite displayed for the item in various UIs. If not empty overrides sprites declared by Ability and ItemAction"
            },
            {
                "type": "std::string",
                "name": "ui_description",
                "description": "item description displayed in various UIs"
            },
            {
                "type": "bool",
                "name": "enable_orb_hacks",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_all_spells_book",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "always_use_item_name_in_ui",
                "example": "0 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "custom_pickup_string",
                "description": "if set, this is used for the 'Press $0 to pick $1' message"
            },
            {
                "type": "bool",
                "name": "ui_display_description_on_pick_up_hint",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "next_frame_pickable",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "npc_next_frame_pickable",
                "example": "0 [0, 1]",
                "description": "NPC have their own next_frame_pickable, because this is used to make NPCs not pick up gold, which also meant player couldn't pick up that gold"
            },
            {
                "type": "bool",
                "name": "is_pickable",
                "example": "1 [0, 1]",
                "description": "can this be picked up and placed on someone's inventory"
            },
            {
                "type": "bool",
                "name": "is_hittable_always",
                "example": "0 [0, 1]",
                "description": "to override the weirdness that is is_pickable, which affects if this is hittable or not. If true, will always be hittable regardless of is_pickable"
            },
            {
                "type": "float",
                "name": "item_pickup_radius",
                "example": "14.1 [0, 1]",
                "description": "how many pixels away can this item be picked up from"
            },
            {
                "type": "float",
                "name": "camera_max_distance",
                "example": "50 [0, 1]",
                "description": "how far can we move the camera from the player when this item is equipped"
            },
            {
                "type": "float",
                "name": "camera_smooth_speed_multiplier",
                "example": "1 [0, 1]",
                "description": "how quickly does the camera follow player?"
            },
            {
                "type": "bool",
                "name": "has_been_picked_by_player",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFramePickedUp",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mItemUid",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mIsIdentified",
                "example": "1 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "spawn_pos",
                "description": "the position where this item spawned"
            },
            {
                "type": "INVENTORY_KIND::Enum",
                "name": "preferred_inventory",
                "description": "Which inventory do we go to when we're picked up, if it's not full."
            },
            {
                "type": "ivec2",
                "name": "inventory_slot",
                "description": "our preferred slot (x,y) in the inventory"
            }
        ]
    },
    {
        "name": "ItemCostComponent",
        "members": [
            {
                "type": "int64",
                "name": "cost",
                "example": "100 [0, 3500]"
            },
            {
                "type": "bool",
                "name": "stealable",
                "example": "0 [0, 1]",
                "description": "if set - will check that it's within an area called shop"
            }
        ],
        "privates": [
            {
                "type": "int64",
                "name": "mExCost",
                "example": "-1 [0, 1]",
                "description": "used to change the text on the sprite"
            }
        ]
    },
    {
        "name": "ItemPickUpperComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_in_npc",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "pick_up_any_item_buggy",
                "example": "0 [0, 1]",
                "description": "If true, will pick up _any_ item. Breaks all kinds of things, but maybe mods will find this fun to mess around with"
            },
            {
                "type": "bool",
                "name": "is_immune_to_kicks",
                "example": "0 [0, 1]",
                "description": "if set, won't drop the wand if kicked. Mainly used by wand ghosts."
            },
            {
                "type": "EntityID",
                "name": "only_pick_this_entity",
                "example": "0 [0, 1]",
                "description": "picks up this entity and only this entity. Overrides the is_in_npc checks that try to limit things to pickuppable wands"
            },
            {
                "type": "bool",
                "name": "drop_items_on_death",
                "example": "1 [0, 1]",
                "description": "if true, will drop all items. E.g. if true for player, player drops their wands"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "mLatestItemOverlapInfoBoxPosition"
            }
        ]
    },
    {
        "name": "ItemRechargeNearGroundComponent",
        "members": [
            {
                "type": "float",
                "name": "TEMP_TEMPY",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "TEMP_TEMP_TEMP",
                "example": "0 [0, 3.5]"
            }
        ]
    },
    {
        "name": "ItemStashComponent",
        "members": [
            {
                "type": "int",
                "name": "throw_openable_cooldown_frames",
                "example": "30 [0, 180]"
            },
            {
                "type": "bool",
                "name": "init_children",
                "example": "1 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mNextFrameOpenable",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFrameOpened",
                "example": "-1 [0, 1]"
            }
        ]
    },
    {
        "name": "KickComponent",
        "members": [
            {
                "type": "bool",
                "name": "can_kick",
                "example": "1 [0, 1]",
                "description": "e.g. telekinetic kick disables this"
            },
            {
                "type": "float",
                "name": "kick_radius",
                "example": "3 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "telekinesis_throw_speed",
                "example": "25 [0, 1]",
                "description": "this is here, so that STRONG_KICK -perk can affect telekinetic kick as well"
            },
            {
                "type": "std::string",
                "name": "kick_entities",
                "description": "comma separated list of entities that are loaded when player kicks"
            }
        ],
        "custom_data_types": [
            {
                "type": "LensValue<float>",
                "name": "max_force"
            },
            {
                "type": "LensValue<float>",
                "name": "player_kickforce"
            },
            {
                "type": "LensValue<float>",
                "name": "kick_damage",
                "description": "( 1.f / 25.f )"
            },
            {
                "type": "LensValue<float>",
                "name": "kick_knockback",
                "description": "knockback force for entities"
            }
        ]
    },
    {
        "name": "LaserEmitterComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_emitting",
                "example": "1 [0, 1]",
                "description": "If 1, will emit all the time"
            },
            {
                "type": "int32",
                "name": "emit_until_frame",
                "example": "-1 [0, 1]",
                "description": "Can be used to activate a laser temporarily"
            },
            {
                "type": "float",
                "name": "laser_angle_add_rad",
                "example": "0 [0, 1]",
                "description": "Beam angle = entity angle + laser_angle_add_rad"
            }
        ],
        "objects": [
            {
                "type": "ConfigLaser",
                "name": "laser"
            }
        ]
    },
    {
        "name": "LevitationComponent",
        "members": [
            {
                "type": "float",
                "name": "radius",
                "example": "20 [1, 50]",
                "description": "the radius in which we look for entities / bodies to float"
            },
            {
                "type": "float",
                "name": "entity_force",
                "example": "0.3 [0, 1]",
                "description": "how much do we apply the mouse movements to the entitiy"
            },
            {
                "type": "float",
                "name": "box2d_force",
                "example": "0.3 [0, 1]",
                "description": "how much do we apply the mouse movements to the entitiy"
            },
            {
                "type": "int",
                "name": "effect_lifetime_frames",
                "example": "600 [1, 600]"
            }
        ]
    },
    {
        "name": "LifetimeComponent",
        "members": [
            {
                "type": "int",
                "name": "lifetime",
                "example": "-1 [0, 1]",
                "description": "if anything else than -1 will kill this entity when this many frames have passed"
            },
            {
                "type": "bool",
                "name": "fade_sprites",
                "example": "0 [0, 1]",
                "description": "if 1, sprites will be faded as lifetime gets lower"
            },
            {
                "type": "bool",
                "name": "kill_parent",
                "example": "0 [0, 1]",
                "description": "if 1, will kill the parent entity"
            },
            {
                "type": "bool",
                "name": "kill_all_parents",
                "example": "0 [0, 1]",
                "description": "if 1, will kill all the parents entity"
            },
            {
                "type": "bool",
                "name": "serialize_duration",
                "example": "0 [0, 1]",
                "description": "if 1, will retain kill_frame and creation_frame over serialization"
            },
            {
                "type": "int",
                "name": "kill_frame_serialized",
                "example": "0 [0, 1]",
                "description": "frame that this is killed at"
            },
            {
                "type": "int",
                "name": "creation_frame_serialized",
                "example": "0 [0, 1]",
                "description": "frame that this is killed at"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "creation_frame",
                "example": "0 [0, 1]",
                "description": "we'll set this to GG.GetFrameNum() when this component is created"
            },
            {
                "type": "int",
                "name": "kill_frame",
                "example": "0 [0, 1]",
                "description": "frame that this is killed at"
            }
        ],
        "custom_data_types": [
            {
                "type": "ValueRange",
                "name": "randomize_lifetime",
                "description": "this is added to the lifetime"
            }
        ]
    },
    {
        "name": "LightComponent",
        "members": [
            {
                "type": "bool",
                "name": "update_properties",
                "example": "0 [0, 1]",
                "description": "turn this on if you expect this to function like the other components"
            },
            {
                "type": "float",
                "name": "radius",
                "example": "0 [0, 3000]",
                "description": "The radius of the light in world pixels."
            },
            {
                "type": "unsignedint",
                "name": "r",
                "example": "255 [0, 255]",
                "description": "Color red 0-255"
            },
            {
                "type": "unsignedint",
                "name": "g",
                "example": "178 [0, 255]",
                "description": "Color green 0-255"
            },
            {
                "type": "unsignedint",
                "name": "b",
                "example": "118 [0, 255]",
                "description": "Color blue 0-255"
            },
            {
                "type": "float",
                "name": "offset_x",
                "example": "0 [-3000, 3000]",
                "description": "Offset from the center of entity."
            },
            {
                "type": "float",
                "name": "offset_y",
                "example": "0 [-3000, 3000]",
                "description": "Offset from the center of entity."
            },
            {
                "type": "float",
                "name": "fade_out_time",
                "example": "0 [0, 5]",
                "description": "time in seconds, if not 0, this is how long this takes to die, when the component is destroyed"
            },
            {
                "type": "float",
                "name": "blinking_freq",
                "example": "1 [0, 1]",
                "description": "if less than 1, will blink randomly when rand() < blinking_freq"
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "mAlpha",
                "example": "1 [0, 1]"
            },
            {
                "type": "as::Sprite*",
                "name": "mSprite"
            }
        ]
    },
    {
        "name": "LightningComponent",
        "members": [
            {
                "type": "std::string",
                "name": "sprite_lightning_file",
                "example": "data/particles/lightning_ray.png [0, 1]",
                "description": "particle effect, from where the file is loaded that lightning is generated from"
            },
            {
                "type": "bool",
                "name": "is_projectile",
                "example": "0 [0, 1]",
                "description": "if this is true, it's a projectile lightning and looks for ProjectileComponent and uses the data from there to move it"
            },
            {
                "type": "int",
                "name": "explosion_type",
                "example": "1 [0, 1]",
                "description": "1 = lightning trail"
            },
            {
                "type": "int",
                "name": "arc_lifetime",
                "example": "60 [0, 1]",
                "description": "remaining number of frames the arc exists"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mExPosition",
                "description": "stores the ex position of this entity"
            },
            {
                "type": "EntityID",
                "name": "mArcTarget",
                "example": "0 [0, 1]",
                "description": "if 'mArcTarget' points to an existing entity a lighting arc will be created between this entity and 'mArcTarget'"
            }
        ],
        "objects": [
            {
                "type": "ConfigExplosion",
                "name": "config_explosion"
            }
        ]
    },
    {
        "name": "LimbBossComponent",
        "members": [
            {
                "type": "int",
                "name": "state",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mStatePrev",
                "example": "-1 [0, 1]"
            },
            {
                "type": "float",
                "name": "mMoveToPositionX",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mMoveToPositionY",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "LiquidDisplacerComponent",
        "members": [
            {
                "type": "int",
                "name": "radius",
                "example": "1 [0, 20]"
            },
            {
                "type": "float",
                "name": "velocity_x",
                "example": "30 [0, 100]"
            },
            {
                "type": "float",
                "name": "velocity_y",
                "example": "30 [0, 100]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mPrevX",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mPrevY",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "LoadEntitiesComponent",
        "members": [
            {
                "type": "std::string",
                "name": "entity_file",
                "description": "path to the entity file we should load"
            },
            {
                "type": "bool",
                "name": "kill_entity",
                "example": "1 [0, 1]",
                "description": "if 1, we kill our entity when it is created"
            },
            {
                "type": "int",
                "name": "timeout_frames",
                "example": "0 [0, 180]",
                "description": "for timer"
            },
            {
                "type": "int",
                "name": "mTimerTriggerFrame",
                "example": "-1 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "ValueRangeInt",
                "name": "count",
                "description": "how many entities should be loaded (random range)"
            }
        ]
    },
    {
        "name": "LocationMarkerComponent",
        "members": [
            {
                "type": "int",
                "name": "id",
                "example": "0 [0, 3]"
            }
        ]
    },
    {
        "name": "LooseGroundComponent",
        "members": [
            {
                "type": "float",
                "name": "probability",
                "example": "0 [0, 1]",
                "description": "how often do we do this... shoots a ray in random direction and does the loosening"
            },
            {
                "type": "int",
                "name": "max_durability",
                "example": "2147483647 [0, 1]",
                "description": "if material durability > max_durability, it is not loosened"
            },
            {
                "type": "float",
                "name": "max_distance",
                "example": "256 [0, 1]",
                "description": "how far raytraces to find things to loosen up"
            },
            {
                "type": "float",
                "name": "max_angle",
                "example": "1.57 [0, 1]",
                "description": "how much raytraces go to different directions around the up-vector. pi=full circle"
            },
            {
                "type": "int",
                "name": "min_radius",
                "example": "3 [0, 1]",
                "description": "the minimum radius of our loosening of pixels"
            },
            {
                "type": "int",
                "name": "max_radius",
                "example": "8 [0, 1]",
                "description": "the maximum radius of our loosening of pixels"
            },
            {
                "type": "float",
                "name": "chunk_probability",
                "example": "0 [0, 1]",
                "description": "if > 0, will drop box2d chunks of the ceiling"
            },
            {
                "type": "float",
                "name": "chunk_max_angle",
                "example": "0.7 [0, 1]",
                "description": "how much raytraces go to different directions around the up-vector. pi=full circle"
            },
            {
                "type": "int",
                "name": "chunk_count",
                "example": "-1 [0, 1]",
                "description": "how many chunks are we allowed to do, -1 = infinite"
            },
            {
                "type": "std::string",
                "name": "collapse_images",
                "example": "data/procedural_gfx/collapse_big/$[0-14].png [0, 1]",
                "description": "loads these files randomly to do the collapse shapes"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mChunkCount",
                "example": "0 [0, 1]",
                "description": "how many chunks are we allowed to do, -1 = infinite"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "chunk_material",
                "example": "0 [0, 1]",
                "description": "String name of chunk material"
            }
        ]
    },
    {
        "name": "LuaComponent",
        "members": [
            {
                "type": "std::string",
                "name": "script_source_file"
            },
            {
                "type": "bool",
                "name": "execute_on_added",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "execute_on_removed",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "execute_every_n_frame",
                "example": "1 [1, 150]",
                "description": "1 = execute every frame. 2 = execute every second frame. 3 = execute every third frame and so on. -1 = execute only on add/remove/event"
            },
            {
                "type": "int",
                "name": "execute_times",
                "example": "0 [0, 1]",
                "description": "How many times should the script be executed? < 1 means infinite"
            },
            {
                "type": "int",
                "name": "limit_how_many_times_per_frame",
                "example": "-1 [0, 1]",
                "description": "-1 = infinite. Use this to limit how many times this can be executed per frame. Currently only used to limit script_shot from being executed forever."
            },
            {
                "type": "int",
                "name": "limit_to_every_n_frame",
                "example": "-1 [0, 1]",
                "description": "-1 = no limit. Currently only used to limit script_shot from being executed every frame."
            },
            {
                "type": "bool",
                "name": "limit_all_callbacks",
                "example": "0 [0, 1]",
                "description": "NOTE( Petri ): 19.8.2023 - by default limit_how_many_times_per_frame and limit_to_every_n_frame only works for script_shot. If this is set to true, will limit all callbacks. Also note that this limit is shared within this component. So if this is true and both script_shot and script_damage_received and both are called within limit_to_every_n_frame frames, only one of them will be called."
            },
            {
                "type": "bool",
                "name": "remove_after_executed",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "enable_coroutines",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "call_init_function",
                "example": "0 [0, 1]",
                "description": " if 1, calls function init( entity_id:int ) after running the code in the file scope of script_source_file along with all mod appends. Does nothing if execute_on_added is 0"
            },
            {
                "type": "std::string",
                "name": "script_enabled_changed",
                "description": "if set, calls function 'enabled_changed( entity_id:int, is_enabled:bool )' when the IsEnabled status of this LuaComponent is changed"
            },
            {
                "type": "std::string",
                "name": "script_damage_received",
                "description": "if set, calls function 'damage_received( damage:number, message:string, entity_thats_responsible:int, is_fatal:bool, projectile_thats_responsible:int )' when we receive a message about damage (Message_DamageReceived)"
            },
            {
                "type": "std::string",
                "name": "script_damage_about_to_be_received",
                "description": "if set, calls function 'damage_about_to_be_received( damage:number, x:number, y:number, entity_thats_responsible:int, critical_hit_chance:int )' when we receive a message (Message_DamageAboutToBeReceived) -> new_damage:number,new_critical_hit_chance:int"
            },
            {
                "type": "std::string",
                "name": "script_item_picked_up",
                "description": "if set, calls function 'item_pickup( int entity_item, int entity_pickupper, string item_name )' when message 'Message_ItemPickUp' is called"
            },
            {
                "type": "std::string",
                "name": "script_shot",
                "description": "if set, calls function 'shot( projectile_entity_id )' when we receive Message_Shot"
            },
            {
                "type": "std::string",
                "name": "script_collision_trigger_hit",
                "description": "if set, calls function 'collision_trigger( colliding_entity_id )' when we receive Message_CollisionTriggerHit"
            },
            {
                "type": "std::string",
                "name": "script_collision_trigger_timer_finished",
                "description": "if set, calls function 'collision_trigger_timer_finished()' when we receive Message_CollisionTriggerTimerFinished"
            },
            {
                "type": "std::string",
                "name": "script_physics_body_modified",
                "description": "if set, calls function 'physics_body_modified( is_destroyed )' when physics body has been modified"
            },
            {
                "type": "std::string",
                "name": "script_pressure_plate_change",
                "description": "if set, calls function 'pressure_plate_change( new_state )' when PressurePlateComponent decides that things have change"
            },
            {
                "type": "std::string",
                "name": "script_inhaled_material",
                "description": "if set, calls function 'inhaled_material( material_name, count )' once per second for each inhaled material"
            },
            {
                "type": "std::string",
                "name": "script_death",
                "description": "if set, calls function 'death( int damage_type_bit_field, string damage_message, int entity_thats_responsible, bool drop_items )' when we receive message Message_Death"
            },
            {
                "type": "std::string",
                "name": "script_throw_item",
                "description": "if set, calls function 'throw_item( from_x, from_y, to_x, to_y )' when we receive message Message_ThrowItem"
            },
            {
                "type": "std::string",
                "name": "script_material_area_checker_failed",
                "description": "if set, calls function 'material_area_checker_failed( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerFailed"
            },
            {
                "type": "std::string",
                "name": "script_material_area_checker_success",
                "description": "if set, calls function 'material_area_checker_success( pos_x, pos_y, )' when we receive message Message_MaterialAreaCheckerSuccess"
            },
            {
                "type": "std::string",
                "name": "script_electricity_receiver_switched",
                "description": "if set, calls function 'electricity_receiver_switched( bool is_electrified )' when we receive message Message_ElectricityReceiverSwitched"
            },
            {
                "type": "std::string",
                "name": "script_electricity_receiver_electrified",
                "description": "if set, calls function 'electricity_receiver_electrified()' when we receive message Message_ElectricityReceiverElectrified"
            },
            {
                "type": "std::string",
                "name": "script_kick",
                "description": "if set, calls function 'kick( entity_who_kicked )' when we receive message Message_Kick"
            },
            {
                "type": "std::string",
                "name": "script_interacting",
                "description": "if set, calls function 'interacting( entity_who_interacted, entity_interacted, interactable_name )' when we receive message Message_Interaction"
            },
            {
                "type": "std::string",
                "name": "script_audio_event_dead",
                "description": "if set, calls function 'audio_event_dead( bank_file, event_root )' when we receive message Message_AudioEventDead"
            },
            {
                "type": "std::string",
                "name": "script_wand_fired",
                "description": "if set, calls function 'wand_fired( gun_entity_id )' when we receive Message_WandFired"
            },
            {
                "type": "std::string",
                "name": "script_teleported",
                "description": "if set, calls function 'teleported( from_x, from_y, to_x, to_y, bool portal_teleport )' when we receive Message_Teleported"
            },
            {
                "type": "std::string",
                "name": "script_portal_teleport_used",
                "description": "if set, calls function 'portal_teleport_used( entity_that_was_teleported, from_x, from_y, to_x, to_y )' when we receive Message_PortalTeleportUsed"
            },
            {
                "type": "std::string",
                "name": "script_polymorphing_to",
                "description": "if set, calls function 'polymorphing_to( string_entity_we_are_about_to_polymorph_to )' when we receive Message_PolymorphingTo"
            },
            {
                "type": "std::string",
                "name": "script_biome_entered",
                "description": "if set, calls function 'biome_entered( string_biome_name, string_biome_old_name )' when this entity changes biomes. Requires BiomeTrackerComponent"
            },
            {
                "type": "int",
                "name": "mLastExecutionFrame",
                "example": "-1 [0, 1]"
            },
            {
                "type": "int",
                "name": "mTimesExecutedThisFrame",
                "example": "0 [0, 1]",
                "description": "tracks how many times we've executed this frame. This will linger on and store the old value of the old frames. Used internally."
            },
            {
                "type": "bool",
                "name": "mModAppendsDone",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mNextExecutionTime",
                "example": "-1 [0, 1]"
            },
            {
                "type": "int",
                "name": "mTimesExecuted",
                "example": "0 [0, 1]"
            },
            {
                "type": "LuaManager*",
                "name": "mLuaManager"
            },
            {
                "type": "ValueMap",
                "name": "mPersistentValues"
            }
        ],
        "custom_data_types": [
            {
                "type": "LUA_VM_TYPE::Enum",
                "name": "vm_type",
                "description": "Do we share a single Lua virtual machine for everyone who runs 'script_source_file' ('SHARED_BY_MANY_COMPONENTS'), create one VM per one LuaComponent and reuse the VM in case the component runs the script multiple times ('ONE_PER_COMPONENT_INSTANCE'), or create a new VM every time the script is executed ('CREATE_NEW_EVERY_EXECUTION', deprecated)?"
            }
        ]
    },
    {
        "name": "MagicConvertMaterialComponent",
        "members": [
            {
                "type": "int",
                "name": "radius",
                "example": "256 [0, 512]"
            },
            {
                "type": "int",
                "name": "min_radius",
                "example": "0 [0, 512]",
                "description": "allows for convert to happen from x pixels from the center"
            },
            {
                "type": "bool",
                "name": "is_circle",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "steps_per_frame",
                "example": "10 [0, 512]"
            },
            {
                "type": "std::string",
                "name": "from_material_tag",
                "description": "the tag of material, e.g. [liquid]"
            },
            {
                "type": "bool",
                "name": "from_any_material",
                "example": "0 [0, 1]",
                "description": "if 1, converts any cells of any material to 'to_materia'"
            },
            {
                "type": "bool",
                "name": "clean_stains",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "extinguish_fire",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "fan_the_flames",
                "example": "0 [0, 1]",
                "description": "if > 0, will call UpdateFire() fan_the_flames times"
            },
            {
                "type": "int32",
                "name": "temperature_reaction_temp",
                "example": "0 [0, 1]",
                "description": "if != 0, will use the 'cold_freezes_to_materials' and 'warmth_melts_to_materials' in CellData to convert cells different materials"
            },
            {
                "type": "int",
                "name": "ignite_materials",
                "example": "0 [0, 1]",
                "description": "if > 0, will call Ignite() with ingite_materials as probability_of_fire"
            },
            {
                "type": "bool",
                "name": "loop",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "kill_when_finished",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "convert_entities",
                "example": "0 [0, 1]",
                "description": "if 1, kills entities with a damagemodel and converts them to 'to_material'"
            },
            {
                "type": "bool",
                "name": "stain_frozen",
                "example": "0 [0, 1]",
                "description": "petri hax"
            },
            {
                "type": "float",
                "name": "reaction_audio_amount",
                "example": "0 [0, 1]",
                "description": "if > 0, will generate chemical reaction audio at converted cells"
            },
            {
                "type": "bool",
                "name": "convert_same_material",
                "example": "1 [0, 1]",
                "description": "9.10.2020 - added this because at the end this caused the 'white ring' to appear, set it to false if you don't want constant whiteout"
            },
            {
                "type": "std::string",
                "name": "from_material_array"
            },
            {
                "type": "std::string",
                "name": "to_material_array"
            },
            {
                "type": "int",
                "name": "mRadius",
                "example": "0 [0, 512]"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mUseArrays",
                "example": "0 [0, 1]"
            },
            {
                "type": "std::vector<int>",
                "name": "mFromMaterialArray"
            },
            {
                "type": "std::vector<int>",
                "name": "mToMaterialArray"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "from_material",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "to_material",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "MagicXRayComponent",
        "members": [
            {
                "type": "int",
                "name": "radius",
                "example": "256 [0, 512]"
            },
            {
                "type": "int",
                "name": "steps_per_frame",
                "example": "10 [0, 512]"
            },
            {
                "type": "int",
                "name": "mStep",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mRadius",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "ManaReloaderComponent"
    },
    {
        "name": "MaterialAreaCheckerComponent",
        "members": [
            {
                "type": "int",
                "name": "update_every_x_frame",
                "example": "0 [0, 1]",
                "description": "if something other than 0 or 1, will only update_every_x_frames "
            },
            {
                "type": "bool",
                "name": "look_for_failure",
                "example": "1 [0, 1]",
                "description": "if true, will send message Message_MaterialAreaCheckerFailed if the material doesn't exist. If false, will send a message Message_MaterialAreaCheckerSuccess if the aabb is full of material and material2"
            },
            {
                "type": "int",
                "name": "count_min",
                "example": "0 [0, 1]",
                "description": "If > 0, and look_for_failure=0, will send message if material count exceeds this number of cells"
            },
            {
                "type": "bool",
                "name": "always_check_fullness",
                "example": "0 [0, 1]",
                "description": "if 1, and look_for_failure=0, will always check the whole area for cells"
            },
            {
                "type": "bool",
                "name": "kill_after_message",
                "example": "1 [0, 1]",
                "description": "will kill this entity after sending the message"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mPosition",
                "example": "0 [0, 1]",
                "description": "keeps track where we are"
            },
            {
                "type": "int",
                "name": "mLastFrameChecked",
                "example": "0 [0, 1]",
                "description": "keeps track of how often we've checked"
            }
        ],
        "custom_data_types": [
            {
                "type": "types::aabb",
                "name": "area_aabb",
                "description": "aabb offset, we check that this aabb contains only material"
            },
            {
                "type": "int",
                "name": "material",
                "example": "0 [0, 1]",
                "description": "String name of material that we check that the aabb contains"
            },
            {
                "type": "int",
                "name": "material2",
                "example": "0 [0, 1]",
                "description": "String name of material2 that we check that the aabb contains"
            }
        ]
    },
    {
        "name": "MaterialInventoryComponent",
        "members": [
            {
                "type": "bool",
                "name": "drop_as_item",
                "example": "1 [0, 1]",
                "description": "if true, drops a bag that the player can big up"
            },
            {
                "type": "bool",
                "name": "on_death_spill",
                "example": "0 [0, 1]",
                "description": "if true, on the death this will explode all the materials into air"
            },
            {
                "type": "bool",
                "name": "leak_gently",
                "example": "1 [0, 1]",
                "description": "NOTE( Petri ): 11.8.2023 - set this to false for old style leaky hidden piles situation."
            },
            {
                "type": "float",
                "name": "leak_on_damage_percent",
                "example": "0 [0, 1]",
                "description": "if higher than 0 then it might leak when projectile damage happens"
            },
            {
                "type": "float",
                "name": "leak_pressure_min",
                "example": "0.7 [0, 1]",
                "description": "leak pressure coefficient"
            },
            {
                "type": "float",
                "name": "leak_pressure_max",
                "example": "1.1 [0, 1]",
                "description": "leak pressure coefficient"
            },
            {
                "type": "float",
                "name": "min_damage_to_leak",
                "example": "0.09 [0, 1]",
                "description": "the minimum damage that has to be done in order for a leak to occur"
            },
            {
                "type": "float",
                "name": "b2_force_on_leak",
                "example": "0 [0, 10]",
                "description": "if 0, nothing happens, elsewise will add a b2 force to the particleemitter which will push the b2body"
            },
            {
                "type": "float",
                "name": "death_throw_particle_velocity_coeff",
                "example": "1 [0, 1]",
                "description": "how far do we throw material particles on death?"
            },
            {
                "type": "bool",
                "name": "kill_when_empty",
                "example": "0 [0, 1]",
                "description": "if set, will send MessageDeath when materials are drained"
            },
            {
                "type": "bool",
                "name": "halftime_materials",
                "example": "0 [0, 1]",
                "description": "if true, will multiply the materials with the given halftimes"
            },
            {
                "type": "int",
                "name": "do_reactions",
                "example": "0 [0, 100]",
                "description": "NOTE( Petri ): 15.8.2023 - if > 0, will do CellReactions between the materials. Value is the percent chance of how often. 100 = every frame "
            },
            {
                "type": "bool",
                "name": "do_reactions_explosions",
                "example": "0 [0, 1]",
                "description": "requires do_reactions > 0 - are we allowed to do reaction explosions?"
            },
            {
                "type": "bool",
                "name": "do_reactions_entities",
                "example": "0 [0, 1]",
                "description": "requires do_reactions > 0 - are we allowed to load entities when doing reactions?"
            },
            {
                "type": "int",
                "name": "reaction_speed",
                "example": "5 [0, 1]",
                "description": "Note( Petri ): 17.8.2023 - how 'fast' do we let reactions happen. How many pixels of material do we convert at one time (5-10) seems like a nice speed."
            },
            {
                "type": "bool",
                "name": "reactions_shaking_speeds_up",
                "example": "1 [0, 1]",
                "description": "Note( Petri ): 17.8.2023 - added the ability of shaking the bottle to cause reactions to happen quicker. "
            },
            {
                "type": "double",
                "name": "max_capacity",
                "example": "-1 [0, 1]",
                "description": "how much materials we can store in total. < 0 = infinite"
            },
            {
                "type": "float",
                "name": "audio_collision_size_modifier_amount",
                "example": "0 [0, 1]",
                "description": "if > 0, 'fullness of this container' * 'audio_collision_size_modifier_amount' is added to collision audio event size"
            },
            {
                "type": "int32",
                "name": "last_frame_drank",
                "example": "-100 [0, 1]",
                "description": "last frame someone ingested from this via IngestionSystem"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "is_death_handled",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "ex_position",
                "description": "used to figure out movement velocity"
            },
            {
                "type": "float",
                "name": "ex_angle",
                "example": "0 [0, 1]",
                "description": "used to figure out movement velocity"
            }
        ],
        "custom_data_types": [
            {
                "type": "MATERIAL_VEC_DOUBLES",
                "name": "count_per_material_type",
                "description": "Count of each material indexed by material type ID"
            }
        ]
    },
    {
        "name": "MaterialSeaSpawnerComponent",
        "members": [
            {
                "type": "int",
                "name": "speed",
                "example": "10 [1, 100]",
                "description": "How many pixels to cover per one direction per one frame"
            },
            {
                "type": "float",
                "name": "sine_wavelength",
                "example": "10 [0, 2]",
                "description": "Parameters for sine wave that affects material spawn pattern"
            },
            {
                "type": "float",
                "name": "sine_amplitude",
                "example": "5 [0, 2]",
                "description": "Parameters for sine wave that affects material spawn pattern"
            },
            {
                "type": "double",
                "name": "noise_scale",
                "example": "0.1 [0, 1]",
                "description": "Parameters for noise that affects material spawn pattern"
            },
            {
                "type": "double",
                "name": "noise_threshold",
                "example": "0.05 [0, 1]",
                "description": "Parameters for noise that affects material spawn pattern"
            },
            {
                "type": "int",
                "name": "m_position",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "frames_run",
                "example": "0 [0, 1]",
                "description": "to help keep the effect"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "material",
                "example": "0 [0, 1]",
                "description": "String name of material this creates"
            },
            {
                "type": "ivec2",
                "name": "size",
                "description": "Size of the area to cover"
            },
            {
                "type": "ivec2",
                "name": "offset",
                "description": "Offset of the center of the area to cover"
            }
        ]
    },
    {
        "name": "MaterialSuckerComponent",
        "members": [
            {
                "type": "int",
                "name": "material_type",
                "example": "0 [0, 3]",
                "description": "0 = liquid, 1 = sand, 2 = gas (arbitary order)"
            },
            {
                "type": "int",
                "name": "barrel_size",
                "example": "50 [0, 1024]",
                "description": "how many pixels can we suck up"
            },
            {
                "type": "int",
                "name": "num_cells_sucked_per_frame",
                "example": "1 [0, 5]",
                "description": "How many cells at max can we suck per frame?"
            },
            {
                "type": "bool",
                "name": "set_projectile_to_liquid",
                "example": "0 [0, 1]",
                "description": "if set, will set the projectile what ever we're sucking...?"
            },
            {
                "type": "int",
                "name": "last_material_id",
                "example": "0 [0, 1]",
                "description": "hax... this is set if we use set_projectile_to_liquid"
            },
            {
                "type": "bool",
                "name": "suck_gold",
                "example": "0 [0, 1]",
                "description": "if set will just suck gold and update wallet"
            },
            {
                "type": "bool",
                "name": "suck_health",
                "example": "0 [0, 1]",
                "description": "if set will just suck healthium material and add 1 hp every sucked healthium"
            },
            {
                "type": "bool",
                "name": "suck_static_materials",
                "example": "0 [0, 1]",
                "description": "will suck static materials from the world"
            },
            {
                "type": "std::string",
                "name": "suck_tag",
                "description": "if set, will only suck materials with this tag. NOTE, will also require the correct material_type to be set"
            },
            {
                "type": "int",
                "name": "mAmountUsed",
                "example": "0 [0, 1]",
                "description": "how full are we"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mGoldAccumulator",
                "example": "0 [0, 1]",
                "description": "accumulates amount of gold picked during consecutive frames"
            },
            {
                "type": "int",
                "name": "mLastFramePickedGold",
                "example": "-2 [0, 1]",
                "description": "last frame we picked gold"
            }
        ],
        "custom_data_types": [
            {
                "type": "types::iaabb",
                "name": "randomized_position",
                "description": "random offset for pos, where we look for pixels"
            }
        ]
    },
    {
        "name": "MoveToSurfaceOnCreateComponent",
        "members": [
            {
                "type": "float",
                "name": "lookup_radius",
                "example": "64 [0, 64]"
            },
            {
                "type": "float",
                "name": "offset_from_surface",
                "example": "2 [0, 10]"
            },
            {
                "type": "int",
                "name": "ray_count",
                "example": "4 [0, 8]"
            },
            {
                "type": "float",
                "name": "verlet_min_joint_distance",
                "example": "32 [0, 128]"
            }
        ],
        "custom_data_types": [
            {
                "type": "MOVETOSURFACE_TYPE::Enum",
                "name": "type"
            }
        ]
    },
    {
        "name": "MusicEnergyAffectorComponent",
        "members": [
            {
                "type": "float",
                "name": "energy_target",
                "example": "0.5 [0, 1]",
                "description": "the energy this makes music go towards"
            },
            {
                "type": "float",
                "name": "fade_range",
                "example": "0 [0, 256]",
                "description": "if > 0, fade between 0 and energy_target based on distance to this entity"
            },
            {
                "type": "bool",
                "name": "trigger_danger_music",
                "example": "1 [0, 1]",
                "description": "if 1, attempts to trigger danger music no matter what energy level is reached"
            },
            {
                "type": "int",
                "name": "fog_of_war_threshold",
                "example": "200 [0, 255]",
                "description": "if fog of war at position of this entity is greater than 'fog_of_war_threshold', this has  no effect"
            },
            {
                "type": "bool",
                "name": "is_enemy",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "energy_lerp_up_speed_multiplier",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "NinjaRopeComponent",
        "members": [
            {
                "type": "float",
                "name": "max_length",
                "example": "356 [0, 2000]"
            },
            {
                "type": "float",
                "name": "mLength",
                "example": "0 [0, 2000]"
            }
        ],
        "privates": [
            {
                "type": "NINJA_ROPE_SEGMENT_VECTOR",
                "name": "mSegments"
            }
        ]
    },
    {
        "name": "NullDamageComponent",
        "members": [
            {
                "type": "float",
                "name": "null_chance",
                "example": "1 [0, 1]",
                "description": "if less than 1, then will roll the die to see if it will NULL all damage. Stick this into your projectile entity"
            }
        ]
    },
    {
        "name": "OrbComponent",
        "members": [
            {
                "type": "int",
                "name": "orb_id",
                "example": "0 [0, 20]",
                "description": "must be unique for every orb in the world"
            }
        ]
    },
    {
        "name": "ParticleEmitterComponent",
        "members": [
            {
                "type": "std::string",
                "name": "emitted_material_name",
                "example": "blood [0, 1]"
            },
            {
                "type": "bool",
                "name": "create_real_particles",
                "example": "0 [0, 1]",
                "description": "used to be emit_real_particles - creates these particles in the grid, if that happens velocity and lifetime are ignored"
            },
            {
                "type": "bool",
                "name": "emit_real_particles",
                "example": "0 [0, 1]",
                "description": "this creates particles that will behave like particles, but work outside of the screen"
            },
            {
                "type": "bool",
                "name": "emit_cosmetic_particles",
                "example": "0 [0, 1]",
                "description": "particle does have collisions, but no other physical interactions with the world. the particles are culled outside camera region"
            },
            {
                "type": "bool",
                "name": "cosmetic_force_create",
                "example": "1 [0, 1]",
                "description": "cosmetic particles are created inside grid cells"
            },
            {
                "type": "bool",
                "name": "render_back",
                "example": "1 [0, 1]",
                "description": "for cosmetic particles, if they are rendered on front or in the back..."
            },
            {
                "type": "bool",
                "name": "render_ultrabright",
                "example": "0 [0, 1]",
                "description": "if 1, particles made of a glowing material will be 3x as bright as usually"
            },
            {
                "type": "bool",
                "name": "collide_with_grid",
                "example": "1 [0, 1]",
                "description": "for cosmetic particles, if 1 the particles collide with grid and only exist in screen space"
            },
            {
                "type": "bool",
                "name": "collide_with_gas_and_fire",
                "example": "1 [0, 1]",
                "description": "does it collide with gas and fire, works with create_real_particles and raytraced images "
            },
            {
                "type": "bool",
                "name": "particle_single_width",
                "example": "1 [0, 1]",
                "description": "for cosmetic particles, forces them (gas,fire) to be only 1 pixel wide "
            },
            {
                "type": "bool",
                "name": "emit_only_if_there_is_space",
                "example": "0 [0, 1]",
                "description": "This is turned for potions after they take some damage and start leaking"
            },
            {
                "type": "int",
                "name": "emitter_lifetime_frames",
                "example": "-1 [0, 1]",
                "description": "emitter lifetime in frames. -1 = infinite"
            },
            {
                "type": "bool",
                "name": "fire_cells_dont_ignite_damagemodel",
                "example": "0 [0, 1]",
                "description": "if set, and fire cells are created, this changes their default behaviour of igniting DamageModels"
            },
            {
                "type": "bool",
                "name": "color_is_based_on_pos",
                "example": "0 [0, 1]",
                "description": "if true, will get the particle color based on the world position (instead of randomizing it)"
            },
            {
                "type": "float",
                "name": "custom_alpha",
                "example": "-1 [0, 1]",
                "description": "if >= 0, will use this as particle alpha"
            },
            {
                "type": "float",
                "name": "x_pos_offset_min",
                "example": "0 [-20, 20]"
            },
            {
                "type": "float",
                "name": "y_pos_offset_min",
                "example": "0 [-20, 20]"
            },
            {
                "type": "float",
                "name": "x_pos_offset_max",
                "example": "0 [-20, 20]"
            },
            {
                "type": "float",
                "name": "y_pos_offset_max",
                "example": "0 [-20, 20]"
            },
            {
                "type": "float",
                "name": "area_circle_sector_degrees",
                "example": "360 [0, 360]"
            },
            {
                "type": "float",
                "name": "x_vel_min",
                "example": "0 [-100, 100]"
            },
            {
                "type": "float",
                "name": "x_vel_max",
                "example": "0 [-100, 100]"
            },
            {
                "type": "float",
                "name": "y_vel_min",
                "example": "0 [-100, 100]"
            },
            {
                "type": "float",
                "name": "y_vel_max",
                "example": "0 [-100, 100]"
            },
            {
                "type": "float",
                "name": "direction_random_deg",
                "example": "0 [0, 90]"
            },
            {
                "type": "float",
                "name": "velocity_always_away_from_center",
                "example": "0 [-256, 256]",
                "description": "if set, will make the velocity's rotation always away from center of randomized aabb"
            },
            {
                "type": "float",
                "name": "lifetime_min",
                "example": "5 [0, 10]"
            },
            {
                "type": "float",
                "name": "lifetime_max",
                "example": "10 [0, 10]"
            },
            {
                "type": "float",
                "name": "airflow_force",
                "example": "0 [0, 6]"
            },
            {
                "type": "float",
                "name": "airflow_time",
                "example": "1 [0, 2]"
            },
            {
                "type": "float",
                "name": "airflow_scale",
                "example": "1 [0, 2]"
            },
            {
                "type": "float",
                "name": "friction",
                "example": "0 [0, 10]"
            },
            {
                "type": "float",
                "name": "attractor_force",
                "example": "0 [0, 100]",
                "description": "If > 0, an attractor is created at the position of the entity that owns this component"
            },
            {
                "type": "int",
                "name": "emission_interval_min_frames",
                "example": "5 [0, 120]"
            },
            {
                "type": "int",
                "name": "emission_interval_max_frames",
                "example": "10 [0, 120]"
            },
            {
                "type": "int",
                "name": "emission_chance",
                "example": "100 [0, 100]"
            },
            {
                "type": "int",
                "name": "delay_frames",
                "example": "0 [0, 1]",
                "description": "if set will delay this many frames until starts"
            },
            {
                "type": "bool",
                "name": "is_emitting",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "use_material_inventory",
                "example": "0 [0, 1]",
                "description": "if set, it'll use MaterialInventoryComponent as the source of the particles emitted"
            },
            {
                "type": "bool",
                "name": "is_trail",
                "example": "0 [0, 1]",
                "description": "if set, will do a trail based on the previous position and current position"
            },
            {
                "type": "float",
                "name": "trail_gap",
                "example": "0 [0, 1]",
                "description": "if > 0, trail particles will be generated this far from each other between our old and new position, else [count_min-count_max] particles will be generated on the line"
            },
            {
                "type": "bool",
                "name": "render_on_grid",
                "example": "0 [0, 1]",
                "description": "if set, particle render positions will be snapped to cell grid"
            },
            {
                "type": "bool",
                "name": "fade_based_on_lifetime",
                "example": "0 [0, 1]",
                "description": "if set, particle's position in its lifetime will determine the rendering alpha"
            },
            {
                "type": "bool",
                "name": "draw_as_long",
                "example": "0 [0, 1]",
                "description": "if set, particle will rendered as a trail along it's movement vector"
            },
            {
                "type": "float",
                "name": "b2_force",
                "example": "0 [0, 10]",
                "description": "if 0 nothing happens, if 1 will apply a force to the physics body (if has one), also requires that we use the material inventory"
            },
            {
                "type": "bool",
                "name": "set_magic_creation",
                "example": "0 [0, 1]",
                "description": "if set will set the magic creation 1 in the cells and do the white glow effect"
            },
            {
                "type": "std::string",
                "name": "image_animation_file",
                "description": "file to use for image-based animation"
            },
            {
                "type": "std::string",
                "name": "image_animation_colors_file",
                "description": "file to use for image-based animation"
            },
            {
                "type": "float",
                "name": "image_animation_speed",
                "example": "1 [0, 255]",
                "description": "how long do we stay on one frame of image-based animation. 0.5 means two game frames per one animation frame. 2.0 means two animation frames per one game frame, and so on. 0 means we always emit at time 0 of the animation."
            },
            {
                "type": "bool",
                "name": "image_animation_loop",
                "example": "1 [0, 1]",
                "description": "does image-based animation keep looping while this component is active?"
            },
            {
                "type": "float",
                "name": "image_animation_phase",
                "example": "0 [0, 1]",
                "description": "the point in time [0,1] where the image-based animation will start the first cycle"
            },
            {
                "type": "float",
                "name": "image_animation_emission_probability",
                "example": "1 [0, 1]",
                "description": "[0,1], probability of emitting image based particles is multiplied with this"
            },
            {
                "type": "bool",
                "name": "image_animation_raytrace_from_center",
                "example": "0 [0, 1]",
                "description": "enable this to disable image_animations (from the center) going through the world"
            },
            {
                "type": "bool",
                "name": "image_animation_use_entity_rotation",
                "example": "0 [0, 1]",
                "description": "if 1, image animation emission will be rotated based on entity rotation"
            },
            {
                "type": "bool",
                "name": "ignore_transform_updated_msg",
                "example": "0 [0, 1]",
                "description": "if 1, mExPosition and m_last_emit_position will not be updated when receiving Message_TransformUpdated"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mExPosition",
                "description": "is used with is_trail"
            },
            {
                "type": "int",
                "name": "mMaterialInventoryMax",
                "example": "1024 [0, 1]",
                "description": "this is how we figure out the pressure, when using material_inventory"
            },
            {
                "type": "LensValue<int>",
                "name": "m_material_id"
            },
            {
                "type": "int",
                "name": "m_next_emit_frame",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "m_has_emitted",
                "example": "0 [0, 1]"
            },
            {
                "type": "ivec2",
                "name": "m_last_emit_position"
            },
            {
                "type": "ParticleEmitter_Animation*",
                "name": "m_cached_image_animation"
            },
            {
                "type": "float",
                "name": "m_image_based_animation_time",
                "example": "0 [0, 1]"
            },
            {
                "type": "float*",
                "name": "m_collision_angles"
            },
            {
                "type": "int16",
                "name": "m_particle_attractor_id",
                "example": "-1 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "uint32",
                "name": "color",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "offset"
            },
            {
                "type": "ValueRange",
                "name": "area_circle_radius",
                "description": "If > 0, the particles will be emitted inside a circular area defined by the min and max bounds of 'area_circle_radius'."
            },
            {
                "type": "vec2",
                "name": "gravity"
            },
            {
                "type": "LensValue<int>",
                "name": "count_min"
            },
            {
                "type": "LensValue<int>",
                "name": "count_max"
            },
            {
                "type": "PARTICLE_EMITTER_CUSTOM_STYLE::Enum",
                "name": "custom_style",
                "description": "NONE or FIRE"
            }
        ]
    },
    {
        "name": "PathFindingComponent",
        "members": [
            {
                "type": "int",
                "name": "search_depth_max_no_goal",
                "example": "20 [0, 1e+006]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "iterations_max_no_goal",
                "example": "1500 [0, 1e+006]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "search_depth_max_with_goal",
                "example": "2500 [0, 1e+006]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "iterations_max_with_goal",
                "example": "1500 [0, 1e+006]",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "cost_of_flying",
                "example": "20 [0, 100000]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "distance_to_reach_node_x",
                "example": "2 [0, 200]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "distance_to_reach_node_y",
                "example": "6 [0, 200]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "frames_to_get_stuck",
                "example": "60 [0, 600]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "frames_between_searches",
                "example": "30 [0, 300]",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "y_walking_compensation",
                "example": "0 [-100, 100]",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "can_fly",
                "example": "1 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "can_walk",
                "example": "1 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "can_jump",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "can_dive",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "can_swim_on_surface",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "never_consider_line_of_sight",
                "example": "0 [0, 1]",
                "description": "if 1, we require a path to have an entity at the goal, having line of sight to the entity is not enough"
            },
            {
                "type": "float",
                "name": "space_required",
                "example": "0 [0, 20]",
                "description": "how far (in cells) must a point on our route be from the nearest wall to consider it passable?"
            },
            {
                "type": "float",
                "name": "max_jump_distance_from_camera",
                "example": "400 [0, 400]",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "jump_speed",
                "example": "200 [0, 1000]",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "initial_jump_lob",
                "example": "1 [0, 5]",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "initial_jump_max_distance_x",
                "example": "100 [0, 1000]",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "initial_jump_max_distance_y",
                "example": "80 [0, 1000]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "read_state",
                "example": "0 [0, 1]",
                "description": "Read only value to get mState as an integer. Used to detect when the worst cheesers are trying to cheese our beloved squidward."
            }
        ],
        "privates": [
            {
                "type": "PathFindingInput",
                "name": "input",
                "description": "TODO: Comment"
            },
            {
                "type": "MSG_QUEUE_PATH_FINDING_RESULT",
                "name": "job_result_receiver",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "waiting_for",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "next_search_frame",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "VECTOR_PATHNODE",
                "name": "path",
                "description": "TODO: Comment"
            },
            {
                "type": "PathFindingResultNode",
                "name": "path_next_node",
                "description": "TODO: Comment"
            },
            {
                "type": "vec2",
                "name": "path_next_node_vector_to",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "path_next_node_distance_to",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "PathFindingNodeHandle",
                "name": "path_previous_node",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "path_frames_stuck",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "path_is_stuck",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "path_last_frame_with_job",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "PathFindingLogic*",
                "name": "mLogic",
                "description": "this defines what is an acceptable path"
            },
            {
                "type": "PathFindingLogic*",
                "name": "mFallbackLogic",
                "description": "we use this to define an acceptable path if mLogic doesn't return one"
            },
            {
                "type": "PathFindingLogic*",
                "name": "mSelectedLogic",
                "description": "TODO: Comment"
            },
            {
                "type": "bool",
                "name": "mEnabled",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "PathFindingComponentState::Enum",
                "name": "mState",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "mTimesStuck",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "int",
                "name": "mNextClearDontApproachListFrame",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "float",
                "name": "mNodeProximityCheckCorrectionY",
                "example": "0 [0, 1]",
                "description": "TODO: Comment"
            },
            {
                "type": "VECTOR_PATHNODE",
                "name": "debug_path",
                "description": "TODO: Comment"
            },
            {
                "type": "LensValue<float>",
                "name": "jump_velocity_multiplier",
                "description": "TODO: Comment"
            }
        ],
        "custom_data_types": [
            {
                "type": "VECTOR_JUMPPARAMS",
                "name": "jump_trajectories",
                "description": "TODO: Comment"
            }
        ]
    },
    {
        "name": "PathFindingGridMarkerComponent",
        "members": [
            {
                "type": "int",
                "name": "marker_work_flag",
                "example": "0 [0, 255]"
            },
            {
                "type": "float",
                "name": "marker_offset_x",
                "example": "0 [-1000, 1000]"
            },
            {
                "type": "float",
                "name": "marker_offset_y",
                "example": "0 [-1000, 1000]"
            },
            {
                "type": "float",
                "name": "player_marker_radius",
                "example": "0 [0, 128]"
            }
        ],
        "privates": [
            {
                "type": "PathFindingNodeHandle",
                "name": "mNode",
                "description": "we change the work state of this node. thus we need to keep a reference to it"
            }
        ]
    },
    {
        "name": "PhysicsAIComponent",
        "members": [
            {
                "type": "float",
                "name": "target_vec_max_len",
                "example": "5 [0, 1]"
            },
            {
                "type": "float",
                "name": "force_coeff",
                "example": "30 [0, 1]"
            },
            {
                "type": "float",
                "name": "force_balancing_coeff",
                "example": "1.5 [0, 1]"
            },
            {
                "type": "float",
                "name": "force_max",
                "example": "100 [0, 1]"
            },
            {
                "type": "float",
                "name": "torque_coeff",
                "example": "50 [0, 1]"
            },
            {
                "type": "float",
                "name": "torque_balancing_coeff",
                "example": "0.2 [0, 1]"
            },
            {
                "type": "float",
                "name": "torque_max",
                "example": "50 [0, 1]"
            },
            {
                "type": "float",
                "name": "torque_damaged_max",
                "example": "100 [0, 1]"
            },
            {
                "type": "float",
                "name": "torque_jump_random",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "damage_deactivation_probability",
                "example": "80 [0, 1]"
            },
            {
                "type": "int",
                "name": "damage_deactivation_time_min",
                "example": "30 [0, 1]"
            },
            {
                "type": "int",
                "name": "damage_deactivation_time_max",
                "example": "60 [0, 1]"
            },
            {
                "type": "float",
                "name": "die_on_remaining_mass_percentage",
                "example": "0.3 [0, 1]"
            },
            {
                "type": "bool",
                "name": "levitate",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "v0_jump_logic",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "v0_swim_logic",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "v0_body_id_logic",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "swim_check_y_min",
                "example": "-2 [0, 1]"
            },
            {
                "type": "int",
                "name": "swim_check_y_max",
                "example": "2 [0, 1]"
            },
            {
                "type": "int",
                "name": "swim_check_side_x",
                "example": "4 [0, 1]"
            },
            {
                "type": "int",
                "name": "swim_check_side_y",
                "example": "-2 [0, 1]"
            },
            {
                "type": "bool",
                "name": "keep_inside_world",
                "example": "1 [0, 1]",
                "description": "fix to the bug in which the spiders spawned inside the holy mountain, if set will try not to go into places which aren't loaded "
            },
            {
                "type": "bool",
                "name": "free_if_static",
                "example": "0 [0, 1]",
                "description": "set true for the boss, because box2d might turn this body into a static body, if it thinks it's glitching out. "
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "rotation_speed",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mStartingMass",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mMainBodyFound",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextFrameActive",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mRotationTarget",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mLastPositionWhenHadPath"
            },
            {
                "type": "bool",
                "name": "mHasLastPosition",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "PhysicsBody2Component",
        "members": [
            {
                "type": "b2ObjectID",
                "name": "mBodyId",
                "example": "0 [0, 1]",
                "description": "this is mBody->GetBodyId() - not to be confused with uid, has to be tracked separately, since the mBody pointer is not unique"
            },
            {
                "type": "float",
                "name": "linear_damping",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "angular_damping",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "allow_sleep",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "fixed_rotation",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_bullet",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_static",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "buoyancy",
                "example": "0.7 [0, 1]"
            },
            {
                "type": "bool",
                "name": "hax_fix_going_through_ground",
                "example": "0 [0, 1]",
                "description": "if 1, will lift the body upwards if it is inside ground"
            },
            {
                "type": "bool",
                "name": "hax_fix_going_through_sand",
                "example": "0 [0, 1]",
                "description": "hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand"
            },
            {
                "type": "bool",
                "name": "hax_wait_till_pixel_scenes_loaded",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "go_through_sand",
                "example": "0 [0, 1]",
                "description": "if 1, will go through sand PhysicsBridge::mGoThroughSand = 1"
            },
            {
                "type": "bool",
                "name": "auto_clean",
                "example": "1 [0, 1]",
                "description": "if 1, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that"
            },
            {
                "type": "bool",
                "name": "force_add_update_areas",
                "example": "1 [0, 1]",
                "description": "if 1, we will mark our predicted aabb as a box2d update area."
            },
            {
                "type": "bool",
                "name": "update_entity_transform",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "kill_entity_if_body_destroyed",
                "example": "1 [0, 1]",
                "description": "if 1, will kill the entity when physics body is destroyed"
            },
            {
                "type": "bool",
                "name": "kill_entity_after_initialized",
                "example": "0 [0, 1]",
                "description": "if 1, will destroy the entity after initialization has been done based the entity's PhysicsBodyComponents and JointComponents"
            },
            {
                "type": "bool",
                "name": "manual_init",
                "example": "0 [0, 1]",
                "description": "if 1, initialization occurs only when done via for example lua component and Physic2InitFromComponents()"
            },
            {
                "type": "bool",
                "name": "destroy_body_if_entity_destroyed",
                "example": "0 [0, 1]",
                "description": "if 1, root body is destroyed if the entity is destroyed"
            },
            {
                "type": "float",
                "name": "root_offset_x",
                "example": "0 [0, 1]",
                "description": "TODO"
            },
            {
                "type": "float",
                "name": "root_offset_y",
                "example": "0 [0, 1]",
                "description": "TODO"
            },
            {
                "type": "float",
                "name": "init_offset_x",
                "example": "0 [0, 1]",
                "description": "TODO"
            },
            {
                "type": "float",
                "name": "init_offset_y",
                "example": "0 [0, 1]",
                "description": "TODO"
            },
            {
                "type": "bool",
                "name": "mActiveState",
                "example": "0 [0, 1]",
                "description": "private variable, please don't mess around with this"
            },
            {
                "type": "uint32",
                "name": "mPixelCountOrig",
                "example": "0 [0, 1]",
                "description": "the number of pixels the body had when it was originally created"
            }
        ],
        "privates": [
            {
                "type": "b2Body*",
                "name": "mBody"
            },
            {
                "type": "bool",
                "name": "mInitialized",
                "example": "0 [0, 1]",
                "description": "private variable, please don't mess around with this"
            },
            {
                "type": "uint32",
                "name": "mPixelCount",
                "example": "0 [0, 1]",
                "description": "if set, tracks the number of csolidcells the body has"
            },
            {
                "type": "bool",
                "name": "mRefreshed",
                "example": "0 [0, 1]",
                "description": "this is sure the bodies are only parsed once"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "mLocalPosition",
                "description": "private variable, please don't mess around with this"
            }
        ]
    },
    {
        "name": "PhysicsBodyCollisionDamageComponent",
        "members": [
            {
                "type": "float",
                "name": "speed_threshold",
                "example": "60 [0, 100]"
            },
            {
                "type": "float",
                "name": "damage_multiplier",
                "example": "0.016667 [0, 1]"
            }
        ]
    },
    {
        "name": "PhysicsBodyComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_external",
                "example": "0 [0, 1]",
                "description": "if mBody is set from outside, will ignore all the things"
            },
            {
                "type": "bool",
                "name": "hax_fix_going_through_ground",
                "example": "0 [0, 1]",
                "description": "if set will lift the body upwards if it is inside ground"
            },
            {
                "type": "bool",
                "name": "hax_fix_going_through_sand",
                "example": "0 [0, 1]",
                "description": "hax_fix_going_through_ground has to be set, if set will lift the body upwards if it is inside sand"
            },
            {
                "type": "bool",
                "name": "hax_wait_till_pixel_scenes_loaded",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "uid",
                "example": "0 [0, 1000]",
                "description": "if the entity has multiple physics bodies and has specific shapes for those and possible joints, you should use this. 0 is default for shapes"
            },
            {
                "type": "bool",
                "name": "is_enabled",
                "example": "1 [0, 1]",
                "description": "Use this to kill the physics body of. if is_enabled is set to false, will destroy the physics body"
            },
            {
                "type": "float",
                "name": "linear_damping",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "angular_damping",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "allow_sleep",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "fixed_rotation",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "buoyancy",
                "example": "0.7 [0, 1]"
            },
            {
                "type": "float",
                "name": "gravity_scale_if_has_no_image_shapes",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_bullet",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_static",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_kinematic",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_character",
                "example": "0 [0, 1]",
                "description": "if it is a character, then we need to few interesting things from time to time"
            },
            {
                "type": "bool",
                "name": "go_through_sand",
                "example": "0 [0, 1]",
                "description": "if set, will go through sand PhysicsBridge::mGoThroughSand = 1"
            },
            {
                "type": "bool",
                "name": "gridworld_box2d",
                "example": "1 [0, 1]",
                "description": "default is 1. You should only change this if you know the body isn't going to touch gridworld"
            },
            {
                "type": "bool",
                "name": "auto_clean",
                "example": "1 [0, 1]",
                "description": "if set, the simulation might destroy this body if it's hidden under sand. Problematic if you have a small piece with joint attached to something like the wheels of minecart. Set to 0 in cases like that"
            },
            {
                "type": "bool",
                "name": "on_death_leave_physics_body",
                "example": "0 [0, 1]",
                "description": "if set, will leave the b2body into the world, even if the entity is killed"
            },
            {
                "type": "bool",
                "name": "on_death_really_leave_body",
                "example": "0 [0, 1]",
                "description": "camera bound... god damn... we need something special when we want to leave the body"
            },
            {
                "type": "bool",
                "name": "update_entity_transform",
                "example": "1 [0, 1]",
                "description": "WARNING! Don't touch this unless you know what you're doing. If false, doesn't update the entitys transform to match the physics body. This is used with multi body entities, to use the correct body to update the entity, e.g. minecart"
            },
            {
                "type": "bool",
                "name": "force_add_update_areas",
                "example": "0 [0, 1]",
                "description": "if 1, we will mark our predicted aabb as a box2d update area."
            },
            {
                "type": "bool",
                "name": "kills_entity",
                "example": "1 [0, 1]",
                "description": "if set, will kill the entity when physics body is destroyed"
            },
            {
                "type": "bool",
                "name": "projectiles_rotate_toward_velocity",
                "example": "0 [0, 1]",
                "description": "for physics projectiles, if true will initially rotate the body based on the velocity"
            },
            {
                "type": "bool",
                "name": "randomize_init_velocity",
                "example": "0 [0, 1]",
                "description": "randomizes the init velocity"
            },
            {
                "type": "bool",
                "name": "mActiveState",
                "example": "0 [0, 1]",
                "description": "private variable, please don't mess around with this"
            }
        ],
        "privates": [
            {
                "type": "b2Body*",
                "name": "mBody"
            },
            {
                "type": "b2ObjectID",
                "name": "mBodyId",
                "example": "0 [0, 1]",
                "description": "this is mBody->GetBodyId() - not to be confused with uid shit, has to be tracked separately, since the mBody pointer is not unique"
            },
            {
                "type": "int",
                "name": "mPixelCount",
                "example": "0 [0, 1]",
                "description": "if set, tracks the number of csolidcells the body has"
            },
            {
                "type": "b2Vec2",
                "name": "mLocalPosition"
            },
            {
                "type": "bool",
                "name": "mRefreshed",
                "example": "0 [0, 1]",
                "description": "this is sure the bodies are only parsed once"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "initial_velocity",
                "description": "if you want a velocity at the start, set it here"
            }
        ]
    },
    {
        "name": "PhysicsImageShapeComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_root",
                "example": "0 [0, 1]",
                "description": "if 1, PhysicsBody2Component will use this to figure out where the entity is located"
            },
            {
                "type": "int",
                "name": "body_id",
                "example": "0 [0, 1000]",
                "description": "used to figure out which bodies are attached to each other when creating joints"
            },
            {
                "type": "bool",
                "name": "use_sprite",
                "example": "0 [0, 1]",
                "description": "will try to find the SpriteComponent and use that"
            },
            {
                "type": "bool",
                "name": "is_circle",
                "example": "0 [0, 1]",
                "description": "tries to fit this into a circle, looks at bounding box of the pixels and sets the circle to the center of that with radius being the line from there to a straight edge"
            },
            {
                "type": "bool",
                "name": "centered",
                "example": "0 [0, 1]",
                "description": "if this is true, moves offset to be in the center of the image, overwrites the offset_x, offset_y"
            },
            {
                "type": "float",
                "name": "offset_x",
                "example": "0 [0, 1]",
                "description": "offset x in pixels"
            },
            {
                "type": "float",
                "name": "offset_y",
                "example": "0 [0, 1]",
                "description": "offset y in pixels"
            },
            {
                "type": "float",
                "name": "z",
                "example": "0 [0, 1]",
                "description": "offset in the z direction"
            },
            {
                "type": "std::string",
                "name": "image_file",
                "description": "the png file from which the body is created from"
            }
        ],
        "privates": [
            {
                "type": "b2Body*",
                "name": "mBody",
                "description": "used in joint creation phase"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "material",
                "example": "0 [0, 1]",
                "description": "the material from which the body is created"
            }
        ]
    },
    {
        "name": "PhysicsJoint2Component",
        "members": [
            {
                "type": "uint16",
                "name": "joint_id",
                "example": "0 [0, 1000]",
                "description": "Use this to create a relation between PhysicsJointMutator and a joint. The PhysicsJointMutator must exist when the physics objects are initialized for the first time. This id should be unique inside one entity. Defaults to 0"
            },
            {
                "type": "float",
                "name": "break_force",
                "example": "1.3 [0, 1]",
                "description": "if > 0, will break if theres a force too strong."
            },
            {
                "type": "float",
                "name": "break_distance",
                "example": "1.4142 [0, 1]",
                "description": "if > 0, will break if the anchors on the bodies get further than this."
            },
            {
                "type": "bool",
                "name": "break_on_body_modified",
                "example": "0 [0, 1]",
                "description": "if > 1, will break if an attached body is modified"
            },
            {
                "type": "float",
                "name": "break_on_shear_angle_deg",
                "example": "0 [0, 1]",
                "description": "if > 0, will break if the angle between the linked bodies becomes greater than this"
            },
            {
                "type": "int",
                "name": "body1_id",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "body2_id",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "offset_x",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "offset_y",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "ray_x",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "ray_y",
                "example": "-10 [0, 1]"
            },
            {
                "type": "float",
                "name": "surface_attachment_offset_x",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "surface_attachment_offset_y",
                "example": "2.5 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "JOINT_TYPE::Enum",
                "name": "type",
                "description": "Enum - REVOLUTE_JOINT, WELD_JOINT, REVOLUTE_JOINT_ATTACH_TO_NEARBY_SURFACE or WELD_JOINT_ATTACH_TO_NEARBY_SURFACE"
            }
        ]
    },
    {
        "name": "PhysicsJoint2MutatorComponent",
        "members": [
            {
                "type": "uint16",
                "name": "joint_id",
                "example": "0 [0, 1000]",
                "description": "Use this to create a relation between PhysicsJointMutator and a joint created by PhysicsJoint2Component. The PhysicsJoint2Mutator must exist when the physics objects are initialized for the first time."
            },
            {
                "type": "bool",
                "name": "destroy",
                "example": "0 [0, 1]",
                "description": "if 1, the joint will break and this component will be destroyed."
            },
            {
                "type": "float",
                "name": "motor_speed",
                "example": "0 [0, 1]",
                "description": "if != 0 and this is linked to a revolute joint, the joint motor will be enabled at this speed"
            },
            {
                "type": "float",
                "name": "motor_max_torque",
                "example": "1 [0, 1]",
                "description": "max torque for motor"
            },
            {
                "type": "uint64",
                "name": "mBox2DJointId",
                "example": "0 [0, 1]",
                "description": "Private, don't touch this! Stores the joint's id in the physics engine."
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "mPreviousMotorSpeed",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mPreviousMotorMaxTorque",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "PhysicsJointComponent",
        "members": [
            {
                "type": "bool",
                "name": "nail_to_wall",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "grid_joint",
                "example": "0 [0, 1]",
                "description": "if 1, will do a grid joint that works correctly with a body when it is destroyed / chipped away"
            },
            {
                "type": "bool",
                "name": "breakable",
                "example": "0 [0, 1]",
                "description": "if 1, will break if theres a force too strong"
            },
            {
                "type": "int",
                "name": "body1_id",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "body2_id",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "pos_x",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "pos_y",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "delta_x",
                "example": "0 [-10, 10]",
                "description": "For mouse joint only ... moves the mouse joint by *dt "
            },
            {
                "type": "float",
                "name": "delta_y",
                "example": "0 [-10, 10]",
                "description": "For mouse joint only ... moves the mouse joint by *dt "
            },
            {
                "type": "bool",
                "name": "mMotorEnabled",
                "example": "0 [0, 1]",
                "description": "enable motor, by setting this to true"
            },
            {
                "type": "float",
                "name": "mMotorSpeed",
                "example": "0 [0, 20]",
                "description": "if enabled this gets set to speed"
            },
            {
                "type": "float",
                "name": "mMaxMotorTorque",
                "example": "1 [0, 1]",
                "description": "max torque for motor"
            }
        ],
        "privates": [
            {
                "type": "b2Joint*",
                "name": "mJoint"
            }
        ],
        "custom_data_types": [
            {
                "type": "JOINT_TYPE::Enum",
                "name": "type",
                "description": "Enum - JOINT_TYPE"
            }
        ]
    },
    {
        "name": "PhysicsKeepInWorldComponent",
        "members": [
            {
                "type": "bool",
                "name": "check_whole_aabb",
                "example": "0 [0, 1]",
                "description": "All that is needed is to include one of the components with PhysicsBodyComponent or PhysicsBody2Component and it will be frozen when it hits outer edges of the world. NOTE! This will override the auto_clean variable, auto_clean will be set to false. If this is true, will check all the 4 corners of the bounding box"
            },
            {
                "type": "bool",
                "name": "predict_aabb",
                "example": "0 [0, 1]",
                "description": "Will add the velocity * 1.5 to the aabb to predict where the body will end up at. This will greatly help keep the body inside simulated world."
            },
            {
                "type": "bool",
                "name": "keep_at_last_valid_pos",
                "example": "0 [0, 1]",
                "description": "Will try to keep the object at the latest valid position"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mExPosition"
            },
            {
                "type": "float",
                "name": "mExRotation",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "PhysicsPickUpComponent",
        "members": [
            {
                "type": "float",
                "name": "pick_up_strength",
                "example": "200 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "isBroken",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "leftJointPos"
            },
            {
                "type": "vec2",
                "name": "rightJointPos"
            },
            {
                "type": "b2WeldJoint*",
                "name": "leftJoint"
            },
            {
                "type": "b2WeldJoint*",
                "name": "rightJoint"
            }
        ],
        "custom_data_types": [
            {
                "type": "types::xform",
                "name": "transform"
            },
            {
                "type": "vec2",
                "name": "original_left_joint_pos"
            },
            {
                "type": "vec2",
                "name": "original_right_joint_pos"
            }
        ]
    },
    {
        "name": "PhysicsRagdollComponent",
        "members": [
            {
                "type": "std::string",
                "name": "filename",
                "description": "file that should include just a list of other files, that have all the parts"
            },
            {
                "type": "std::string",
                "name": "filenames",
                "description": "a list of body parts as png images, separate the files by ','. e.g. 'data/temp/ragdoll/leg.png, data/temp/ragdoll/head.png,...'"
            },
            {
                "type": "float",
                "name": "offset_x",
                "example": "0 [0, 20]",
                "description": "offset of where the ragdoll will be created"
            },
            {
                "type": "float",
                "name": "offset_y",
                "example": "0 [0, 20]",
                "description": "offset of where the ragdoll will be created"
            }
        ],
        "privates": [
            {
                "type": "std::vector<b2Body*>*",
                "name": "bodies"
            }
        ]
    },
    {
        "name": "PhysicsShapeComponent",
        "members": [
            {
                "type": "bool",
                "name": "recreate",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_circle",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_box",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_capsule",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_based_on_sprite",
                "example": "0 [0, 1]",
                "description": "if set, will use sprite component to figure out a box that fits this"
            },
            {
                "type": "float",
                "name": "friction",
                "example": "0.75 [0, 1]"
            },
            {
                "type": "float",
                "name": "restitution",
                "example": "0.1 [0, 1]"
            },
            {
                "type": "float",
                "name": "density",
                "example": "0.75 [0, 5]"
            },
            {
                "type": "float",
                "name": "local_position_x",
                "example": "0 [-5, 5]"
            },
            {
                "type": "float",
                "name": "local_position_y",
                "example": "0 [-5, 5]"
            },
            {
                "type": "float",
                "name": "radius_x",
                "example": "1 [0, 10]"
            },
            {
                "type": "float",
                "name": "radius_y",
                "example": "1 [0, 10]"
            },
            {
                "type": "float",
                "name": "capsule_x_percent",
                "example": "0.25 [0, 1]"
            },
            {
                "type": "float",
                "name": "capsule_y_percent",
                "example": "0.3 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "material",
                "example": "0 [0, 1]",
                "description": "the material to use for collision audio"
            }
        ]
    },
    {
        "name": "PhysicsThrowableComponent",
        "members": [
            {
                "type": "float",
                "name": "throw_force_coeff",
                "example": "1 [0, 2]"
            },
            {
                "type": "float",
                "name": "max_throw_speed",
                "example": "180 [0, 256]"
            },
            {
                "type": "float",
                "name": "min_torque",
                "example": "0.5 [0, 20]"
            },
            {
                "type": "float",
                "name": "max_torque",
                "example": "8 [0, 20]"
            },
            {
                "type": "float",
                "name": "tip_check_offset_min",
                "example": "3 [0, 20]"
            },
            {
                "type": "float",
                "name": "tip_check_offset_max",
                "example": "5 [0, 20]"
            },
            {
                "type": "float",
                "name": "tip_check_random_rotation_deg",
                "example": "9 [0, 180]"
            },
            {
                "type": "float",
                "name": "attach_min_speed",
                "example": "70 [0, 180]"
            },
            {
                "type": "bool",
                "name": "attach_to_surfaces_knife_style",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "hp",
                "example": "100 [0, 200]",
                "description": "WIP WIP"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mHasJoint",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "PixelSceneComponent",
        "members": [
            {
                "type": "std::string",
                "name": "pixel_scene",
                "description": "loads this pixel scene file"
            },
            {
                "type": "std::string",
                "name": "pixel_scene_visual",
                "description": "this is the colors that get used for the pixels, if empty will use material colors"
            },
            {
                "type": "std::string",
                "name": "pixel_scene_background",
                "description": "this is the background file that gets loaded, if empty won't do anything"
            },
            {
                "type": "int",
                "name": "background_z_index",
                "example": "50 [0, 1]",
                "description": "the standard z_index of pixel scene backgrounds"
            },
            {
                "type": "float",
                "name": "offset_x",
                "example": "0 [-30, 30]",
                "description": "how much off from the entity x,y will this be. Top left corner is where it loads the pixel scene"
            },
            {
                "type": "float",
                "name": "offset_y",
                "example": "0 [-30, 30]"
            },
            {
                "type": "bool",
                "name": "skip_biome_checks",
                "example": "0 [0, 1]",
                "description": "biome check is on by default - it will check that pixel scene is loaded so that every corner is in the same biome"
            },
            {
                "type": "bool",
                "name": "skip_edge_textures",
                "example": "0 [0, 1]",
                "description": "if on - won't do the edge textures for the pixel scene"
            }
        ]
    },
    {
        "name": "PixelSpriteComponent",
        "members": [
            {
                "type": "std::string",
                "name": "image_file",
                "description": "loads pixelsprite based on this file"
            },
            {
                "type": "int",
                "name": "anchor_x",
                "example": "0 [0, 3.5]",
                "description": "the anchor and center_offset"
            },
            {
                "type": "int",
                "name": "anchor_y",
                "example": "0 [0, 3.5]",
                "description": "the anchor and center_offset"
            },
            {
                "type": "std::string",
                "name": "material",
                "example": "wood_loose [0, 1]",
                "description": "what's the material that things are made out of, TODO - change this into MetaCustom"
            },
            {
                "type": "bool",
                "name": "diggable",
                "example": "1 [0, 1]",
                "description": "if 1, this can be broken with digger"
            },
            {
                "type": "bool",
                "name": "clean_overlapping_pixels",
                "example": "1 [0, 1]",
                "description": "cleans up the pixels that are ovelapping in the world"
            },
            {
                "type": "bool",
                "name": "kill_when_sprite_dies",
                "example": "1 [0, 1]",
                "description": "kills the entity, if the pixel sprite is dead (empty)"
            },
            {
                "type": "bool",
                "name": "create_box2d_bodies",
                "example": "0 [0, 1]",
                "description": "if true, will create new pixel sprites with box2d bodies, instead of gridworld cells"
            }
        ],
        "custom_data_types": [
            {
                "type": "PixelSprite*",
                "name": "mPixelSprite"
            }
        ]
    },
    {
        "name": "PlatformShooterPlayerComponent",
        "members": [
            {
                "type": "float",
                "name": "aiming_reticle_distance_from_character",
                "example": "40 [0, 1000]"
            },
            {
                "type": "float",
                "name": "camera_max_distance_from_character",
                "example": "25 [0, 1000]"
            },
            {
                "type": "float",
                "name": "alcohol_drunken_speed",
                "example": "0.005 [0, 1000]"
            },
            {
                "type": "float",
                "name": "blood_fungi_drunken_speed",
                "example": "0.006 [0, 1000]"
            },
            {
                "type": "float",
                "name": "blood_worm_drunken_speed",
                "example": "0.006 [0, 1000]"
            },
            {
                "type": "int",
                "name": "eating_cells_per_frame",
                "example": "1 [0, 100]"
            },
            {
                "type": "int",
                "name": "eating_probability",
                "example": "5 [0, 100]"
            },
            {
                "type": "int",
                "name": "eating_delay_frames",
                "example": "30 [0, 100]"
            },
            {
                "type": "float",
                "name": "stoned_speed",
                "example": "0.1 [0, 1000]"
            },
            {
                "type": "bool",
                "name": "center_camera_on_this_entity",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "move_camera_with_aim",
                "example": "1 [0, 1]",
                "description": "if true, moves camera with the aim."
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mSmoothedCameraPosition"
            },
            {
                "type": "vec2",
                "name": "mSmoothedAimingVector"
            },
            {
                "type": "float",
                "name": "mCameraRecoil",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mCameraRecoilTarget",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mCrouching",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mCameraDistanceLerped",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mRequireTriggerPull",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mWarpDelay",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mItemTemporarilyHidden",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mDesiredCameraPos"
            },
            {
                "type": "bool",
                "name": "mHasGamepadControlsPrev",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mForceFireOnNextUpdate",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mFastMovementParticlesAlphaSmoothed",
                "example": "0 [0, 1]"
            },
            {
                "type": "uint64",
                "name": "mTeleBoltFramesDuringLastSecond",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mCamCorrectionTeleSmoothed",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mCamCorrectionGainSmoothed"
            },
            {
                "type": "Vec2ArrayInline",
                "name": "mCameraErrorPrev"
            },
            {
                "type": "vec2",
                "name": "mCamErrorAveraged"
            },
            {
                "type": "bool",
                "name": "mCamMovingFastPrev",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mCamFrameStartedMovingFast",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mCamFrameLastMovingFastExplosion",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mCessationDo",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mCessationLifetime",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "ivec2",
                "name": "eating_area_min"
            },
            {
                "type": "ivec2",
                "name": "eating_area_max"
            }
        ]
    },
    {
        "name": "PlayerCollisionComponent",
        "members": [
            {
                "type": "int",
                "name": "getting_crushed_threshold",
                "example": "5 [0, 100]"
            },
            {
                "type": "int",
                "name": "moving_up_before_getting_crushed_threshold",
                "example": "3 [0, 100]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "getting_crushed_counter",
                "example": "0 [0, 1]",
                "description": "1.12.2018 - Is this still used?"
            },
            {
                "type": "int",
                "name": "stuck_in_ground_counter",
                "example": "0 [0, 1]",
                "description": "used this mostly for player to figure out if it's stuck in ground"
            },
            {
                "type": "int",
                "name": "DEBUG_stuck_in_static_ground",
                "example": "0 [0, 1]",
                "description": "used to report error + also to free the player in case something horrible has gone wrong"
            },
            {
                "type": "bool",
                "name": "mCollidedHorizontally",
                "example": "0 [0, 1]"
            },
            {
                "type": "b2Body*",
                "name": "mPhysicsCollisionHax",
                "description": "hax"
            }
        ]
    },
    {
        "name": "PlayerStatsComponent",
        "members": [
            {
                "type": "int",
                "name": "lives",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "max_hp",
                "example": "4 [0, 1]"
            },
            {
                "type": "float",
                "name": "speed",
                "example": "1 [0, 1]"
            }
        ]
    },
    {
        "name": "PositionSeedComponent",
        "members": [
            {
                "type": "float",
                "name": "pos_x",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "pos_y",
                "example": "0 [0, 3.5]"
            }
        ]
    },
    {
        "name": "PotionComponent",
        "members": [
            {
                "type": "float",
                "name": "spray_velocity_coeff",
                "example": "1 [0, 2]"
            },
            {
                "type": "float",
                "name": "spray_velocity_normalized_min",
                "example": "0.5 [0, 1]"
            },
            {
                "type": "bool",
                "name": "body_colored",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "throw_bunch",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "throw_how_many",
                "example": "5 [0, 1]"
            },
            {
                "type": "bool",
                "name": "dont_spray_static_materials",
                "example": "0 [0, 1]",
                "description": "NOTE( Petri ): 15.8.2023 - if this is set to true, will only spray dynamic materials, that dont cause bugs (i.e. will not spray hard rock, box2d materials)"
            },
            {
                "type": "bool",
                "name": "dont_spray_just_leak_gas_materials",
                "example": "0 [0, 1]",
                "description": "NOTE( Petri ): 15.8.2023 - if this is set to true, will only leak gas materials instead of 'spraying' them."
            },
            {
                "type": "bool",
                "name": "never_color",
                "example": "0 [0, 1]",
                "description": "Petri: body_colored didn't seem to work, so I added never_color. It can be set to true if you never want the potion to be colored"
            }
        ],
        "custom_data_types": [
            {
                "type": "int",
                "name": "custom_color_material",
                "example": "0 [0, 1]",
                "description": "if set, will always use the color from this material"
            }
        ]
    },
    {
        "name": "PressurePlateComponent",
        "members": [
            {
                "type": "int",
                "name": "check_every_x_frames",
                "example": "30 [0, 1]",
                "description": "how often do we check the world"
            },
            {
                "type": "int",
                "name": "state",
                "example": "0 [0, 1]",
                "description": "0 is up, 1 is down"
            },
            {
                "type": "float",
                "name": "material_percent",
                "example": "0.75 [0, 1]",
                "description": "how much material should there be in the aabbs that we go down "
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mNextFrame",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "aabb_min"
            },
            {
                "type": "vec2",
                "name": "aabb_max"
            }
        ]
    },
    {
        "name": "ProjectileComponent",
        "members": [
            {
                "type": "int",
                "name": "lifetime",
                "example": "-1 [0, 1]",
                "description": "lifetime, -1 means it's endless, otherwise it's the frame count"
            },
            {
                "type": "int",
                "name": "lifetime_randomness",
                "example": "0 [0, 1]",
                "description": "final lifetime will be lifetime + random(-lifetime_randomness,lifetime_randomness)"
            },
            {
                "type": "bool",
                "name": "on_lifetime_out_explode",
                "example": "0 [0, 1]",
                "description": "when lifetime runs out, should we explode?"
            },
            {
                "type": "bool",
                "name": "collide_with_world",
                "example": "1 [0, 1]",
                "description": "true by default. Some projectiles you don't want to collide with the world, e.g. blackholes"
            },
            {
                "type": "float",
                "name": "speed_min",
                "example": "60 [0, 60000]"
            },
            {
                "type": "float",
                "name": "speed_max",
                "example": "60 [0, 60000]"
            },
            {
                "type": "float",
                "name": "friction",
                "example": "0 [0, 60000]"
            },
            {
                "type": "float",
                "name": "direction_random_rad",
                "example": "0 [0, 3.14151]",
                "description": "when fired, randomizes the velocity -this, this"
            },
            {
                "type": "float",
                "name": "direction_nonrandom_rad",
                "example": "0 [-3.14, 3.14]",
                "description": "when fired, multiplies this with projectile_i and adds it to direction"
            },
            {
                "type": "float",
                "name": "lob_min",
                "example": "0.5 [0, 60000]"
            },
            {
                "type": "float",
                "name": "lob_max",
                "example": "0.8 [0, 60000]"
            },
            {
                "type": "float",
                "name": "camera_shake_when_shot",
                "example": "0 [0, 60000]"
            },
            {
                "type": "float",
                "name": "shoot_light_flash_radius",
                "example": "0 [0, 60000]"
            },
            {
                "type": "unsignedint",
                "name": "shoot_light_flash_r",
                "example": "255 [0, 255]"
            },
            {
                "type": "unsignedint",
                "name": "shoot_light_flash_g",
                "example": "180 [0, 255]"
            },
            {
                "type": "unsignedint",
                "name": "shoot_light_flash_b",
                "example": "150 [0, 255]"
            },
            {
                "type": "bool",
                "name": "create_shell_casing",
                "example": "0 [0, 1]",
                "description": "should we create shell casings?"
            },
            {
                "type": "std::string",
                "name": "shell_casing_material",
                "example": "brass [0, 1]",
                "description": "material of the shell casing"
            },
            {
                "type": "std::string",
                "name": "muzzle_flash_file",
                "description": "this entity is created along with the projectile, oriented along the projectile's path"
            },
            {
                "type": "int",
                "name": "bounces_left",
                "example": "0 [0, 1e+008]"
            },
            {
                "type": "float",
                "name": "bounce_energy",
                "example": "0.5 [0, 1]",
                "description": "when bouncing, velocity is multiplied by this"
            },
            {
                "type": "bool",
                "name": "bounce_always",
                "example": "0 [0, 1]",
                "description": "if true, will do a fake bounce if can't do the proper bounce, but will always try to bounce"
            },
            {
                "type": "bool",
                "name": "bounce_at_any_angle",
                "example": "0 [0, 1]",
                "description": "if true, will bounce at any reflection angle"
            },
            {
                "type": "bool",
                "name": "attach_to_parent_trigger",
                "example": "0 [0, 1]",
                "description": "if true, will attach to the projectile entity that created this projectile via a trigger"
            },
            {
                "type": "std::string",
                "name": "bounce_fx_file",
                "description": "this entity is created at the bounce position. it gets the bounce angle as rotation."
            },
            {
                "type": "float",
                "name": "angular_velocity",
                "example": "0 [-3.1415, 3.1415]",
                "description": "this is only applied if velocity_sets_rotation == false"
            },
            {
                "type": "bool",
                "name": "velocity_sets_rotation",
                "example": "1 [0, 1]",
                "description": "whether we set the rotation based on velocity, as in spear or if we update the rotation with angular_velocity"
            },
            {
                "type": "bool",
                "name": "velocity_sets_scale",
                "example": "0 [0, 1]",
                "description": "if true, the sprite width is made equal to the distance traveled since last frame"
            },
            {
                "type": "float",
                "name": "velocity_sets_scale_coeff",
                "example": "1 [0, 1]",
                "description": "Larger value means velocity affects the scale more"
            },
            {
                "type": "bool",
                "name": "velocity_sets_y_flip",
                "example": "0 [0, 1]",
                "description": "if true, the sprite is flipped based on which side the projectile is currently traveling"
            },
            {
                "type": "float",
                "name": "velocity_updates_animation",
                "example": "0 [0, 1]",
                "description": "updates the animation based on far the sprite moved"
            },
            {
                "type": "float",
                "name": "ground_penetration_coeff",
                "example": "0 [0, 5]",
                "description": "if > 0, this, along with VelocityComponent.mass affects how far we penetrate in materials"
            },
            {
                "type": "int",
                "name": "ground_penetration_max_durability_to_destroy",
                "example": "0 [0, 1]",
                "description": "if 0, will not penetrate into materials with durability greater than this"
            },
            {
                "type": "std::string",
                "name": "go_through_this_material",
                "description": "if set, we never collide with this material"
            },
            {
                "type": "bool",
                "name": "do_moveto_update",
                "example": "1 [0, 1]",
                "description": "this should probably be true, to get normal projectile behaviour, but you might want to disable this for some physics-based projectiles, like bombs"
            },
            {
                "type": "int",
                "name": "on_death_duplicate_remaining",
                "example": "0 [0, 1]",
                "description": "if greater than 0, the projectile creates two clones of itself on death. 'on_death_duplicate_remaining' on the clones is reduced by one"
            },
            {
                "type": "bool",
                "name": "on_death_gfx_leave_sprite",
                "example": "1 [0, 1]",
                "description": "if true, finds all the sprites and leaves as sand cells into the grid"
            },
            {
                "type": "bool",
                "name": "on_death_explode",
                "example": "0 [0, 1]",
                "description": "if true, does explosion with config_explosion"
            },
            {
                "type": "bool",
                "name": "on_death_emit_particle",
                "example": "0 [0, 1]",
                "description": "if true, emits on_death_emit_particle_type on death"
            },
            {
                "type": "int",
                "name": "on_death_emit_particle_count",
                "example": "1 [0, 1]",
                "description": "how many particles should we emit"
            },
            {
                "type": "bool",
                "name": "die_on_liquid_collision",
                "example": "0 [0, 1]",
                "description": "if true, dies on collision with liquids"
            },
            {
                "type": "bool",
                "name": "die_on_low_velocity",
                "example": "0 [0, 1]",
                "description": "if true, dies when speed goes below die_on_low_velocity_limit"
            },
            {
                "type": "float",
                "name": "die_on_low_velocity_limit",
                "example": "50 [0, 1]",
                "description": "please see die_on_low_velocity"
            },
            {
                "type": "std::string",
                "name": "on_death_emit_particle_type"
            },
            {
                "type": "bool",
                "name": "on_death_particle_check_concrete",
                "example": "0 [0, 1]",
                "description": "if you want it to stick as concrete, you should enable this"
            },
            {
                "type": "bool",
                "name": "ground_collision_fx",
                "example": "1 [0, 1]",
                "description": "if 1, spurt some particles when colliding with mortals"
            },
            {
                "type": "bool",
                "name": "explosion_dont_damage_shooter",
                "example": "0 [0, 1]",
                "description": "if true, explosion doesn't damage the entity who shot this"
            },
            {
                "type": "float",
                "name": "on_death_item_pickable_radius",
                "example": "0 [0, 1]",
                "description": "if > 0, makes items closer than this radius pickable on death"
            },
            {
                "type": "bool",
                "name": "penetrate_world",
                "example": "0 [0, 1]",
                "description": "if true, the projectile doesn't collide with ground, liquids, physical objects etc"
            },
            {
                "type": "float",
                "name": "penetrate_world_velocity_coeff",
                "example": "0.6 [0, 1]",
                "description": "if 'penetrate_world' is true, the projectile moves with a velocity multiplied by this value when inside world"
            },
            {
                "type": "bool",
                "name": "penetrate_entities",
                "example": "0 [0, 1]",
                "description": "if true, the projectile doesn't stop when it collides with entities. damages each entity only once"
            },
            {
                "type": "bool",
                "name": "on_collision_die",
                "example": "1 [0, 1]",
                "description": "if true, this is killed as soon as it hits the ground"
            },
            {
                "type": "bool",
                "name": "on_collision_remove_projectile",
                "example": "0 [0, 1]",
                "description": "if true, ProjectileComponent is removed from the entitiy"
            },
            {
                "type": "bool",
                "name": "on_collision_spawn_entity",
                "example": "1 [0, 1]",
                "description": "if true, spawns the spawn_entity"
            },
            {
                "type": "std::string",
                "name": "spawn_entity",
                "description": "this is spawned if hit something an on_collision_spawn_entity = 1"
            },
            {
                "type": "bool",
                "name": "spawn_entity_is_projectile",
                "example": "0 [0, 1]",
                "description": "if true, will use ShootProjectile instead of LoadEntity()"
            },
            {
                "type": "float",
                "name": "physics_impulse_coeff",
                "example": "300 [0, 1]",
                "description": "projectile applies an impulse to physics bodies it hits. Impulse = physics_impulse_coeff * velocity"
            },
            {
                "type": "int",
                "name": "damage_every_x_frames",
                "example": "-1 [0, 1]",
                "description": "if set != -1, will only do damage every x frames, used for fields and such, which would otherwise do damage every frame"
            },
            {
                "type": "bool",
                "name": "damage_scaled_by_speed",
                "example": "0 [0, 1]",
                "description": "if 1, damage is multiplied by (projectile speed / original projectile speed) ratio"
            },
            {
                "type": "float",
                "name": "damage_scale_max_speed",
                "example": "0 [0, 1]",
                "description": "if > 0 and damage_scaled_by_speed = 1, will use this instead of mInitialSpeed when calculating the damage"
            },
            {
                "type": "bool",
                "name": "collide_with_entities",
                "example": "1 [0, 1]",
                "description": "if 1, looks for entities with tag, collide_with_tag and collides with them, giving them damage"
            },
            {
                "type": "std::string",
                "name": "collide_with_tag",
                "example": "hittable [0, 1]",
                "description": "default: mortal, if you needed can be changed to something more specific"
            },
            {
                "type": "std::string",
                "name": "dont_collide_with_tag",
                "description": "if set will ignore entities with this tag"
            },
            {
                "type": "int",
                "name": "collide_with_shooter_frames",
                "example": "-1 [0, 1]",
                "description": "remember friendly_fire 1, if -1 won't collide with shooter at all, otherwise uses the value as frame count and while it's running won't damage the shooter "
            },
            {
                "type": "bool",
                "name": "friendly_fire",
                "example": "0 [0, 1]",
                "description": "if true, will damage same herd id"
            },
            {
                "type": "float",
                "name": "damage",
                "example": "1 [0, 1]",
                "description": "how much Projectile damage does this do when it hits something"
            },
            {
                "type": "float",
                "name": "knockback_force",
                "example": "0 [0, 1]",
                "description": "How far do entities get thrown if a knockback occurs. final_knockback = ProjectileComponent.knockback_force * VelocityComponent.mVelocity * VelocityComponent.mass / who_we_hit.mass"
            },
            {
                "type": "float",
                "name": "ragdoll_force_multiplier",
                "example": "0.025 [0, 1]",
                "description": "velocity * ragdoll_force_multiplier is applied to any ragdolls that are created by entities killed by this"
            },
            {
                "type": "float",
                "name": "hit_particle_force_multiplier",
                "example": "0.1 [0, 1]",
                "description": "hit particle velocity = projectile_velocity * hit_particle_force_multiplier * some randomness"
            },
            {
                "type": "float",
                "name": "blood_count_multiplier",
                "example": "1 [0, 1]",
                "description": "how much blood does this projectile cause"
            },
            {
                "type": "std::string",
                "name": "damage_game_effect_entities",
                "description": "a list of game_effects entities separated with ','. e.g. 'data/entities/misc/effect_electrocution.xml,data/entities/misc/effect_on_fire.xml' "
            },
            {
                "type": "bool",
                "name": "never_hit_player",
                "example": "0 [0, 1]",
                "description": "If 1, does not hit player no matter what herds this and player belong to"
            },
            {
                "type": "bool",
                "name": "collect_materials_to_shooter",
                "example": "0 [0, 1]",
                "description": "if 1, looks up the 'who_shot' entity and its MaterialInventoryComponent on destruction and updates it based on the cells destroyed on our explosion."
            },
            {
                "type": "bool",
                "name": "play_damage_sounds",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "mLastFrameDamaged",
                "example": "-1024 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "mWhoShot",
                "example": "0 [0, 1]",
                "description": "entity (creature) that shot this"
            },
            {
                "type": "EntityTypeID",
                "name": "mWhoShotEntityTypeID",
                "example": "0 [0, 1]",
                "description": "used for stats"
            },
            {
                "type": "int",
                "name": "mShooterHerdId",
                "example": "0 [0, 1]",
                "description": "the herdid of mWhoShot, unless friendly fire"
            },
            {
                "type": "int",
                "name": "mStartingLifetime",
                "example": "0 [0, 1]"
            },
            {
                "type": "EntityID",
                "name": "mEntityThatShot",
                "example": "0 [0, 1]",
                "description": "for triggers, if shot from a trigger this should point to the projectile entity that shot this. Otherwise this should be the same as mWhoShot. NOTE! Not really tested properly so might break."
            },
            {
                "type": "ProjectileTriggers",
                "name": "mTriggers"
            },
            {
                "type": "VEC_ENTITY",
                "name": "mDamagedEntities"
            },
            {
                "type": "float",
                "name": "mInitialSpeed",
                "example": "-1 [0, 1]"
            }
        ],
        "objects": [
            {
                "type": "ConfigGunActionInfo",
                "name": "config"
            },
            {
                "type": "ConfigExplosion",
                "name": "config_explosion",
                "description": "if we have explosion, it's the setup for it"
            },
            {
                "type": "ConfigDamagesByType",
                "name": "damage_by_type",
                "description": "the amounts of different types of damage this does"
            },
            {
                "type": "ConfigDamageCritical",
                "name": "damage_critical",
                "description": "config for critical hit"
            }
        ],
        "custom_data_types": [
            {
                "type": "PROJECTILE_TYPE::Enum",
                "name": "projectile_type"
            },
            {
                "type": "vec2",
                "name": "shell_casing_offset",
                "description": "where the shell casing will be created relative to projectile, y is flipped if projectile direction is to the left."
            },
            {
                "type": "RAGDOLL_FX::Enum",
                "name": "ragdoll_fx_on_collision",
                "description": "if not NORMAL, do a special ragdoll"
            }
        ]
    },
    {
        "name": "RotateTowardsComponent",
        "members": [
            {
                "type": "std::string",
                "name": "entity_with_tag",
                "example": "player_unit [0, 1]",
                "description": "will rotate this entity towards the closest entity with tag"
            }
        ]
    },
    {
        "name": "SetLightAlphaFromVelocityComponent",
        "members": [
            {
                "type": "float",
                "name": "max_velocity",
                "example": "50 [1, 150]"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mPrevPosition"
            }
        ]
    },
    {
        "name": "SetStartVelocityComponent",
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "velocity",
                "description": "This is added together with random velocity"
            },
            {
                "type": "ValueRange",
                "name": "randomize_angle",
                "description": "Random angle min max range in radians, clockwise. 0.0 points directly rightward."
            },
            {
                "type": "ValueRange",
                "name": "randomize_speed",
                "description": "Random speed min max range"
            }
        ]
    },
    {
        "name": "ShotEffectComponent",
        "members": [
            {
                "type": "std::string",
                "name": "extra_modifier",
                "description": "name of modifier function executed per projectile from 'gun_extra_modifiers.lua'"
            }
        ],
        "custom_data_types": [
            {
                "type": "GAME_EFFECT::Enum",
                "name": "condition_effect",
                "description": "Shooting entity needs to have this 'GAME_EFFECT' for effects to apply. If both 'condition_effect' and 'condition_status' are set, they are combined with AND logic"
            },
            {
                "type": "StatusEffectType",
                "name": "condition_status",
                "example": "0 [0, 1]",
                "description": "Shooting entity needs to have this 'STATUS_EFFECT' for effects to apply"
            }
        ]
    },
    {
        "name": "SimplePhysicsComponent",
        "members": [
            {
                "type": "bool",
                "name": "can_go_up",
                "example": "1 [0, 1]",
                "description": "if set, will not try to move this upwards"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mOldPosition",
                "description": "used for box2d simple physics"
            }
        ]
    },
    {
        "name": "SineWaveComponent",
        "members": [
            {
                "type": "float",
                "name": "sinewave_freq",
                "example": "1 [0, 1]",
                "description": "sinewave_m * sinf( sinewave_freq * lifetime++)"
            },
            {
                "type": "float",
                "name": "sinewave_m",
                "example": "0.6 [0, 1]",
                "description": "sinewave_m * sinf( sinewave_freq * lifetime++)"
            },
            {
                "type": "int",
                "name": "lifetime",
                "example": "-1 [0, 1]",
                "description": "-1 seems to fix some problems with this... sinewave_m * sinf( sinewave_freq * lifetime++)"
            }
        ]
    },
    {
        "name": "SpriteAnimatorComponent",
        "members": [
            {
                "type": "std::string",
                "name": "target_sprite_comp_name",
                "example": "character [0, 1]"
            },
            {
                "type": "bool",
                "name": "rotate_to_surface_normal",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "STACK_ANIMATIONSTATE",
                "name": "mStates"
            },
            {
                "type": "ComponentTags",
                "name": "mCachedTargetSpriteTag"
            },
            {
                "type": "std::string",
                "name": "mSendOnFinishedMessageName"
            }
        ]
    },
    {
        "name": "SpriteComponent",
        "members": [
            {
                "type": "std::string",
                "name": "image_file",
                "example": "data/temp/temp_gun.png [0, 1]"
            },
            {
                "type": "bool",
                "name": "ui_is_parent",
                "example": "0 [0, 1]",
                "description": "Adds this to the GG.GetUISprite() as a child, instead of the mSpriteContainer"
            },
            {
                "type": "bool",
                "name": "is_text_sprite",
                "example": "0 [0, 1]",
                "description": "if you want to load a text sprite, set this to true and image_file to a font file"
            },
            {
                "type": "float",
                "name": "offset_x",
                "example": "0 [-24, 24]"
            },
            {
                "type": "float",
                "name": "offset_y",
                "example": "0 [-24, 24]"
            },
            {
                "type": "float",
                "name": "alpha",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "visible",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "emissive",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "additive",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "fog_of_war_hole",
                "example": "0 [0, 1]",
                "description": "if 1, the alpha channel of this texture punctures a hole in the fog of war"
            },
            {
                "type": "bool",
                "name": "smooth_filtering",
                "example": "0 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "rect_animation"
            },
            {
                "type": "std::string",
                "name": "next_rect_animation"
            },
            {
                "type": "std::string",
                "name": "text"
            },
            {
                "type": "float",
                "name": "z_index",
                "example": "1 [-256, 256]",
                "description": "0 = world grid, -1 = enemies, -1.5 = items in world, player = 0.6"
            },
            {
                "type": "bool",
                "name": "update_transform",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "update_transform_rotation",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "kill_entity_after_finished",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "has_special_scale",
                "example": "0 [0, 1]",
                "description": "if this is set, sets special_scale_x and _y to scale"
            },
            {
                "type": "float",
                "name": "special_scale_x",
                "example": "1 [0, 1]",
                "description": "this overrides the scale of the entity, if has_special_scale"
            },
            {
                "type": "float",
                "name": "special_scale_y",
                "example": "1 [0, 1]",
                "description": "this overrides the scale of the entity, if has_special_scale"
            },
            {
                "type": "bool",
                "name": "never_ragdollify_on_death",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "as::Sprite*",
                "name": "mSprite"
            },
            {
                "type": "SpriteRenderList*",
                "name": "mRenderList"
            },
            {
                "type": "int32",
                "name": "mRenderListHandle",
                "example": "-1 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "transform_offset"
            },
            {
                "type": "vec2",
                "name": "offset_animator_offset",
                "description": "used by SpriteOffsetAnimator"
            }
        ]
    },
    {
        "name": "SpriteOffsetAnimatorComponent",
        "members": [
            {
                "type": "float",
                "name": "x_amount",
                "example": "0 [0, 5]"
            },
            {
                "type": "float",
                "name": "x_speed",
                "example": "0 [0, 5]"
            },
            {
                "type": "float",
                "name": "y_amount",
                "example": "2 [0, 5]"
            },
            {
                "type": "float",
                "name": "y_speed",
                "example": "2 [0, 5]"
            },
            {
                "type": "int",
                "name": "sprite_id",
                "example": "0 [0, 8]"
            },
            {
                "type": "float",
                "name": "x_phase",
                "example": "16 [0, 32]"
            },
            {
                "type": "float",
                "name": "x_phase_offset",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "SpriteParticleEmitterComponent",
        "members": [
            {
                "type": "std::string",
                "name": "sprite_file",
                "description": "filepath to the sprite(s), supports the $[0-3] syntax"
            },
            {
                "type": "bool",
                "name": "sprite_centered",
                "example": "0 [0, 1]",
                "description": "sets the offset to the center of the image"
            },
            {
                "type": "bool",
                "name": "sprite_random_rotation",
                "example": "0 [0, 1]",
                "description": "rotates the sprite randomly in 90 degree angles"
            },
            {
                "type": "bool",
                "name": "render_back",
                "example": "0 [0, 1]",
                "description": "if true, will set this particle to be behind entities (won't emit light)"
            },
            {
                "type": "float",
                "name": "delay",
                "example": "0 [0, 1]",
                "description": "delay in seconds..."
            },
            {
                "type": "float",
                "name": "lifetime",
                "example": "0 [0, 1]",
                "description": "lifetime in seconds..."
            },
            {
                "type": "bool",
                "name": "additive",
                "example": "0 [0, 1]",
                "description": "if 1, the sprites will be rendered using additive blending"
            },
            {
                "type": "bool",
                "name": "emissive",
                "example": "0 [0, 1]",
                "description": "if 1, the sprites will be rendered onto the emissive render target"
            },
            {
                "type": "float",
                "name": "velocity_slowdown",
                "example": "0 [0, 1]",
                "description": "what percent of the velocity is slowed by *dt"
            },
            {
                "type": "float",
                "name": "rotation",
                "example": "0 [0, 1]",
                "description": "original rotation in rads"
            },
            {
                "type": "float",
                "name": "angular_velocity",
                "example": "0 [0, 1]",
                "description": "how much rotation there is in a second"
            },
            {
                "type": "bool",
                "name": "use_velocity_as_rotation",
                "example": "0 [0, 1]",
                "description": "do we rotate the sprite based on the velocity"
            },
            {
                "type": "bool",
                "name": "use_rotation_from_velocity_component",
                "example": "0 [0, 1]",
                "description": "if set, will set the initial rotation based on the velocity component's velocity"
            },
            {
                "type": "bool",
                "name": "use_rotation_from_entity",
                "example": "0 [0, 1]",
                "description": "if set, will 'inherit' rotation from the entity"
            },
            {
                "type": "float",
                "name": "entity_velocity_multiplier",
                "example": "0 [0, 1]",
                "description": "0 = doesn't use the velocity from spawning entity at all, 1 = uses all"
            },
            {
                "type": "float",
                "name": "z_index",
                "example": "0 [0, 1]",
                "description": "Depth of created particles"
            },
            {
                "type": "bool",
                "name": "randomize_position_inside_hitbox",
                "example": "0 [0, 1]",
                "description": "if set, will randomize position inside the hitbox aabb"
            },
            {
                "type": "bool",
                "name": "velocity_always_away_from_center",
                "example": "0 [0, 1]",
                "description": "if set, will make the velocity's rotation always away from center of randomized aabb"
            },
            {
                "type": "bool",
                "name": "camera_bound",
                "example": "1 [0, 1]",
                "description": "if true, will be culled if not near the camera"
            },
            {
                "type": "float",
                "name": "camera_distance",
                "example": "75 [0, 1]",
                "description": "if the distance from camera (edges) is higher than this, this will be culled"
            },
            {
                "type": "bool",
                "name": "is_emitting",
                "example": "1 [0, 1]",
                "description": "disable this from emitting..."
            },
            {
                "type": "int",
                "name": "count_min",
                "example": "0 [0, 1]",
                "description": "how many particles do we spawn at one time"
            },
            {
                "type": "int",
                "name": "count_max",
                "example": "1 [0, 1]",
                "description": "how many particles do we spawn at one time"
            },
            {
                "type": "int",
                "name": "emission_interval_min_frames",
                "example": "5 [0, 200]",
                "description": "how often do we emit particles"
            },
            {
                "type": "int",
                "name": "emission_interval_max_frames",
                "example": "10 [0, 200]",
                "description": "how often do we emit particles"
            },
            {
                "type": "std::string",
                "name": "entity_file",
                "description": "if set, this entity is loaded to the emission position by the emitter when it emits"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mNextEmitFrame",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "types::fcolor",
                "name": "color",
                "description": "original color"
            },
            {
                "type": "types::fcolor",
                "name": "color_change",
                "description": "how much the color changes in a second"
            },
            {
                "type": "vec2",
                "name": "velocity",
                "description": "original velocity"
            },
            {
                "type": "vec2",
                "name": "gravity",
                "description": "gravity"
            },
            {
                "type": "vec2",
                "name": "scale",
                "description": "original scale"
            },
            {
                "type": "vec2",
                "name": "scale_velocity",
                "description": "scale velocity per second"
            },
            {
                "type": "ValueRange",
                "name": "randomize_lifetime",
                "description": "this is added to the lifetime"
            },
            {
                "type": "types::aabb",
                "name": "randomize_position",
                "description": "random offset for pos"
            },
            {
                "type": "types::aabb",
                "name": "randomize_velocity",
                "description": "add this randomized velocity inside this o the velocity"
            },
            {
                "type": "types::aabb",
                "name": "randomize_scale",
                "description": "add this randomized vector2 to scale"
            },
            {
                "type": "ValueRange",
                "name": "randomize_rotation",
                "description": "this is added to the rotation "
            },
            {
                "type": "ValueRange",
                "name": "randomize_angular_velocity",
                "description": "this is added to angular_velocity"
            },
            {
                "type": "ValueRange",
                "name": "randomize_alpha",
                "description": "this is added to the alpha"
            },
            {
                "type": "ValueRange",
                "name": "randomize_animation_speed_coeff",
                "description": "if set, animation speed is multiplied by a random value inside this range"
            },
            {
                "type": "vec2",
                "name": "expand_randomize_position",
                "description": "will add dt*this to randomize_position_aabb every frame"
            }
        ]
    },
    {
        "name": "SpriteStainsComponent",
        "members": [
            {
                "type": "int",
                "name": "sprite_id",
                "example": "0 [0, 10]",
                "description": "which sprite (in the order in which they appear in the entity) are we going to stain?"
            },
            {
                "type": "bool",
                "name": "fade_stains_towards_srite_top",
                "example": "1 [0, 1]",
                "description": "if 1, shades get less opaque near the top of the sprite"
            }
        ],
        "privates": [
            {
                "type": "VirtualTextureHandle",
                "name": "mTextureHandle"
            },
            {
                "type": "SpriteStainsState",
                "name": "mState"
            }
        ],
        "custom_data_types": [
            {
                "type": "LensValue<int>",
                "name": "stain_shaken_drop_chance_multiplier",
                "description": "how quickly stains are dropped relative to normal drop speed"
            },
            {
                "type": "SpriteStains*",
                "name": "mData"
            }
        ]
    },
    {
        "name": "StatusEffectDataComponent",
        "privates": [
            {
                "type": "int",
                "name": "mLastAttackingPlayerFrame",
                "example": "-99999 [0, 1]"
            },
            {
                "type": "VECTOR_FLOAT",
                "name": "mStainEffectsSmoothedForUI"
            },
            {
                "type": "bool",
                "name": "mHasChildIconsCached",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "VECTOR_FLOAT",
                "name": "stain_effects"
            },
            {
                "type": "VECTOR_INT32",
                "name": "stain_effect_cooldowns"
            },
            {
                "type": "VECTOR_FLOAT",
                "name": "effects_previous"
            },
            {
                "type": "VECTOR_FLOAT",
                "name": "ingestion_effects"
            },
            {
                "type": "VEC_OF_MATERIALS",
                "name": "ingestion_effect_causes"
            },
            {
                "type": "VECTOR_INT32",
                "name": "ingestion_effect_causes_many"
            }
        ]
    },
    {
        "name": "StreamingKeepAliveComponent",
        "members": [
            {
                "type": "float",
                "name": "TEMP_TEMPY",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "TEMP_TEMP_TEMP",
                "example": "0 [0, 3.5]"
            }
        ]
    },
    {
        "name": "TelekinesisComponent",
        "members": [
            {
                "type": "uint32",
                "name": "min_size",
                "example": "7 [0, 1]",
                "description": "Minimum size of physics body that can be grabbed, in cells/pixels"
            },
            {
                "type": "uint32",
                "name": "max_size",
                "example": "1500 [0, 1]",
                "description": "Maximum size of physics body that can be grabbed, in cells/pixels"
            },
            {
                "type": "float",
                "name": "radius",
                "example": "250 [0, 300]",
                "description": "Maximum object search distance"
            },
            {
                "type": "float",
                "name": "throw_speed",
                "example": "25 [0, 300]",
                "description": "Affects object speed when it is thrown"
            },
            {
                "type": "float",
                "name": "target_distance",
                "example": "6 [0, 30]",
                "description": "Affects how far objects float from owner when held. Object size will also affect the floating distance."
            },
            {
                "type": "bool",
                "name": "kick_to_use",
                "example": "1 [0, 1]",
                "description": "If 1, telekinesis interaction will occur when kick input is detected in root entity's ControlsComponent"
            },
            {
                "type": "int32",
                "name": "mState",
                "example": "0 [0, 1]"
            },
            {
                "type": "uint64",
                "name": "mBodyID",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mStartBodyMaxExtent",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mStartAimAngle",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mStartBodyAngle",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mStartBodyDistance",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mStartTime",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mMinBodyDistance",
                "example": "3.40282e+038 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mInteract",
                "example": "0 [0, 1]",
                "description": "If set to true, telekinesis interaction will occur. Will automatically turn to false at the end of component update."
            }
        ]
    },
    {
        "name": "TeleportComponent",
        "members": [
            {
                "type": "bool",
                "name": "target_x_is_absolute_position",
                "example": "0 [0, 1]",
                "description": "If set, target position x is in world coordinates, otherwise it's an offset"
            },
            {
                "type": "bool",
                "name": "target_y_is_absolute_position",
                "example": "0 [0, 1]",
                "description": "If set, target position y is in world coordinates, otherwise it's an offset"
            },
            {
                "type": "std::string",
                "name": "source_particle_fx_file",
                "example": "data/entities/particles/teleportation_source.xml [0, 1]",
                "description": "This entity is loaded at the source position when teleportation occurs"
            },
            {
                "type": "std::string",
                "name": "target_particle_fx_file",
                "example": "data/entities/particles/teleportation_target.xml [0, 1]",
                "description": "This entity is loaded at the target position when teleportation occurs"
            },
            {
                "type": "bool",
                "name": "load_collapse_entity",
                "example": "1 [0, 1]",
                "description": "if we don't want things to collapse after the teleport"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "safety_counter",
                "example": "0 [0, 1]",
                "description": "used to keep track that we're not stuck in waiting for a pixel scene to load, that is not going to be loaded"
            },
            {
                "type": "TeleportComponentState::Enum",
                "name": "state"
            },
            {
                "type": "ENTITY_VEC",
                "name": "teleported_entities"
            },
            {
                "type": "types::aabb",
                "name": "source_location_camera_aabb"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "target",
                "description": "Where should we teleport"
            }
        ]
    },
    {
        "name": "TeleportProjectileComponent",
        "members": [
            {
                "type": "float",
                "name": "min_distance_from_wall",
                "example": "16 [0, 16]"
            },
            {
                "type": "int",
                "name": "actionable_lifetime",
                "example": "3 [0, 20]"
            },
            {
                "type": "bool",
                "name": "reset_shooter_y_vel",
                "example": "1 [0, 1]",
                "description": "If 1, will set shooter y velocity to 0 on teleport"
            }
        ],
        "privates": [
            {
                "type": "EntityID",
                "name": "mWhoShot",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "TextLogComponent",
        "members": [
            {
                "type": "std::string",
                "name": "key"
            },
            {
                "type": "std::string",
                "name": "image_filename"
            }
        ],
        "privates": [
            {
                "type": "std::string",
                "name": "mCachedName"
            }
        ]
    },
    {
        "name": "TorchComponent",
        "members": [
            {
                "type": "int",
                "name": "probability_of_ignition_attempt",
                "example": "15 [0, 100]",
                "description": "how likely are we to ignite colliding cells"
            },
            {
                "type": "float",
                "name": "suffocation_check_offset_y",
                "example": "-2 [-10, 10]",
                "description": "check offset in world coordinates from our position"
            },
            {
                "type": "int",
                "name": "frames_suffocated_to_extinguish",
                "example": "5 [0, 30]",
                "description": "how many frames the torch needs to be suffocated before it stops emitting fire"
            },
            {
                "type": "bool",
                "name": "extinguishable",
                "example": "1 [0, 1]",
                "description": "if 1, the torch needs to be re-ignited in case it is turned off"
            },
            {
                "type": "float",
                "name": "fire_audio_weight",
                "example": "0 [0, 2]",
                "description": "how loud is the sound of our fire? 0 = no sound"
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "mFlickerOffset",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFramesSuffocated",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mIsOn",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mFireIsBurningPrev",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "UIIconComponent",
        "members": [
            {
                "type": "std::string",
                "name": "icon_sprite_file"
            },
            {
                "type": "std::string",
                "name": "name"
            },
            {
                "type": "std::string",
                "name": "description"
            },
            {
                "type": "bool",
                "name": "display_above_head",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "display_in_hud",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "is_perk",
                "example": "1 [0, 1]"
            }
        ]
    },
    {
        "name": "UIInfoComponent",
        "members": [
            {
                "type": "std::string",
                "name": "name"
            }
        ]
    },
    {
        "name": "VariableStorageComponent",
        "members": [
            {
                "type": "std::string",
                "name": "name"
            },
            {
                "type": "std::string",
                "name": "value_string"
            },
            {
                "type": "int",
                "name": "value_int",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "value_bool",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "value_float",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "VelocityComponent",
        "members": [
            {
                "type": "float",
                "name": "gravity_x",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "gravity_y",
                "example": "400 [0, 1]"
            },
            {
                "type": "float",
                "name": "mass",
                "example": "0.05 [0, 10]"
            },
            {
                "type": "float",
                "name": "air_friction",
                "example": "0.55 [0, 1]"
            },
            {
                "type": "float",
                "name": "terminal_velocity",
                "example": "1000 [0, 1]"
            },
            {
                "type": "bool",
                "name": "apply_terminal_velocity",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "updates_velocity",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "displace_liquid",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "affect_physics_bodies",
                "example": "0 [0, 1]",
                "description": "if true, will move the physics body by the difference of mVelocity to the previous frame"
            },
            {
                "type": "bool",
                "name": "limit_to_max_velocity",
                "example": "1 [0, 1]",
                "description": "if true will limit the velocity to 61440. You can turn this off, but it's not recommended, since there are some nasty bugs that can happen with extremely high velocities."
            },
            {
                "type": "int",
                "name": "liquid_death_threshold",
                "example": "0 [0, 1]",
                "description": "if > 0, entity will die if liquid hit count is greater than this."
            },
            {
                "type": "float",
                "name": "liquid_drag",
                "example": "1 [0, 1]",
                "description": "1 = slows down in liquid, 0 = doesn't slow down at all"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mPrevVelocity",
                "description": "used to update physics bodies"
            },
            {
                "type": "int",
                "name": "mLatestLiquidHitCount",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mAverageLiquidHitCount",
                "example": "0 [0, 1]"
            },
            {
                "type": "ivec2",
                "name": "mPrevPosition"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "mVelocity"
            }
        ]
    },
    {
        "name": "VerletPhysicsComponent",
        "members": [
            {
                "type": "int",
                "name": "num_points",
                "example": "2 [0, 1]"
            },
            {
                "type": "int",
                "name": "num_links",
                "example": "2 [0, 1]"
            },
            {
                "type": "int",
                "name": "width",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "resting_distance",
                "example": "2 [0, 16]"
            },
            {
                "type": "float",
                "name": "mass_min",
                "example": "0.8 [0.03, 2]"
            },
            {
                "type": "float",
                "name": "mass_max",
                "example": "1 [0.03, 2]"
            },
            {
                "type": "float",
                "name": "stiffness",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "velocity_dampening",
                "example": "0.99 [0.2, 1]"
            },
            {
                "type": "float",
                "name": "liquid_damping",
                "example": "0.7 [0, 1]",
                "description": "how much we dampen when in liquid"
            },
            {
                "type": "float",
                "name": "gets_entity_velocity_coeff",
                "example": "0 [0, 10]"
            },
            {
                "type": "bool",
                "name": "collide_with_cells",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "simulate_gravity",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "simulate_wind",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "wind_change_speed",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "constrain_stretching",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "pixelate_sprite_transforms",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "scale_sprite_x",
                "example": "1 [0, 1]"
            },
            {
                "type": "bool",
                "name": "follow_entity_transform",
                "example": "1 [0, 1]"
            },
            {
                "type": "float",
                "name": "animation_amount",
                "example": "2 [0, 1]"
            },
            {
                "type": "float",
                "name": "animation_speed",
                "example": "5 [0, 1]"
            },
            {
                "type": "float",
                "name": "animation_energy",
                "example": "0.6 [0, 1]"
            },
            {
                "type": "float",
                "name": "cloth_sprite_z_index",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "stain_cells_probability",
                "example": "0 [0, 1]",
                "description": "0 = never, 1 = most likely, 10 = less likely - and so on"
            },
            {
                "type": "bool",
                "name": "m_is_culled_previous",
                "example": "0 [0, 1]",
                "description": "Developer note: this needs to be serialized in case we serialize SpriteComponent.is_visible"
            }
        ],
        "privates": [
            {
                "type": "FloatArrayInline",
                "name": "masses"
            },
            {
                "type": "Vec2ArrayInline",
                "name": "positions"
            },
            {
                "type": "Vec2ArrayInline",
                "name": "positions_prev"
            },
            {
                "type": "Vec2ArrayInline",
                "name": "velocities"
            },
            {
                "type": "FloatArrayInline",
                "name": "dampenings"
            },
            {
                "type": "FloatArrayInline",
                "name": "freedoms"
            },
            {
                "type": "VerletLinkArrayInline",
                "name": "links"
            },
            {
                "type": "VerletSprite*",
                "name": "sprite"
            }
        ],
        "custom_data_types": [
            {
                "type": "VERLET_TYPE::Enum",
                "name": "type"
            },
            {
                "type": "vec2",
                "name": "animation_target_offset"
            },
            {
                "type": "uint32",
                "name": "cloth_color_edge",
                "example": "4288376730 [0, 1]"
            },
            {
                "type": "uint32",
                "name": "cloth_color",
                "example": "4286534774 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "m_position_previous"
            },
            {
                "type": "UintArrayInline",
                "name": "colors"
            },
            {
                "type": "UintArrayInline",
                "name": "materials"
            }
        ]
    },
    {
        "name": "VerletWeaponComponent",
        "members": [
            {
                "type": "float",
                "name": "damage_radius",
                "example": "5 [0, 10]"
            },
            {
                "type": "float",
                "name": "physics_force_radius",
                "example": "3 [0, 10]"
            },
            {
                "type": "float",
                "name": "damage_min_step",
                "example": "0.01 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "damage_max",
                "example": "1 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "damage_coeff",
                "example": "1 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "impulse_coeff",
                "example": "1 [0, 3.5]"
            },
            {
                "type": "int",
                "name": "fade_duration_frames",
                "example": "10 [0, 100]"
            },
            {
                "type": "float",
                "name": "physics_impulse_coeff",
                "example": "1 [0, 3.5]"
            }
        ],
        "privates": [
            {
                "type": "int",
                "name": "mPlayerCooldownEnd",
                "example": "-1 [0, 1]"
            }
        ]
    },
    {
        "name": "VerletWorldJointComponent",
        "members": [
            {
                "type": "int",
                "name": "verlet_point_index",
                "example": "0 [0, 32]",
                "description": "Index of the verlet point we attach"
            }
        ],
        "privates": [
            {
                "type": "bool",
                "name": "mUpdated",
                "example": "0 [0, 1]"
            },
            {
                "type": "grid::ICell*",
                "name": "mCell"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "world_position",
                "description": "Where we attach the verlet point"
            }
        ]
    },
    {
        "name": "WalletComponent",
        "members": [
            {
                "type": "int64",
                "name": "money",
                "example": "0 [0, 10000]"
            },
            {
                "type": "int64",
                "name": "money_spent",
                "example": "0 [0, 1]",
                "description": "tracks how much money the player has spent"
            },
            {
                "type": "int64",
                "name": "mMoneyPrevFrame",
                "example": "0 [0, 1]",
                "description": "HAX to give player towards infinite moneys"
            },
            {
                "type": "bool",
                "name": "mHasReachedInf",
                "example": "0 [0, 1]",
                "description": "once it hits this value... keep it there"
            }
        ]
    },
    {
        "name": "WalletValuableComponent",
        "members": [
            {
                "type": "int",
                "name": "money_value",
                "example": "10 [0, 100]"
            }
        ]
    },
    {
        "name": "WorldStateComponent",
        "members": [
            {
                "type": "bool",
                "name": "is_initialized",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "time",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "time_total",
                "example": "0 [0, 1000]"
            },
            {
                "type": "float",
                "name": "time_dt",
                "example": "1 [0, 1000]",
                "description": "to make the time go really fast or slow?"
            },
            {
                "type": "int",
                "name": "day_count",
                "example": "0 [0, 3.5]"
            },
            {
                "type": "float",
                "name": "rain",
                "example": "0 [0, 1]",
                "description": "should be called clouds, controls amount of cloud cover in the sky"
            },
            {
                "type": "float",
                "name": "rain_target",
                "example": "0 [0, 1]",
                "description": "should be called clouds_target, controls amount of cloud cover in the sky"
            },
            {
                "type": "float",
                "name": "fog",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "fog_target",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "intro_weather",
                "example": "0 [0, 1]",
                "description": "if set, will set the weather to be nice all the time"
            },
            {
                "type": "float",
                "name": "wind",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "wind_speed",
                "example": "2 [-50, 50]"
            },
            {
                "type": "float",
                "name": "wind_speed_sin_t",
                "example": "10 [0, 1]"
            },
            {
                "type": "float",
                "name": "wind_speed_sin",
                "example": "3 [-50, 50]"
            },
            {
                "type": "float",
                "name": "clouds_01_target",
                "example": "0 [-27, 100]"
            },
            {
                "type": "float",
                "name": "clouds_02_target",
                "example": "0 [-100, 185]"
            },
            {
                "type": "float",
                "name": "gradient_sky_alpha_target",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "sky_sunset_alpha_target",
                "example": "1 [0, 1]"
            },
            {
                "type": "int",
                "name": "lightning_count",
                "example": "0 [0, 100]",
                "description": "this gets decreased to 0, this is the frame count of how many times do we do our awesome lightning effect"
            },
            {
                "type": "uint32",
                "name": "next_portal_id",
                "example": "1 [0, 1]"
            },
            {
                "type": "std::string",
                "name": "session_stat_file",
                "description": "if empty, we'll create one. This tracks the play time, death, kills... etch"
            },
            {
                "type": "int",
                "name": "player_polymorph_count",
                "example": "0 [0, 1]",
                "description": "how many times player has been polymorphed"
            },
            {
                "type": "int",
                "name": "player_polymorph_random_count",
                "example": "0 [0, 1]",
                "description": "how many times player has been random polymorphed"
            },
            {
                "type": "int",
                "name": "player_did_infinite_spell_count",
                "example": "0 [0, 1]",
                "description": "how many times player has done a secret trick"
            },
            {
                "type": "int",
                "name": "player_did_damage_over_1milj",
                "example": "0 [0, 1]",
                "description": "how many times player has player done damage of over 1000000"
            },
            {
                "type": "int",
                "name": "player_living_with_minus_hp",
                "example": "0 [0, 1]",
                "description": "how many times player has been detected with minus health"
            },
            {
                "type": "float",
                "name": "global_genome_relations_modifier",
                "example": "0 [0, 1]",
                "description": "Genome_GetHerdRelation adds this value to the results. 100 = good relations, 0 is bad "
            },
            {
                "type": "bool",
                "name": "mods_have_been_active_during_this_run",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "twitch_has_been_active_during_this_run",
                "example": "0 [0, 1]"
            },
            {
                "type": "uint32",
                "name": "next_cut_through_world_id",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "perk_infinite_spells",
                "example": "0 [0, 1]",
                "description": "if true, almost all spells will have unlimited uses. (black holes, matter eater, heals excluded"
            },
            {
                "type": "bool",
                "name": "perk_trick_kills_blood_money",
                "example": "0 [0, 1]",
                "description": "if true, trick kills will produce blood money (heals player)"
            },
            {
                "type": "int",
                "name": "perk_hp_drop_chance",
                "example": "0 [0, 1]",
                "description": "if > 0, then there's chance that killing an enemy will drop bloodmoney_50"
            },
            {
                "type": "bool",
                "name": "perk_gold_is_forever",
                "example": "0 [0, 1]",
                "description": "drop_money.lua - checks if this is true and removes Lifetime_Component from gold nuggets"
            },
            {
                "type": "bool",
                "name": "perk_rats_player_friendly",
                "example": "0 [0, 1]",
                "description": "if 1, rats don't attack player herd and the other way round. this is a persistent change"
            },
            {
                "type": "bool",
                "name": "EVERYTHING_TO_GOLD",
                "example": "0 [0, 1]",
                "description": "if true everything will be gold + used to track if the wallet should go to infinite"
            },
            {
                "type": "std::string",
                "name": "material_everything_to_gold",
                "example": "gold [0, 1]"
            },
            {
                "type": "std::string",
                "name": "material_everything_to_gold_static",
                "example": "gold_static [0, 1]"
            },
            {
                "type": "bool",
                "name": "INFINITE_GOLD_HAPPENING",
                "example": "0 [0, 1]",
                "description": "the secret ending with infinite gold"
            },
            {
                "type": "bool",
                "name": "ENDING_HAPPINESS_HAPPENING",
                "example": "0 [0, 1]",
                "description": "if true, will do the animations for happiness ending"
            },
            {
                "type": "int",
                "name": "ENDING_HAPPINESS_FRAMES",
                "example": "0 [0, 1]",
                "description": "to keep track of the animation"
            },
            {
                "type": "bool",
                "name": "ENDING_HAPPINESS",
                "example": "0 [0, 1]",
                "description": "this is set if ending happiness has happened"
            },
            {
                "type": "float",
                "name": "mFlashAlpha",
                "example": "0 [0, 1]",
                "description": "to keep track of the animation"
            },
            {
                "type": "int",
                "name": "DEBUG_LOADED_FROM_AUTOSAVE",
                "example": "0 [0, 1]",
                "description": "how many times have loaded from autosaves"
            },
            {
                "type": "int",
                "name": "DEBUG_LOADED_FROM_OLD_VERSION",
                "example": "0 [0, 1]",
                "description": "how many times have we loaded from an old version of the game"
            }
        ],
        "privates": [
            {
                "type": "float",
                "name": "rain_target_extra",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "fog_target_extra",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "perk_rats_player_friendly_prev",
                "example": "0 [0, 1]"
            }
        ],
        "custom_data_types": [
            {
                "type": "vec2",
                "name": "player_spawn_location"
            },
            {
                "type": "MAP_STRING_STRING",
                "name": "lua_globals"
            },
            {
                "type": "VEC_PENDINGPORTAL",
                "name": "pending_portals"
            },
            {
                "type": "VECTOR_INT32",
                "name": "apparitions_per_level"
            },
            {
                "type": "VEC_NPCPARTY",
                "name": "npc_parties"
            },
            {
                "type": "VECTOR_INT32",
                "name": "orbs_found_thisrun"
            },
            {
                "type": "VECTOR_STRING",
                "name": "flags"
            },
            {
                "type": "VECTOR_STRING",
                "name": "changed_materials",
                "description": "pairs of materials changed via ConvertMaterialEverywhere(). stored so these can be restored when loading a save"
            },
            {
                "type": "VEC_CUTTHROUGHWORLD",
                "name": "cuts_through_world"
            },
            {
                "type": "LensValue<int>",
                "name": "gore_multiplier"
            },
            {
                "type": "LensValue<int>",
                "name": "trick_kill_gold_multiplier"
            },
            {
                "type": "LensValue<float>",
                "name": "damage_flash_multiplier"
            },
            {
                "type": "LensValue<bool>",
                "name": "open_fog_of_war_everywhere",
                "description": "same as the trailer mode, open fog of war everywhere"
            },
            {
                "type": "LensValue<bool>",
                "name": "consume_actions",
                "description": "same as the trailer mode, spells with limited uses are not consumed if this is false"
            }
        ]
    },
    {
        "name": "WormAIComponent",
        "members": [
            {
                "type": "float",
                "name": "speed",
                "example": "1 [0, 10000]"
            },
            {
                "type": "float",
                "name": "speed_hunt",
                "example": "3 [0, 10000]"
            },
            {
                "type": "float",
                "name": "direction_adjust_speed",
                "example": "1 [0, 10000]"
            },
            {
                "type": "float",
                "name": "direction_adjust_speed_hunt",
                "example": "1 [0, 10000]"
            },
            {
                "type": "float",
                "name": "random_target_box_radius",
                "example": "512 [0, 10000]"
            },
            {
                "type": "int",
                "name": "new_hunt_target_check_every",
                "example": "30 [0, 10000]"
            },
            {
                "type": "int",
                "name": "new_random_target_check_every",
                "example": "120 [0, 10000]"
            },
            {
                "type": "float",
                "name": "hunt_box_radius",
                "example": "512 [0, 10000]"
            },
            {
                "type": "int",
                "name": "cocoon_food_required",
                "example": "30 [0, 1]",
                "description": "how much food do we need to consume before we can cocoon"
            },
            {
                "type": "std::string",
                "name": "cocoon_entity",
                "description": "if empty, won't cocoon, if set it'll spawn this after it's eaten enough"
            },
            {
                "type": "float",
                "name": "give_up_area_radius",
                "example": "50 [0, 10000]"
            },
            {
                "type": "int",
                "name": "give_up_time_frames",
                "example": "300 [0, 10000]"
            },
            {
                "type": "bool",
                "name": "debug_follow_mouse",
                "example": "0 [0, 1]"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mRandomTarget"
            },
            {
                "type": "int",
                "name": "mTargetEntityId",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextTargetCheckFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mNextHuntTargetCheckFrame",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mGiveUpStarted",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mGiveUpAreaMinX",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mGiveUpAreaMinY",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mGiveUpAreaMaxX",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mGiveUpAreaMaxY",
                "example": "0 [0, 1]"
            }
        ]
    },
    {
        "name": "WormAttractorComponent",
        "members": [
            {
                "type": "int",
                "name": "direction",
                "example": "1 [-1, 1]",
                "description": "1 = attracts worms, -1 detracts worms"
            },
            {
                "type": "float",
                "name": "radius",
                "example": "50 [0, 100]",
                "description": "radius of detracting worms"
            }
        ]
    },
    {
        "name": "WormComponent",
        "members": [
            {
                "type": "float",
                "name": "speed",
                "example": "1 [0, 10000]"
            },
            {
                "type": "float",
                "name": "acceleration",
                "example": "3 [0, 10000]"
            },
            {
                "type": "float",
                "name": "gravity",
                "example": "3 [0, 10000]"
            },
            {
                "type": "float",
                "name": "tail_gravity",
                "example": "30 [0, 10000]"
            },
            {
                "type": "float",
                "name": "part_distance",
                "example": "10 [0, 10000]"
            },
            {
                "type": "int",
                "name": "ground_check_offset",
                "example": "0 [0, 10000]"
            },
            {
                "type": "float",
                "name": "hitbox_radius",
                "example": "1 [0, 1e+006]"
            },
            {
                "type": "float",
                "name": "bite_damage",
                "example": "1 [0, 10]",
                "description": "how much damage does this do when it hits an entity"
            },
            {
                "type": "float",
                "name": "target_kill_radius",
                "example": "1 [0, 1e+006]"
            },
            {
                "type": "float",
                "name": "target_kill_ragdoll_force",
                "example": "1 [0, 1e+006]"
            },
            {
                "type": "float",
                "name": "jump_cam_shake",
                "example": "4 [0, 10000]"
            },
            {
                "type": "float",
                "name": "jump_cam_shake_distance",
                "example": "256 [0, 10000]"
            },
            {
                "type": "float",
                "name": "eat_anim_wait_mult",
                "example": "0.05 [0, 10000]"
            },
            {
                "type": "std::string",
                "name": "ragdoll_filename"
            },
            {
                "type": "bool",
                "name": "is_water_worm",
                "example": "0 [0, 1]",
                "description": "if true, tries to stay in liquids"
            },
            {
                "type": "float",
                "name": "max_speed",
                "example": "25 [0, 1]",
                "description": "max speed, used when attracted to a point"
            }
        ],
        "privates": [
            {
                "type": "vec2",
                "name": "mTargetVec"
            },
            {
                "type": "float",
                "name": "mGravVelocity",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mSpeed",
                "example": "0 [0, 1]"
            },
            {
                "type": "vec2",
                "name": "mTargetPosition"
            },
            {
                "type": "float",
                "name": "mTargetSpeed",
                "example": "0 [0, 1]"
            },
            {
                "type": "bool",
                "name": "mOnGroundPrev",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mMaterialIdPrev",
                "example": "0 [0, 1]"
            },
            {
                "type": "int",
                "name": "mFrameNextDamage",
                "example": "0 [0, 1]"
            },
            {
                "type": "float",
                "name": "mDirectionAdjustSpeed",
                "example": "1 [0, 1]"
            },
            {
                "type": "WormPartPositions",
                "name": "mPrevPositions"
            }
        ],
        "custom_data_types": [
            {
                "type": "LensValue<float>",
                "name": "ground_decceleration"
            }
        ]
    },
    {
        "name": "WormPlayerComponent",
        "privates": [
            {
                "type": "vec2",
                "name": "mPrevPosition"
            },
            {
                "type": "vec2",
                "name": "mDirection",
                "description": "if mDirection == 0,0 nothings works"
            }
        ]
    }
]